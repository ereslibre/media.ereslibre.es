Index: apps/dolphin/src/dolphinsortfilterproxymodel.cpp
===================================================================
--- apps/dolphin/src/dolphinsortfilterproxymodel.cpp	(revisión: 708805)
+++ apps/dolphin/src/dolphinsortfilterproxymodel.cpp	(copia de trabajo)
@@ -29,20 +29,21 @@
 #include <nepomuk/tag.h>
 #endif
 
-#include <kdirmodel.h>
+#include "dolphinmodel.h"
+
 #include <kfileitem.h>
 #include <kdatetime.h>
 #include <klocale.h>
 
 static DolphinView::Sorting sortingTypeTable[] =
 {
-    DolphinView::SortByName,        // KDirModel::Name
-    DolphinView::SortBySize,        // KDirModel::Size
-    DolphinView::SortByDate,        // KDirModel::ModifiedTime
-    DolphinView::SortByPermissions, // KDirModel::Permissions
-    DolphinView::SortByOwner,       // KDirModel::Owner
-    DolphinView::SortByGroup,       // KDirModel::Group
-    DolphinView::SortByType         // KDirModel::Type
+    DolphinView::SortByName,        // DolphinModel::Name
+    DolphinView::SortBySize,        // DolphinModel::Size
+    DolphinView::SortByDate,        // DolphinModel::ModifiedTime
+    DolphinView::SortByPermissions, // DolphinModel::Permissions
+    DolphinView::SortByOwner,       // DolphinModel::Owner
+    DolphinView::SortByGroup,       // DolphinModel::Group
+    DolphinView::SortByType         // DolphinModel::Type
 #ifdef HAVE_NEPOMUK
     , DolphinView::SortByRating
     , DolphinView::SortByTags
@@ -91,13 +92,12 @@
 bool DolphinSortFilterProxyModel::lessThanGeneralPurpose(const QModelIndex &left,
                                                          const QModelIndex &right) const
 {
-    KDirModel* dirModel = static_cast<KDirModel*>(sourceModel());
+    DolphinModel* dolphinModel = static_cast<DolphinModel*>(sourceModel());
 
-    const KFileItem leftFileItem  = dirModel->itemForIndex(left);
-    const KFileItem rightFileItem = dirModel->itemForIndex(right);
+    const KFileItem leftFileItem  = dolphinModel->itemForIndex(left);
+    const KFileItem rightFileItem = dolphinModel->itemForIndex(right);
 
-    //FIXME left.column() should be used instead!
-    switch (sortRole()) {
+    switch (left.column()) {
     case DolphinView::SortByName: {
         QString leftFileName(leftFileItem.name());
         if (leftFileName.at(0) == '.') {
@@ -109,8 +109,7 @@
             rightFileName = rightFileName.mid(1);
         }
 
-        // We don't care about case for building categories. We also don't
-        // want here to compare by a natural comparison.
+        // We don't care about case for building categories.
         return naturalCompare(leftFileName, rightFileName) < 0;
     }
 
@@ -154,20 +153,20 @@
     }
 #ifdef HAVE_NEPOMUK
     case DolphinView::SortByRating: {
-        const quint32 leftRating = ratingForIndex(left);
-        const quint32 rightRating = ratingForIndex(right);
+        const quint32 leftRating = DolphinModel::ratingForIndex(left);
+        const quint32 rightRating = DolphinModel::ratingForIndex(right);
         return leftRating > rightRating;
     }
     case DolphinView::SortByTags: {
-        const QString leftTags = tagsForIndex(left);
-        const QString rightTags = tagsForIndex(right);
+        const QString leftTags = DolphinModel::tagsForIndex(left);
+        const QString rightTags = DolphinModel::tagsForIndex(right);
 
         if (leftTags.isEmpty() && !rightTags.isEmpty())
             return false;
         else if (!leftTags.isEmpty() && rightTags.isEmpty())
             return true;
 
-        return naturalCompare(tagsForIndex(left), tagsForIndex(right)) < 0;
+        return naturalCompare(DolphinModel::tagsForIndex(left), DolphinModel::tagsForIndex(right)) < 0;
     }
 #endif
     default:
@@ -180,10 +179,10 @@
                                            const QModelIndex& right) const
 {
 #ifdef HAVE_NEPOMUK
-    KDirModel* dirModel = static_cast<KDirModel*>(sourceModel());
+    DolphinModel* dolphinModel = static_cast<DolphinModel*>(sourceModel());
 
-    const KFileItem leftFileItem  = dirModel->itemForIndex(left);
-    const KFileItem rightFileItem = dirModel->itemForIndex(right);
+    const KFileItem leftFileItem  = dolphinModel->itemForIndex(left);
+    const KFileItem rightFileItem = dolphinModel->itemForIndex(right);
 
 
     // Hidden elements go before visible ones, if they both are
@@ -194,11 +193,10 @@
         return false;
     }
 
-    //FIXME left.column() should be used instead!
-    switch (sortRole()) {
+    switch (left.column()) {
     case DolphinView::SortByRating: {
-        const quint32 leftRating  = ratingForIndex(left);
-        const quint32 rightRating = ratingForIndex(right);
+        const quint32 leftRating  = DolphinModel::ratingForIndex(left);
+        const quint32 rightRating = DolphinModel::ratingForIndex(right);
 
         if (leftRating == rightRating) {
             // On our priority, folders go above regular files.
@@ -222,8 +220,8 @@
     }
 
     case DolphinView::SortByTags: {
-        const QString leftTags = tagsForIndex(left);
-        const QString rightTags = tagsForIndex(right);
+        const QString leftTags = DolphinModel::tagsForIndex(left);
+        const QString rightTags = DolphinModel::tagsForIndex(right);
 
         if (leftTags == rightTags) {
             // On our priority, folders go above regular files.
@@ -251,55 +249,4 @@
     return KDirSortFilterProxyModel::lessThan(left, right);
 }
 
-quint32 DolphinSortFilterProxyModel::ratingForIndex(const QModelIndex& index)
-{
-#ifdef HAVE_NEPOMUK
-    quint32 rating = 0;
-
-    const KDirModel* dirModel = static_cast<const KDirModel*>(index.model());
-    KFileItem item = dirModel->itemForIndex(index);
-    if (!item.isNull()) {
-        const Nepomuk::Resource resource(item.url().url(), Nepomuk::NFO::File());
-        rating = resource.rating();
-    }
-    return rating;
-#else
-    Q_UNUSED(index);
-    return 0;
-#endif
-}
-
-QString DolphinSortFilterProxyModel::tagsForIndex(const QModelIndex& index)
-{
-#ifdef HAVE_NEPOMUK
-    QString tagsString;
-
-    const KDirModel* dirModel = static_cast<const KDirModel*>(index.model());
-    KFileItem item = dirModel->itemForIndex(index);
-    if (!item.isNull()) {
-        const Nepomuk::Resource resource(item.url().url(), Nepomuk::NFO::File());
-        const QList<Nepomuk::Tag> tags = resource.tags();
-        QStringList stringList;
-        foreach (const Nepomuk::Tag& tag, tags) {
-            stringList.append(tag.label());
-        }
-        stringList.sort();
-
-        foreach (const QString& str, stringList) {
-            tagsString += str;
-            tagsString += ", ";
-        }
-
-        if (!tagsString.isEmpty()) {
-            tagsString.resize(tagsString.size() - 2);
-        }
-    }
-
-    return tagsString;
-#else
-    Q_UNUSED(index);
-    return QString();
-#endif
-}
-
 #include "dolphinsortfilterproxymodel.moc"
Index: apps/dolphin/src/dolphincolumnview.cpp
===================================================================
--- apps/dolphin/src/dolphincolumnview.cpp	(revisión: 708805)
+++ apps/dolphin/src/dolphincolumnview.cpp	(copia de trabajo)
@@ -19,6 +19,7 @@
 
 #include "dolphincolumnview.h"
 
+#include "dolphinmodel.h"
 #include "dolphincontroller.h"
 #include "dolphinsettings.h"
 
@@ -27,7 +28,6 @@
 #include <kcolorutils.h>
 #include <kcolorscheme.h>
 #include <kdirlister.h>
-#include <kdirmodel.h>
 
 #include <QAbstractProxyModel>
 #include <QApplication>
@@ -299,9 +299,9 @@
     if (index.isValid()) {
         // a click on an item has been done
         const QAbstractProxyModel* proxyModel = static_cast<const QAbstractProxyModel*>(m_view->model());
-        const KDirModel* dirModel = static_cast<const KDirModel*>(proxyModel->sourceModel());
+        const DolphinModel* dolphinModel = static_cast<const DolphinModel*>(proxyModel->sourceModel());
         const QModelIndex dirIndex = proxyModel->mapToSource(index);
-        KFileItem item = dirModel->itemForIndex(dirIndex);
+        KFileItem item = dolphinModel->itemForIndex(dirIndex);
         if (!item.isNull()) {
             QItemSelectionModel* selModel = selectionModel();
 
@@ -378,8 +378,8 @@
     if (!m_childUrl.isEmpty()) {
         // indicate the shown URL of the next column by highlighting the shown folder item
         const QAbstractProxyModel* proxyModel = static_cast<const QAbstractProxyModel*>(m_view->model());
-        const KDirModel* dirModel = static_cast<const KDirModel*>(proxyModel->sourceModel());
-        const QModelIndex dirIndex = dirModel->indexForUrl(m_childUrl);
+        const DolphinModel* dolphinModel = static_cast<const DolphinModel*>(proxyModel->sourceModel());
+        const QModelIndex dirIndex = dolphinModel->indexForUrl(m_childUrl);
         const QModelIndex proxyIndex = proxyModel->mapFromSource(dirIndex);
         if (proxyIndex.isValid() && !selectionModel()->isSelected(proxyIndex)) {
             const QRect itemRect = visualRect(proxyIndex);
@@ -512,10 +512,10 @@
         columnUrl = m_controller->url();
     } else {
         const QAbstractProxyModel* proxyModel = static_cast<const QAbstractProxyModel*>(model());
-        const KDirModel* dirModel = static_cast<const KDirModel*>(proxyModel->sourceModel());
+        const DolphinModel* dolphinModel = static_cast<const DolphinModel*>(proxyModel->sourceModel());
 
-        const QModelIndex dirModelIndex = proxyModel->mapToSource(index);
-        KFileItem fileItem = dirModel->itemForIndex(dirModelIndex);
+        const QModelIndex dolphinModelIndex = proxyModel->mapToSource(index);
+        KFileItem fileItem = dolphinModel->itemForIndex(dolphinModelIndex);
         if (!fileItem.isNull()) {
             columnUrl = fileItem.url();
         }
Index: apps/dolphin/src/dolphinpart.cpp
===================================================================
--- apps/dolphin/src/dolphinpart.cpp	(revisión: 708805)
+++ apps/dolphin/src/dolphinpart.cpp	(copia de trabajo)
@@ -20,9 +20,9 @@
 #include "dolphinpart.h"
 #include "dolphinsortfilterproxymodel.h"
 #include "dolphinview.h"
+#include "dolphinmodel.h"
 
 #include <kdirlister.h>
-#include <kdirmodel.h>
 #include <kmessagebox.h>
 #include <kparts/browserextension.h>
 #include <kparts/genericfactory.h>
@@ -53,16 +53,16 @@
     connect(m_dirLister, SIGNAL(completed(KUrl)), this, SLOT(slotCompleted(KUrl)));
     connect(m_dirLister, SIGNAL(canceled(KUrl)), this, SLOT(slotCanceled(KUrl)));
 
-    m_dirModel = new KDirModel(this);
-    m_dirModel->setDirLister(m_dirLister);
+    m_dolphinModel = new DolphinModel(this);
+    m_dolphinModel->setDirLister(m_dirLister);
 
     m_proxyModel = new DolphinSortFilterProxyModel(this);
-    m_proxyModel->setSourceModel(m_dirModel);
+    m_proxyModel->setSourceModel(m_dolphinModel);
 
     m_view = new DolphinView(parentWidget,
                              KUrl(),
                              m_dirLister,
-                             m_dirModel,
+                             m_dolphinModel,
                              m_proxyModel);
     setWidget(m_view);
 
Index: apps/dolphin/src/treeviewsidebarpage.h
===================================================================
--- apps/dolphin/src/treeviewsidebarpage.h	(revisión: 708805)
+++ apps/dolphin/src/treeviewsidebarpage.h	(copia de trabajo)
@@ -24,7 +24,7 @@
 #include <sidebarpage.h>
 
 class KDirLister;
-class KDirModel;
+class DolphinModel;
 
 class DolphinSortFilterProxyModel;
 class SidebarTreeView;
@@ -110,7 +110,7 @@
 
 private:
     KDirLister* m_dirLister;
-    KDirModel* m_dirModel;
+    DolphinModel* m_dolphinModel;
     DolphinSortFilterProxyModel* m_proxyModel;
     SidebarTreeView* m_treeView;
     KUrl m_leafDir;
Index: apps/dolphin/src/dolphinmainwindow.cpp
===================================================================
--- apps/dolphin/src/dolphinmainwindow.cpp	(revisión: 708805)
+++ apps/dolphin/src/dolphinmainwindow.cpp	(copia de trabajo)
@@ -933,7 +933,7 @@
 
 void DolphinMainWindow::findFile()
 {
-    KRun::run("kfind", m_activeViewContainer->url(), this);
+    m_activeViewContainer->showFindPart();
 }
 
 void DolphinMainWindow::compareFiles()
Index: apps/dolphin/src/kcategorizedview_p.h
===================================================================
--- apps/dolphin/src/kcategorizedview_p.h	(revisión: 708805)
+++ apps/dolphin/src/kcategorizedview_p.h	(copia de trabajo)
@@ -21,7 +21,8 @@
 #ifndef KCATEGORIZEDVIEW_P_H
 #define KCATEGORIZEDVIEW_P_H
 
-class DolphinSortFilterProxyModel;
+class KCategorizedSortFilterProxyModel;
+class KCategoryDrawer;
 
 /**
   * @internal
@@ -122,7 +123,7 @@
 
     // Basic data
     KCategorizedView *listView;
-    KItemCategorizer *itemCategorizer;
+    KCategoryDrawer *categoryDrawer;
     QSize biggestItemSize;
 
     // Behavior data
@@ -140,10 +141,10 @@
     // Cache data
     // We cannot merge some of them into structs because it would affect
     // performance
-    QHash<QModelIndex, struct ElementInfo> elementsInfo; // in source model
-    QHash<QModelIndex, QRect> elementsPosition;          // in source model
-    QHash<QModelIndex, QModelIndex> elementDictionary;   // mapped indexes
-    QHash<QModelIndex, QModelIndex> invertedElementDictionary;   // mapped indexes
+    QHash<int, struct ElementInfo> elementsInfo; // in source model
+    QHash<int, QRect> elementsPosition;          // in source model
+    QHash<int, QModelIndex> elementDictionary;   // mapped indexes
+    QHash<int, QModelIndex> invertedElementDictionary;   // mapped indexes
     QHash<QString, QModelIndexList> categoriesIndexes;
     QHash<QString, QRect> categoriesPosition;
     QStringList categories;
@@ -152,7 +153,7 @@
     QRect lastSelectionRect;
 
     // Attributes for speed reasons
-    DolphinSortFilterProxyModel *proxyModel;
+    KCategorizedSortFilterProxyModel *proxyModel;
     QModelIndexList sourceModelIndexList;                // in source model
 };
 
Index: apps/dolphin/src/dolphindetailsview.cpp
===================================================================
--- apps/dolphin/src/dolphindetailsview.cpp	(revisión: 708805)
+++ apps/dolphin/src/dolphindetailsview.cpp	(copia de trabajo)
@@ -20,6 +20,7 @@
 
 #include "dolphindetailsview.h"
 
+#include "dolphinmodel.h"
 #include "dolphincontroller.h"
 #include "dolphinsettings.h"
 #include "dolphinsortfilterproxymodel.h"
@@ -27,8 +28,6 @@
 
 #include "dolphin_detailsmodesettings.h"
 
-#include <kdirmodel.h>
-
 #include <QApplication>
 #include <QHeaderView>
 #include <QRubberBand>
@@ -118,23 +117,23 @@
         const DetailsModeSettings* settings = DolphinSettings::instance().detailsModeSettings();
         Q_ASSERT(settings != 0);
         if (!settings->showDate()) {
-            hideColumn(KDirModel::ModifiedTime);
+            hideColumn(DolphinModel::ModifiedTime);
         }
 
         if (!settings->showPermissions()) {
-            hideColumn(KDirModel::Permissions);
+            hideColumn(DolphinModel::Permissions);
         }
 
         if (!settings->showOwner()) {
-            hideColumn(KDirModel::Owner);
+            hideColumn(DolphinModel::Owner);
         }
 
         if (!settings->showGroup()) {
-            hideColumn(KDirModel::Group);
+            hideColumn(DolphinModel::Group);
         }
 
         if (!settings->showType()) {
-            hideColumn(KDirModel::Type);
+            hideColumn(DolphinModel::Type);
         }
     }
 
@@ -159,7 +158,7 @@
     QTreeView::mousePressEvent(event);
 
     const QModelIndex index = indexAt(event->pos());
-    if (!index.isValid() || (index.column() != KDirModel::Name)) {
+    if (!index.isValid() || (index.column() != DolphinModel::Name)) {
         const Qt::KeyboardModifiers modifier = QApplication::keyboardModifiers();
         if (!(modifier & Qt::ShiftModifier) && !(modifier & Qt::ControlModifier)) {
             clearSelection();
@@ -223,7 +222,7 @@
     // TODO: remove this code when the issue #160611 is solved in Qt 4.4
     setDirtyRegion(m_dropRect);
     const QModelIndex index = indexAt(event->pos());
-    if (!index.isValid() || (index.column() != KDirModel::Name)) {
+    if (!index.isValid() || (index.column() != DolphinModel::Name)) {
         m_dragging = false;
     } else {
         m_dragging = true;
@@ -296,7 +295,7 @@
 void DolphinDetailsView::slotEntered(const QModelIndex& index)
 {
     const QPoint pos = viewport()->mapFromGlobal(QCursor::pos());
-    const int nameColumnWidth = header()->sectionSize(KDirModel::Name);
+    const int nameColumnWidth = header()->sectionSize(DolphinModel::Name);
     if (pos.x() < nameColumnWidth) {
         m_controller->emitItemEntered(index);
     }
Index: apps/dolphin/src/dolphinviewcontainer.h
===================================================================
--- apps/dolphin/src/dolphinviewcontainer.h	(revisión: 708805)
+++ apps/dolphin/src/dolphinviewcontainer.h	(copia de trabajo)
@@ -23,7 +23,6 @@
 
 #include "dolphinview.h"
 
-#include <kparts/part.h>
 #include <kfileitem.h>
 #include <kfileitemdelegate.h>
 #include <kio/job.h>
@@ -38,7 +37,7 @@
 
 class FilterBar;
 class KUrl;
-class KDirModel;
+class DolphinModel;
 class KUrlNavigator;
 class DolphinDirLister;
 class DolphinMainWindow;
@@ -46,6 +45,11 @@
 class DolphinStatusBar;
 class QModelIndex;
 
+namespace KParts
+{
+    class ReadOnlyPart;
+};
+
 /**
  * @short Represents a view for the directory content
  *        including the navigation bar, filter bar and status bar.
@@ -130,6 +134,16 @@
     void showFilterBar(bool show);
 
     /**
+     * Shows the find part dialog.
+     */
+    void showFindPart();
+
+    /**
+     * Closes the find part dialog.
+     */
+    void closeFindPart();
+
+    /**
      * Updates the number of items (= number of files + number of
      * directories) in the statusbar. If files are selected, the number
      * of selected files and the sum of the filesize is shown.
@@ -230,8 +244,9 @@
 
     FilterBar* m_filterBar;
     DolphinStatusBar* m_statusBar;
+    KParts::ReadOnlyPart* m_findPart;
 
-    KDirModel* m_dirModel;
+    DolphinModel* m_dolphinModel;
     DolphinDirLister* m_dirLister;
     DolphinSortFilterProxyModel* m_proxyModel;
 };
Index: apps/dolphin/src/dolphinsortfilterproxymodel.h
===================================================================
--- apps/dolphin/src/dolphinsortfilterproxymodel.h	(revisión: 708805)
+++ apps/dolphin/src/dolphinsortfilterproxymodel.h	(copia de trabajo)
@@ -25,7 +25,7 @@
 #include <libdolphin_export.h>
 
 /**
- * @brief Acts as proxy model for KDirModel to sort and filter
+ * @brief Acts as proxy model for DolphinModel to sort and filter
  *        KFileItems.
  *
  * A natural sorting is done. This means that items like:
@@ -37,7 +37,10 @@
  * - item_2.png
  * - item_10.png
  *
- * It is assured that directories are always sorted before files.
+ * @note It is NOT assured that directories are always sorted before files.
+ *       For example, on a Nepomuk based sorting, it is possible to have a file
+ *       rated with 10 stars, and a directory rated with 5 stars. The file will
+ *       be shown before the directory.
  */
 class LIBDOLPHINPRIVATE_EXPORT DolphinSortFilterProxyModel : public KDirSortFilterProxyModel
 {
@@ -84,13 +87,6 @@
     virtual bool lessThanGeneralPurpose(const QModelIndex &left,
                                         const QModelIndex &right) const;
 
-    /**
-     * For each category, that exists due to lessThanGeneralPurpose(), the
-     * lessThanCategoryPurpose() will be applied.
-     */
-    inline bool lessThanCategoryPurpose(const QModelIndex &left,
-                                        const QModelIndex &right) const;
-
 signals:
     void sortingRoleChanged();
 
@@ -99,23 +95,8 @@
                           const QModelIndex& right) const;
 
 private:
-    /**
-     * Returns the rating for the item with the index \a index. 0 is
-     * returned if no item could be found.
-     */
-    static quint32 ratingForIndex(const QModelIndex& index);
-
-    /**
-     * Returns the tags for the item with the index \a index. If no
-     * tag is applied, a predefined string will be returned.
-     */
-    static QString tagsForIndex(const QModelIndex& index);
-
-private:
     DolphinView::Sorting m_sorting:16;
     Qt::SortOrder m_sortOrder:16;
-
-    friend class DolphinItemCategorizer;
 };
 
 DolphinView::Sorting DolphinSortFilterProxyModel::sorting() const
@@ -128,10 +109,4 @@
     return m_sortOrder;
 }
 
-bool DolphinSortFilterProxyModel::lessThanCategoryPurpose(const QModelIndex &left,
-                                                          const QModelIndex &right) const
-{
-    return lessThan(left, right);
-}
-
 #endif
Index: apps/dolphin/src/treeviewsidebarpage.cpp
===================================================================
--- apps/dolphin/src/treeviewsidebarpage.cpp	(revisión: 708805)
+++ apps/dolphin/src/treeviewsidebarpage.cpp	(copia de trabajo)
@@ -19,6 +19,7 @@
 
 #include "treeviewsidebarpage.h"
 
+#include "dolphinmodel.h"
 #include "dolphinmainwindow.h"
 #include "dolphinsortfilterproxymodel.h"
 #include "dolphinview.h"
@@ -28,7 +29,6 @@
 
 #include <kfileplacesmodel.h>
 #include <kdirlister.h>
-#include <kdirmodel.h>
 #include <kfileitem.h>
 
 #include <QItemSelection>
@@ -39,7 +39,7 @@
 TreeViewSidebarPage::TreeViewSidebarPage(QWidget* parent) :
     SidebarPage(parent),
     m_dirLister(0),
-    m_dirModel(0),
+    m_dolphinModel(0),
     m_proxyModel(0),
     m_treeView(0),
     m_leafDir()
@@ -89,16 +89,16 @@
         m_dirLister->setDelayedMimeTypes(true);
         m_dirLister->setAutoErrorHandlingEnabled(false, this);
 
-        Q_ASSERT(m_dirModel == 0);
-        m_dirModel = new KDirModel(this);
-        m_dirModel->setDirLister(m_dirLister);
-        m_dirModel->setDropsAllowed(KDirModel::DropOnDirectory);
-        connect(m_dirModel, SIGNAL(expand(const QModelIndex&)),
+        Q_ASSERT(m_dolphinModel == 0);
+        m_dolphinModel = new DolphinModel(this);
+        m_dolphinModel->setDirLister(m_dirLister);
+        m_dolphinModel->setDropsAllowed(DolphinModel::DropOnDirectory);
+        connect(m_dolphinModel, SIGNAL(expand(const QModelIndex&)),
                 this, SLOT(triggerExpanding(const QModelIndex&)));
 
         Q_ASSERT(m_proxyModel == 0);
         m_proxyModel = new DolphinSortFilterProxyModel(this);
-        m_proxyModel->setSourceModel(m_dirModel);
+        m_proxyModel->setSourceModel(m_dolphinModel);
 
         Q_ASSERT(m_treeView == 0);
         m_treeView = new SidebarTreeView(this);
@@ -130,8 +130,8 @@
         return;
     }
 
-    const QModelIndex dirModelIndex = m_proxyModel->mapToSource(index);
-    KFileItem item = m_dirModel->itemForIndex(dirModelIndex);
+    const QModelIndex dolphinModelIndex = m_proxyModel->mapToSource(index);
+    KFileItem item = m_dolphinModel->itemForIndex(dolphinModelIndex);
 
     emit changeSelection(QList<KFileItem>());
     TreeViewContextMenu contextMenu(this, item);
@@ -149,13 +149,13 @@
         return;
     }
 
-    QModelIndex index = m_dirModel->indexForUrl(parentUrl);
+    QModelIndex index = m_dolphinModel->indexForUrl(parentUrl);
     if (index.isValid()) {
         QModelIndex proxyIndex = m_proxyModel->mapFromSource(index);
         m_treeView->setExpanded(proxyIndex, true);
 
         // select the item and assure that the item is visible
-        index = m_dirModel->indexForUrl(url());
+        index = m_dolphinModel->indexForUrl(url());
         if (index.isValid()) {
             proxyIndex = m_proxyModel->mapFromSource(index);
             m_treeView->scrollTo(proxyIndex);
@@ -169,7 +169,7 @@
 void TreeViewSidebarPage::updateActiveView(const QModelIndex& index)
 {
     const QModelIndex dirIndex = m_proxyModel->mapToSource(index);
-    const KFileItem item = m_dirModel->itemForIndex(dirIndex);
+    const KFileItem item = m_dolphinModel->itemForIndex(dirIndex);
     if (!item.isNull()) {
         emit changeUrl(item.url());
     }
@@ -180,7 +180,7 @@
 {
     if (index.isValid()) {
         const QModelIndex dirIndex = m_proxyModel->mapToSource(index);
-        KFileItem item = m_dirModel->itemForIndex(dirIndex);
+        KFileItem item = m_dolphinModel->itemForIndex(dirIndex);
         Q_ASSERT(!item.isNull());
         if (item.isDir()) {
             emit urlsDropped(urls, item.url());
@@ -200,12 +200,12 @@
 {
     // expand all directories until the parent directory of m_leafDir
     const KUrl parentUrl = m_leafDir.upUrl();
-    QModelIndex dirIndex = m_dirModel->indexForUrl(parentUrl);
+    QModelIndex dirIndex = m_dolphinModel->indexForUrl(parentUrl);
     QModelIndex proxyIndex = m_proxyModel->mapFromSource(dirIndex);
     m_treeView->setExpanded(proxyIndex, true);
 
     // assure that m_leafDir gets selected
-    dirIndex = m_dirModel->indexForUrl(m_leafDir);
+    dirIndex = m_dolphinModel->indexForUrl(m_leafDir);
     proxyIndex = m_proxyModel->mapFromSource(dirIndex);
     m_treeView->scrollTo(proxyIndex);
 
@@ -227,7 +227,7 @@
         return;
     }
 
-    const QModelIndex index = m_dirModel->indexForUrl(m_leafDir);
+    const QModelIndex index = m_dolphinModel->indexForUrl(m_leafDir);
     if (index.isValid()) {
         // the item with the given URL is already part of the model
         const QModelIndex proxyIndex = m_proxyModel->mapFromSource(index);
@@ -237,7 +237,7 @@
         // Load all sub directories that need to get expanded for making
         // the leaf directory visible. The slot triggerExpanding() will
         // get invoked if the expanding has been finished.
-        m_dirModel->expandToUrl(m_leafDir);
+        m_dolphinModel->expandToUrl(m_leafDir);
     }
 }
 
Index: apps/dolphin/src/dolphiniconsview.cpp
===================================================================
--- apps/dolphin/src/dolphiniconsview.cpp	(revisión: 708805)
+++ apps/dolphin/src/dolphiniconsview.cpp	(copia de trabajo)
@@ -21,7 +21,6 @@
 
 #include "dolphincontroller.h"
 #include "dolphinsettings.h"
-#include "dolphinitemcategorizer.h"
 
 #include "dolphin_iconsmodesettings.h"
 
@@ -33,7 +32,8 @@
 #include <QPoint>
 
 DolphinIconsView::DolphinIconsView(QWidget* parent, DolphinController* controller) :
-    KCategorizedView(parent),
+    //KCategorizedView(parent),
+    QListView(parent),
     m_controller(controller),
     m_itemSize(),
     m_dragging(false),
@@ -70,7 +70,8 @@
     const IconsModeSettings* settings = DolphinSettings::instance().iconsModeSettings();
     Q_ASSERT(settings != 0);
 
-    m_viewOptions = KCategorizedView::viewOptions();
+//    m_viewOptions = KCategorizedView::viewOptions();
+    m_viewOptions = QListView::viewOptions();
     m_viewOptions.showDecorationSelected = true;
 
     QFont font(settings->fontFamily(), settings->fontSize());
@@ -99,7 +100,8 @@
 {
     const bool leftToRightFlow = (flow() == QListView::LeftToRight);
 
-    QRect itemRect = KCategorizedView::visualRect(index);
+    //QRect itemRect = KCategorizedView::visualRect(index);
+    QRect itemRect = QListView::visualRect(index);
     const int maxWidth  = m_itemSize.width();
     const int maxHeight = m_itemSize.height();
 
@@ -131,7 +133,8 @@
 
 void DolphinIconsView::contextMenuEvent(QContextMenuEvent* event)
 {
-    KCategorizedView::contextMenuEvent(event);
+//    KCategorizedView::contextMenuEvent(event);
+    QListView::contextMenuEvent(event);
     m_controller->triggerContextMenuRequest(event->pos());
 }
 
@@ -145,7 +148,8 @@
         }
     }
 
-    KCategorizedView::mousePressEvent(event);
+    //KCategorizedView::mousePressEvent(event);
+    QListView::mousePressEvent(event);
 }
 
 void DolphinIconsView::dragEnterEvent(QDragEnterEvent* event)
@@ -158,7 +162,8 @@
 
 void DolphinIconsView::dragLeaveEvent(QDragLeaveEvent* event)
 {
-    KCategorizedView::dragLeaveEvent(event);
+    //KCategorizedView::dragLeaveEvent(event);
+    QListView::dragLeaveEvent(event);
 
     // TODO: remove this code when the issue #160611 is solved in Qt 4.4
     m_dragging = false;
@@ -167,7 +172,8 @@
 
 void DolphinIconsView::dragMoveEvent(QDragMoveEvent* event)
 {
-    KCategorizedView::dragMoveEvent(event);
+    //KCategorizedView::dragMoveEvent(event);
+    QListView::dragMoveEvent(event);
 
     // TODO: remove this code when the issue #160611 is solved in Qt 4.4
     const QModelIndex index = indexAt(event->pos());
@@ -187,13 +193,15 @@
             event->acceptProposedAction();
         }
     }
-    KCategorizedView::dropEvent(event);
+    //KCategorizedView::dropEvent(event);
+    QListView::dropEvent(event);
     m_dragging = false;
 }
 
 void DolphinIconsView::paintEvent(QPaintEvent* event)
 {
-    KCategorizedView::paintEvent(event);
+    //KCategorizedView::paintEvent(event);
+    QListView::paintEvent(event);
 
     // TODO: remove this code when the issue #160611 is solved in Qt 4.4
     if (m_dragging) {
Index: apps/dolphin/src/dolphinview.cpp
===================================================================
--- apps/dolphin/src/dolphinview.cpp	(revisión: 708805)
+++ apps/dolphin/src/dolphinview.cpp	(copia de trabajo)
@@ -29,7 +29,6 @@
 #include <QScrollBar>
 
 #include <kcolorscheme.h>
-#include <kdirmodel.h>
 #include <kdirlister.h>
 #include <kfileitemdelegate.h>
 #include <klocale.h>
@@ -42,12 +41,12 @@
 #include <konq_operations.h>
 #include <kurl.h>
 
+#include "dolphinmodel.h"
 #include "dolphincolumnview.h"
 #include "dolphincontroller.h"
 #include "dolphinsortfilterproxymodel.h"
 #include "dolphindetailsview.h"
 #include "dolphiniconsview.h"
-#include "dolphinitemcategorizer.h"
 #include "renamedialog.h"
 #include "viewproperties.h"
 #include "dolphinsettings.h"
@@ -56,7 +55,7 @@
 DolphinView::DolphinView(QWidget* parent,
                          const KUrl& url,
                          KDirLister* dirLister,
-                         KDirModel* dirModel,
+                         DolphinModel* dolphinModel,
                          DolphinSortFilterProxyModel* proxyModel) :
     QWidget(parent),
     m_active(true),
@@ -69,7 +68,7 @@
     m_detailsView(0),
     m_columnView(0),
     m_fileItemDelegate(0),
-    m_dirModel(dirModel),
+    m_dolphinModel(dolphinModel),
     m_dirLister(dirLister),
     m_proxyModel(proxyModel)
 {
@@ -224,14 +223,6 @@
     }
 
     Q_ASSERT(m_iconsView != 0);
-    if (categorized) {
-        Q_ASSERT(m_iconsView->itemCategorizer() == 0);
-        m_iconsView->setItemCategorizer(new DolphinItemCategorizer());
-    } else {
-        KItemCategorizer* categorizer = m_iconsView->itemCategorizer();
-        m_iconsView->setItemCategorizer(0);
-        delete categorizer;
-    }
 
     ViewProperties props(viewPropertiesUrl());
     props.setCategorizedSorting(categorized);
@@ -242,12 +233,7 @@
 
 bool DolphinView::categorizedSorting() const
 {
-    if (!supportsCategorizedSorting()) {
-        return false;
-    }
-
-    Q_ASSERT(m_iconsView != 0);
-    return m_iconsView->itemCategorizer() != 0;
+    return m_proxyModel->isCategorizedModel();
 }
 
 bool DolphinView::supportsCategorizedSorting() const
@@ -294,7 +280,7 @@
 {
     const QAbstractItemView* view = itemView();
 
-    // Our view has a selection, we will map them back to the DirModel
+    // Our view has a selection, we will map them back to the DolphinModel
     // and then fill the KFileItemList.
     Q_ASSERT((view != 0) && (view->selectionModel() != 0));
 
@@ -303,7 +289,7 @@
 
     const QModelIndexList indexList = selection.indexes();
     foreach (QModelIndex index, indexList) {
-        KFileItem item = m_dirModel->itemForIndex(index);
+        KFileItem item = m_dolphinModel->itemForIndex(index);
         if (!item.isNull()) {
             itemList.append(item);
         }
@@ -325,8 +311,8 @@
 
 KFileItem DolphinView::fileItem(const QModelIndex& index) const
 {
-    const QModelIndex dirModelIndex = m_proxyModel->mapToSource(index);
-    return m_dirModel->itemForIndex(dirModelIndex);
+    const QModelIndex dolphinModelIndex = m_proxyModel->mapToSource(index);
+    return m_dolphinModel->itemForIndex(dolphinModelIndex);
 }
 
 void DolphinView::setContentsPosition(int x, int y)
@@ -455,7 +441,8 @@
         return;
     }
 
-    const KFileItem item = m_dirModel->itemForIndex(m_proxyModel->mapToSource(index));
+    const KFileItem item = m_dolphinModel->itemForIndex(m_proxyModel->mapToSource(index));
+
     if (item.isNull()) {
         return;
     }
@@ -481,15 +468,15 @@
         return;
     }
 
-    const QModelIndex idx = m_dirModel->indexForItem(item);
+    const QModelIndex idx = m_dolphinModel->indexForItem(item);
     if (idx.isValid() && (idx.column() == 0)) {
         const QMimeData* mimeData = QApplication::clipboard()->mimeData();
         if (KonqMimeData::decodeIsCutSelection(mimeData) && isCutItem(item)) {
             KIconEffect iconEffect;
             const QPixmap cutPixmap = iconEffect.apply(pixmap, K3Icon::Desktop, K3Icon::DisabledState);
-            m_dirModel->setData(idx, QIcon(cutPixmap), Qt::DecorationRole);
+            m_dolphinModel->setData(idx, QIcon(cutPixmap), Qt::DecorationRole);
         } else {
-            m_dirModel->setData(idx, QIcon(pixmap), Qt::DecorationRole);
+            m_dolphinModel->setData(idx, QIcon(pixmap), Qt::DecorationRole);
         }
     }
 }
@@ -602,17 +589,6 @@
 
     const bool categorized = props.categorizedSorting();
     if (categorized != categorizedSorting()) {
-        if (supportsCategorizedSorting()) {
-            Q_ASSERT(m_iconsView != 0);
-            if (categorized) {
-                Q_ASSERT(m_iconsView->itemCategorizer() == 0);
-                m_iconsView->setItemCategorizer(new DolphinItemCategorizer());
-            } else {
-                KItemCategorizer* categorizer = m_iconsView->itemCategorizer();
-                m_iconsView->setItemCategorizer(0);
-                delete categorizer;
-            }
-        }
         emit categorizedSortingChanged();
     }
 
@@ -654,7 +630,7 @@
     foreach(const KFileItem& item, selection) {
         url = item.url().upUrl();
         if (baseUrl.equals(url, KUrl::CompareWithoutTrailingSlash)) {
-            QModelIndex index = m_proxyModel->mapFromSource(m_dirModel->indexForItem(item));
+            QModelIndex index = m_proxyModel->mapFromSource(m_dolphinModel->indexForItem(item));
             new_selection.select(index, index);
         }
     }
@@ -746,9 +722,9 @@
     QList<CutItem>::const_iterator it = m_cutItemsCache.begin();
     QList<CutItem>::const_iterator end = m_cutItemsCache.end();
     while (it != end) {
-        const QModelIndex index = m_dirModel->indexForUrl((*it).url);
+        const QModelIndex index = m_dolphinModel->indexForUrl((*it).url);
         if (index.isValid()) {
-            m_dirModel->setData(index, QIcon((*it).pixmap), Qt::DecorationRole);
+            m_dolphinModel->setData(index, QIcon((*it).pixmap), Qt::DecorationRole);
         }
         ++it;
     }
@@ -783,11 +759,6 @@
     if (view != 0) {
         m_topLayout->removeWidget(view);
         view->close();
-        if (view == m_iconsView) {
-            KItemCategorizer* categorizer = m_iconsView->itemCategorizer();
-            m_iconsView->setItemCategorizer(0);
-            delete categorizer;
-        }
         view->deleteLater();
         view = 0;
         m_iconsView = 0;
@@ -826,7 +797,7 @@
     view->setModel(m_proxyModel);
     view->setSelectionMode(QAbstractItemView::ExtendedSelection);
 
-    new KMimeTypeResolver(view, m_dirModel);
+    new KMimeTypeResolver(view, m_dolphinModel);
     m_topLayout->insertWidget(1, view);
 
     connect(view->selectionModel(), SIGNAL(selectionChanged(const QItemSelection&, const QItemSelection&)),
@@ -850,7 +821,7 @@
 
 bool DolphinView::isValidNameIndex(const QModelIndex& index) const
 {
-    return index.isValid() && (index.column() == KDirModel::Name);
+    return index.isValid() && (index.column() == DolphinModel::Name);
 }
 
 bool DolphinView::isCutItem(const KFileItem& item) const
@@ -884,10 +855,10 @@
     while (it != end) {
         KFileItem* item = *it;
         if (isCutItem(*item)) {
-            const QModelIndex index = m_dirModel->indexForItem(*item);
+            const QModelIndex index = m_dolphinModel->indexForItem(*item);
             // Huh? the item is already known
-            //const KFileItem item = m_dirModel->itemForIndex(index);
-            const QVariant value = m_dirModel->data(index, Qt::DecorationRole);
+            //const KFileItem item = m_dolphinModel->itemForIndex(index);
+            const QVariant value = m_dolphinModel->data(index, Qt::DecorationRole);
             if (value.type() == QVariant::Icon) {
                 const QIcon icon(qvariant_cast<QIcon>(value));
                 QPixmap pixmap = icon.pixmap(128, 128);
@@ -902,7 +873,7 @@
                 // apply icon effect to the cut item
                 KIconEffect iconEffect;
                 pixmap = iconEffect.apply(pixmap, K3Icon::Desktop, K3Icon::DisabledState);
-                m_dirModel->setData(index, QIcon(pixmap), Qt::DecorationRole);
+                m_dolphinModel->setData(index, QIcon(pixmap), Qt::DecorationRole);
             }
         }
         ++it;
Index: apps/dolphin/src/dolphinpart.h
===================================================================
--- apps/dolphin/src/dolphinpart.h	(revisión: 708805)
+++ apps/dolphin/src/dolphinpart.h	(copia de trabajo)
@@ -24,7 +24,7 @@
 class KFileItem;
 class DolphinPartBrowserExtension;
 class DolphinSortFilterProxyModel;
-class KDirModel;
+class DolphinModel;
 class KDirLister;
 class DolphinView;
 class QLineEdit;
@@ -71,7 +71,7 @@
 private:
     DolphinView* m_view;
     KDirLister* m_dirLister;
-    KDirModel* m_dirModel;
+    DolphinModel* m_dolphinModel;
     DolphinSortFilterProxyModel* m_proxyModel;
     DolphinPartBrowserExtension* m_extension;
     Q_DISABLE_COPY(DolphinPart)
Index: apps/dolphin/src/dolphinviewcontainer.cpp
===================================================================
--- apps/dolphin/src/dolphinviewcontainer.cpp	(revisión: 708805)
+++ apps/dolphin/src/dolphinviewcontainer.cpp	(copia de trabajo)
@@ -27,7 +27,6 @@
 #include <QtCore/QTimer>
 #include <QtGui/QScrollBar>
 
-#include <kdirmodel.h>
 #include <kfileitemdelegate.h>
 #include <kfileplacesmodel.h>
 #include <kglobalsettings.h>
@@ -40,7 +39,10 @@
 #include <konqmimedata.h>
 #include <konq_operations.h>
 #include <kurl.h>
+#include <kparts/componentfactory.h>
+#include <kparts/part.h>
 
+#include "dolphinmodel.h"
 #include "dolphincolumnview.h"
 #include "dolphincontroller.h"
 #include "dolphinstatusbar.h"
@@ -50,7 +52,6 @@
 #include "dolphindetailsview.h"
 #include "dolphiniconsview.h"
 #include "dolphincontextmenu.h"
-#include "dolphinitemcategorizer.h"
 #include "filterbar.h"
 #include "renamedialog.h"
 #include "kurlnavigator.h"
@@ -71,7 +72,8 @@
     m_view(0),
     m_filterBar(0),
     m_statusBar(0),
-    m_dirModel(0),
+    m_findPart(0),
+    m_dolphinModel(0),
     m_dirLister(0),
     m_proxyModel(0)
 {
@@ -100,12 +102,12 @@
     m_dirLister->setMainWindow(this);
     m_dirLister->setDelayedMimeTypes(true);
 
-    m_dirModel = new KDirModel();
-    m_dirModel->setDirLister(m_dirLister);
-    m_dirModel->setDropsAllowed(KDirModel::DropOnDirectory);
+    m_dolphinModel = new DolphinModel();
+    m_dolphinModel->setDirLister(m_dirLister);
+    m_dolphinModel->setDropsAllowed(DolphinModel::DropOnDirectory);
 
     m_proxyModel = new DolphinSortFilterProxyModel(this);
-    m_proxyModel->setSourceModel(m_dirModel);
+    m_proxyModel->setSourceModel(m_dolphinModel);
 
     connect(m_dirLister, SIGNAL(clear()),
             this, SLOT(updateStatusBar()));
@@ -123,7 +125,7 @@
     m_view = new DolphinView(this,
                              url,
                              m_dirLister,
-                             m_dirModel,
+                             m_dolphinModel,
                              m_proxyModel);
     connect(m_view, SIGNAL(urlChanged(const KUrl&)),
             m_urlNavigator, SLOT(setUrl(const KUrl&)));
@@ -272,8 +274,8 @@
 
 KFileItem DolphinViewContainer::fileItem(const QModelIndex& index) const
 {
-    const QModelIndex dirModelIndex = m_proxyModel->mapToSource(index);
-    return m_dirModel->itemForIndex(dirModelIndex);
+    const QModelIndex dolphinModelIndex = m_proxyModel->mapToSource(index);
+    return m_dolphinModel->itemForIndex(dolphinModelIndex);
 }
 
 void DolphinViewContainer::updateProgress(int percent)
@@ -406,6 +408,32 @@
     m_filterBar->setVisible(show);
 }
 
+void DolphinViewContainer::showFindPart()
+{
+    if (!m_findPart)
+    {
+        m_findPart = KParts::ComponentFactory::createPartInstanceFromLibrary<KParts::ReadOnlyPart>("libkfindpart",
+                                                                                                   this,
+                                                                                                   this);
+
+        m_findPart->openUrl(m_dirLister->url());
+
+        connect(m_findPart, SIGNAL(findClosed()), this, SLOT(closeFindPart()));
+        connect(m_dirLister, SIGNAL(started(const KUrl&)), m_findPart, SLOT(openUrl(const KUrl&)));
+
+        m_topLayout->insertWidget(3 /* below the filter bar, and above the status bar */,
+                                  m_findPart->widget());
+    }
+}
+
+void DolphinViewContainer::closeFindPart()
+{
+    disconnect(m_dirLister, SIGNAL(started(const KUrl&)), m_findPart, SLOT(openUrl(const KUrl&)));
+
+    delete m_findPart;
+    m_findPart = 0;
+}
+
 void DolphinViewContainer::updateStatusBar()
 {
     // As the item count information is less important
Index: apps/dolphin/src/kcategorizedview.cpp
===================================================================
--- apps/dolphin/src/kcategorizedview.cpp	(revisión: 708805)
+++ apps/dolphin/src/kcategorizedview.cpp	(copia de trabajo)
@@ -32,52 +32,12 @@
 #include <kdebug.h>
 #include <kstyle.h>
 
-#include "kitemcategorizer.h"
-#include "dolphinsortfilterproxymodel.h"
+#include "kcategorydrawer.h"
+#include "kcategorizedsortfilterproxymodel.h"
 
-class LessThan
-{
-public:
-    enum Purpose
-    {
-        GeneralPurpose = 0,
-        CategoryPurpose
-    };
-
-    inline LessThan(const DolphinSortFilterProxyModel *proxyModel,
-                    Purpose purpose)
-        : proxyModel(proxyModel)
-        , purpose(purpose)
-    {
-    }
-
-    inline bool operator()(const QModelIndex &left,
-                           const QModelIndex &right) const
-    {
-        if (purpose == GeneralPurpose)
-        {
-            return proxyModel->sortOrder() == Qt::AscendingOrder ?
-                   proxyModel->lessThanGeneralPurpose(left, right) :
-                   !proxyModel->lessThanGeneralPurpose(left, right);
-        }
-
-        return proxyModel->sortOrder() == Qt::AscendingOrder ?
-               proxyModel->lessThanCategoryPurpose(left, right) :
-               !proxyModel->lessThanCategoryPurpose(left, right);
-    }
-
-private:
-    const DolphinSortFilterProxyModel *proxyModel;
-    const Purpose purpose;
-};
-
-
-//==============================================================================
-
-
 KCategorizedView::Private::Private(KCategorizedView *listView)
     : listView(listView)
-    , itemCategorizer(0)
+    , categoryDrawer(0)
     , biggestItemSize(QSize(0, 0))
     , mouseButtonPressed(false)
     , isDragging(false)
@@ -116,7 +76,7 @@
     {
         middle = (top + bottom) / 2;
 
-        index = elementDictionary[proxyModel->index(middle, 0)];
+        index = elementDictionary[middle];
         indexVisualRect = visualRect(index);
         // We need the whole height (not only the visualRect). This will help us to update
         // all needed indexes correctly (ereslibre)
@@ -136,7 +96,7 @@
 
     for (int i = middle; i < proxyModel->rowCount(); i++)
     {
-        index = elementDictionary[proxyModel->index(i, 0)];
+        index = elementDictionary[i];
         indexVisualRect = visualRect(index);
 
         if (rect.intersects(indexVisualRect))
@@ -157,10 +117,10 @@
     if (!index.isValid())
         return QRect();
 
-    QString curCategory = elementsInfo[index].category;
+    QString curCategory = elementsInfo[index.row()].category;
 
     QRect retRect(listView->spacing(), listView->spacing() * 2 +
-                  itemCategorizer->categoryHeight(listView->viewOptions()), 0, 0);
+                  categoryDrawer->categoryHeight(listView->viewOptions()), 0, 0);
 
     int viewportWidth = listView->viewport()->width() - listView->spacing();
 
@@ -183,8 +143,8 @@
     if (!elementsPerRow)
         elementsPerRow++;
 
-    int column = elementsInfo[index].relativeOffsetToCategory % elementsPerRow;
-    int row = elementsInfo[index].relativeOffsetToCategory / elementsPerRow;
+    int column = elementsInfo[index.row()].relativeOffsetToCategory % elementsPerRow;
+    int row = elementsInfo[index.row()].relativeOffsetToCategory / elementsPerRow;
 
     retRect.setLeft(retRect.left() + column * listView->spacing() +
                     column * itemWidth);
@@ -202,7 +162,7 @@
 
         retRect.setTop(retRect.top() +
                        (rowsInt * itemHeight) +
-                       itemCategorizer->categoryHeight(listView->viewOptions()) +
+                       categoryDrawer->categoryHeight(listView->viewOptions()) +
                        listView->spacing() * 2);
 
         if (listView->gridSize().isEmpty())
@@ -286,7 +246,7 @@
 
         retRect.setTop(retRect.top() +
                        (rowsInt * itemHeight) +
-                       itemCategorizer->categoryHeight(listView->viewOptions()) +
+                       categoryDrawer->categoryHeight(listView->viewOptions()) +
                        listView->spacing() * 2);
 
         if (listView->gridSize().isEmpty())
@@ -296,7 +256,7 @@
         }
     }
 
-    retRect.setHeight(itemCategorizer->categoryHeight(listView->viewOptions()));
+    retRect.setHeight(categoryDrawer->categoryHeight(listView->viewOptions()));
 
     return retRect;
 }
@@ -305,9 +265,9 @@
 const QRect &KCategorizedView::Private::cacheIndex(const QModelIndex &index)
 {
     QRect rect = visualRectInViewport(index);
-    elementsPosition[index] = rect;
+    elementsPosition[index.row()] = rect;
 
-    return elementsPosition[index];
+    return elementsPosition[index.row()];
 }
 
 // We're sure categoriesPosition doesn't contain category
@@ -321,9 +281,9 @@
 
 const QRect &KCategorizedView::Private::cachedRectIndex(const QModelIndex &index)
 {
-    if (elementsPosition.contains(index)) // If we have it cached
+    if (elementsPosition.contains(index.row())) // If we have it cached
     {                                        // return it
-        return elementsPosition[index];
+        return elementsPosition[index.row()];
     }
     else                                     // Otherwise, cache it
     {                                        // and return it
@@ -366,29 +326,29 @@
 }
 
 void KCategorizedView::Private::drawNewCategory(const QModelIndex &index,
-                                         int sortRole,
-                                         const QStyleOption &option,
-                                         QPainter *painter)
+                                                int sortRole,
+                                                const QStyleOption &option,
+                                                QPainter *painter)
 {
     QStyleOption optionCopy = option;
-    const QString category = itemCategorizer->categoryForItem(index, sortRole);
+    const QString category = listView->model()->data(index, KCategorizedSortFilterProxyModel::CategoryRole).toString();
 
     if ((category == hoveredCategory) && !mouseButtonPressed)
     {
         optionCopy.state |= QStyle::State_MouseOver;
     }
 
-    itemCategorizer->drawCategory(index,
-                                  sortRole,
-                                  optionCopy,
-                                  painter);
+    categoryDrawer->drawCategory(index,
+                                 sortRole,
+                                 optionCopy,
+                                 painter);
 }
 
 
 void KCategorizedView::Private::updateScrollbars()
 {
-    // find the last index in the last category 
-    QModelIndex lastIndex = categoriesIndexes.isEmpty() ? QModelIndex() : categoriesIndexes[categories.last()].last(); 
+    // find the last index in the last category
+    QModelIndex lastIndex = categoriesIndexes.isEmpty() ? QModelIndex() : categoriesIndexes[categories.last()].last();
 
     int lastItemBottom = cachedRectIndex(lastIndex).top() +
                          listView->spacing() + (listView->gridSize().isEmpty() ? 0 : listView->gridSize().height()) - listView->viewport()->height();
@@ -485,7 +445,7 @@
 
     QListView::setModel(model);
 
-    d->proxyModel = dynamic_cast<DolphinSortFilterProxyModel*>(model);
+    d->proxyModel = dynamic_cast<KCategorizedSortFilterProxyModel*>(model);
 
     if (d->proxyModel)
     {
@@ -502,7 +462,7 @@
 QRect KCategorizedView::visualRect(const QModelIndex &index) const
 {
     if ((viewMode() != KCategorizedView::IconMode) || !d->proxyModel ||
-        !d->itemCategorizer)
+        !d->categoryDrawer)
     {
         return QListView::visualRect(index);
     }
@@ -515,12 +475,12 @@
     return d->visualRect(index);
 }
 
-KItemCategorizer *KCategorizedView::itemCategorizer() const
+KCategoryDrawer *KCategorizedView::categoryDrawer() const
 {
-    return d->itemCategorizer;
+    return d->categoryDrawer;
 }
 
-void KCategorizedView::setItemCategorizer(KItemCategorizer *itemCategorizer)
+void KCategorizedView::setCategoryDrawer(KCategoryDrawer *categoryDrawer)
 {
     d->lastSelection = QItemSelection();
     d->currentViewIndex = QModelIndex();
@@ -537,7 +497,7 @@
     d->hovered = QModelIndex();
     d->mouseButtonPressed = false;
 
-    if (!itemCategorizer && d->proxyModel)
+    if (!categoryDrawer && d->proxyModel)
     {
         QObject::disconnect(d->proxyModel,
                             SIGNAL(rowsRemoved(QModelIndex,int,int)),
@@ -547,7 +507,7 @@
                             SIGNAL(sortingRoleChanged()),
                             this, SLOT(slotSortingRoleChanged()));
     }
-    else if (itemCategorizer && d->proxyModel)
+    else if (categoryDrawer && d->proxyModel)
     {
         QObject::connect(d->proxyModel,
                          SIGNAL(rowsRemoved(QModelIndex,int,int)),
@@ -558,9 +518,9 @@
                          this, SLOT(slotSortingRoleChanged()));
     }
 
-    d->itemCategorizer = itemCategorizer;
+    d->categoryDrawer = categoryDrawer;
 
-    if (itemCategorizer)
+    if (categoryDrawer)
     {
         rowsInserted(QModelIndex(), 0, d->proxyModel->rowCount() - 1);
     }
@@ -573,7 +533,7 @@
 QModelIndex KCategorizedView::indexAt(const QPoint &point) const
 {
     if ((viewMode() != KCategorizedView::IconMode) || !d->proxyModel ||
-        !d->itemCategorizer)
+        !d->categoryDrawer)
     {
         return QListView::indexAt(point);
     }
@@ -616,7 +576,7 @@
 void KCategorizedView::paintEvent(QPaintEvent *event)
 {
     if ((viewMode() != KCategorizedView::IconMode) || !d->proxyModel ||
-        !d->itemCategorizer)
+        !d->categoryDrawer)
     {
         QListView::paintEvent(event);
         return;
@@ -744,7 +704,7 @@
     d->forcedSelectionPosition = 0;
 
     if ((viewMode() != KCategorizedView::IconMode) || !d->proxyModel ||
-        !d->itemCategorizer)
+        !d->categoryDrawer)
     {
         return;
     }
@@ -756,7 +716,7 @@
                                     QItemSelectionModel::SelectionFlags flags)
 {
     if ((viewMode() != KCategorizedView::IconMode) || !d->proxyModel ||
-        !d->itemCategorizer)
+        !d->categoryDrawer)
     {
         QListView::setSelection(rect, flags);
         return;
@@ -830,7 +790,7 @@
     QListView::mouseMoveEvent(event);
 
     if ((viewMode() != KCategorizedView::IconMode) || !d->proxyModel ||
-        !d->itemCategorizer)
+        !d->categoryDrawer)
     {
         return;
     }
@@ -910,7 +870,7 @@
     QListView::mouseReleaseEvent(event);
 
     if ((viewMode() != KCategorizedView::IconMode) || !d->proxyModel ||
-        !d->itemCategorizer)
+        !d->categoryDrawer)
     {
         return;
     }
@@ -929,7 +889,11 @@
             {
                 foreach (const QModelIndex &index, d->categoriesIndexes[category])
                 {
-                    selection << QItemSelectionRange(d->proxyModel->mapFromSource(index));
+                    QModelIndex theIndex = (viewMode() == KCategorizedView::IconMode) ?
+                                           d->proxyModel->mapFromSource(d->proxyModel->sourceModel()->index(index.row(), 0)) :
+                                           d->proxyModel->mapFromSource(index);
+
+                    selection << QItemSelectionRange(theIndex);
                 }
 
                 selectionModel()->select(selection, QItemSelectionModel::Select);
@@ -981,7 +945,7 @@
     d->dragLeftViewport = false;
 
     if ((viewMode() != KCategorizedView::IconMode) || !d->proxyModel ||
-        !d->itemCategorizer)
+        !d->categoryDrawer)
     {
         QListView::dragMoveEvent(event);
         return;
@@ -1000,10 +964,10 @@
 QModelIndex KCategorizedView::moveCursor(CursorAction cursorAction,
                                   Qt::KeyboardModifiers modifiers)
 {
-    if (    (viewMode() != KCategorizedView::IconMode) || 
+    if (    (viewMode() != KCategorizedView::IconMode) ||
             !d->proxyModel ||
-            !d->itemCategorizer || 
-            d->categories.isEmpty()     
+            !d->categoryDrawer ||
+            d->categories.isEmpty()
        )
     {
         return QListView::moveCursor(cursorAction, modifiers);
@@ -1040,7 +1004,7 @@
             break;
         }
 
-        if (category == d->elementsInfo[d->proxyModel->mapToSource(current)].category)
+        if (category == d->elementsInfo[d->proxyModel->mapToSource(current).row()].category)
         {
             theCategory = category;
 
@@ -1056,17 +1020,17 @@
     switch (cursorAction)
     {
         case QAbstractItemView::MoveUp: {
-            if (d->elementsInfo[d->proxyModel->mapToSource(current)].relativeOffsetToCategory >= elementsPerRow)
+            if (d->elementsInfo[d->proxyModel->mapToSource(current).row()].relativeOffsetToCategory >= elementsPerRow)
             {
-                int indexToMove = d->invertedElementDictionary[current].row();
-                indexToMove -= qMin(((d->elementsInfo[d->proxyModel->mapToSource(current)].relativeOffsetToCategory) + d->forcedSelectionPosition), elementsPerRow - d->forcedSelectionPosition + (d->elementsInfo[d->proxyModel->mapToSource(current)].relativeOffsetToCategory % elementsPerRow));
+                int indexToMove = d->invertedElementDictionary[current.row()].row();
+                indexToMove -= qMin(((d->elementsInfo[d->proxyModel->mapToSource(current).row()].relativeOffsetToCategory) + d->forcedSelectionPosition), elementsPerRow - d->forcedSelectionPosition + (d->elementsInfo[d->proxyModel->mapToSource(current).row()].relativeOffsetToCategory % elementsPerRow));
 
-                return d->elementDictionary[d->proxyModel->index(indexToMove, 0)];
+                return d->elementDictionary[indexToMove];
             }
             else
             {
                 int lastCategoryLastRow = (d->categoriesIndexes[lastCategory].count() - 1) % elementsPerRow;
-                int indexToMove = d->invertedElementDictionary[current].row() - d->elementsInfo[d->proxyModel->mapToSource(current)].relativeOffsetToCategory;
+                int indexToMove = d->invertedElementDictionary[current.row()].row() - d->elementsInfo[d->proxyModel->mapToSource(current).row()].relativeOffsetToCategory;
 
                 if (d->forcedSelectionPosition >= lastCategoryLastRow)
                 {
@@ -1077,22 +1041,22 @@
                     indexToMove -= qMin((lastCategoryLastRow - d->forcedSelectionPosition + 1), d->forcedSelectionPosition + elementsPerRow + 1);
                 }
 
-                return d->elementDictionary[d->proxyModel->index(indexToMove, 0)];
+                return d->elementDictionary[indexToMove];
             }
         }
 
         case QAbstractItemView::MoveDown: {
-            if (d->elementsInfo[d->proxyModel->mapToSource(current)].relativeOffsetToCategory < (d->categoriesIndexes[theCategory].count() - 1 - ((d->categoriesIndexes[theCategory].count() - 1) % elementsPerRow)))
+            if (d->elementsInfo[d->proxyModel->mapToSource(current).row()].relativeOffsetToCategory < (d->categoriesIndexes[theCategory].count() - 1 - ((d->categoriesIndexes[theCategory].count() - 1) % elementsPerRow)))
             {
-                int indexToMove = d->invertedElementDictionary[current].row();
-                indexToMove += qMin(elementsPerRow, d->categoriesIndexes[theCategory].count() - 1 - d->elementsInfo[d->proxyModel->mapToSource(current)].relativeOffsetToCategory);
+                int indexToMove = d->invertedElementDictionary[current.row()].row();
+                indexToMove += qMin(elementsPerRow, d->categoriesIndexes[theCategory].count() - 1 - d->elementsInfo[d->proxyModel->mapToSource(current).row()].relativeOffsetToCategory);
 
-                return d->elementDictionary[d->proxyModel->index(indexToMove, 0)];
+                return d->elementDictionary[indexToMove];
             }
             else
             {
                 int afterCategoryLastRow = qMin(elementsPerRow, d->categoriesIndexes[afterCategory].count());
-                int indexToMove = d->invertedElementDictionary[current].row() + (d->categoriesIndexes[theCategory].count() - d->elementsInfo[d->proxyModel->mapToSource(current)].relativeOffsetToCategory);
+                int indexToMove = d->invertedElementDictionary[current.row()].row() + (d->categoriesIndexes[theCategory].count() - d->elementsInfo[d->proxyModel->mapToSource(current).row()].relativeOffsetToCategory);
 
                 if (d->forcedSelectionPosition >= afterCategoryLastRow)
                 {
@@ -1103,25 +1067,25 @@
                     indexToMove += qMin(d->forcedSelectionPosition, elementsPerRow);
                 }
 
-                return d->elementDictionary[d->proxyModel->index(indexToMove, 0)];
+                return d->elementDictionary[indexToMove];
             }
         }
 
         case QAbstractItemView::MoveLeft:
-            d->forcedSelectionPosition = d->elementsInfo[d->proxyModel->mapToSource(d->elementDictionary[d->proxyModel->index(d->invertedElementDictionary[current].row() - 1, 0)])].relativeOffsetToCategory % elementsPerRow;
+            d->forcedSelectionPosition = d->elementsInfo[d->proxyModel->mapToSource(d->elementDictionary[d->proxyModel->index(d->invertedElementDictionary[current.row()].row() - 1, 0).row()]).row()].relativeOffsetToCategory % elementsPerRow;
 
             if (d->forcedSelectionPosition < 0)
                 d->forcedSelectionPosition = (d->categoriesIndexes[theCategory].count() - 1) % elementsPerRow;
 
-            return d->elementDictionary[d->proxyModel->index(d->invertedElementDictionary[current].row() - 1, 0)];
+            return d->elementDictionary[d->proxyModel->index(d->invertedElementDictionary[current.row()].row() - 1, 0).row()];
 
         case QAbstractItemView::MoveRight:
-            d->forcedSelectionPosition = d->elementsInfo[d->proxyModel->mapToSource(d->elementDictionary[d->proxyModel->index(d->invertedElementDictionary[current].row() + 1, 0)])].relativeOffsetToCategory % elementsPerRow;
+            d->forcedSelectionPosition = d->elementsInfo[d->proxyModel->mapToSource(d->elementDictionary[d->proxyModel->index(d->invertedElementDictionary[current.row()].row() + 1, 0).row()]).row()].relativeOffsetToCategory % elementsPerRow;
 
             if (d->forcedSelectionPosition < 0)
                 d->forcedSelectionPosition = (d->categoriesIndexes[theCategory].count() - 1) % elementsPerRow;
 
-            return d->elementDictionary[d->proxyModel->index(d->invertedElementDictionary[current].row() + 1, 0)];
+            return d->elementDictionary[d->proxyModel->index(d->invertedElementDictionary[current.row()].row() + 1, 0).row()];
 
         default:
             break;
@@ -1137,7 +1101,7 @@
     QListView::rowsInserted(parent, start, end);
 
     if ((viewMode() != KCategorizedView::IconMode) || !d->proxyModel ||
-        !d->itemCategorizer)
+        !d->categoryDrawer)
     {
         d->lastSelection = QItemSelection();
         d->currentViewIndex = QModelIndex();
@@ -1183,6 +1147,8 @@
     d->biggestItemSize = QSize(0, 0);
     d->mouseButtonPressed = false;
 
+#warning FIXME (ereslibre)
+#if 0
     if (start > end || end < 0 || start < 0 || !d->proxyModel->rowCount())
     {
         return;
@@ -1191,13 +1157,13 @@
     // Add all elements mapped to the source model
     for (int k = 0; k < d->proxyModel->rowCount(); k++)
     {
-        d->biggestItemSize = QSize(qMax(sizeHintForIndex(d->proxyModel->index(k, 0)).width(),
+        d->biggestItemSize = QSize(qMax(sizeHintForIndex(d->proxyModel->index(k, d->proxyModel->sortRole())).width(),
                                         d->biggestItemSize.width()),
-                                   qMax(sizeHintForIndex(d->proxyModel->index(k, 0)).height(),
+                                   qMax(sizeHintForIndex(d->proxyModel->index(k, d->proxyModel->sortRole())).height(),
                                         d->biggestItemSize.height()));
 
         d->sourceModelIndexList <<
-                         d->proxyModel->mapToSource(d->proxyModel->index(k, 0));
+                         d->proxyModel->mapToSource(d->proxyModel->index(k, d->proxyModel->sortRole()));
     }
 
     // Sort them with the general purpose lessThan method
@@ -1208,16 +1174,13 @@
                 generalLessThan);
 
     // Explore categories
-    QString prevCategory =
-                 d->itemCategorizer->categoryForItem(d->sourceModelIndexList[0],
-                                                     d->proxyModel->sortRole());
+    QString prevCategory = model()->data(d->sourceModelIndexList[0], KCategorizedSortFilterProxyModel::CategoryRole).toString();
     QString lastCategory = prevCategory;
     QModelIndexList modelIndexList;
     struct Private::ElementInfo elementInfo;
     foreach (const QModelIndex &index, d->sourceModelIndexList)
     {
-        lastCategory = d->itemCategorizer->categoryForItem(index,
-                                                     d->proxyModel->sortRole());
+        lastCategory = model()->data(index, KCategorizedSortFilterProxyModel::CategoryRole).toString();
 
         elementInfo.category = lastCategory;
 
@@ -1231,7 +1194,7 @@
         modelIndexList << index;
         prevCategory = lastCategory;
 
-        d->elementsInfo.insert(index, elementInfo);
+        d->elementsInfo.insert(index.row(), elementInfo);
     }
 
     d->categoriesIndexes.insert(prevCategory, modelIndexList);
@@ -1249,6 +1212,8 @@
         qStableSort(indexList.begin(), indexList.end(), categoryLessThan);
     }
 
+    int column = (viewMode() == KCategorizedView::IconMode) ? 0 : d->proxyModel->sortRole();
+
     // Finally, fill data information of items situation. This will help when
     // trying to compute an item place in the viewport
     int i = 0; // position relative to the category beginning
@@ -1257,22 +1222,25 @@
     {
         foreach (const QModelIndex &index, d->categoriesIndexes[key])
         {
-            struct Private::ElementInfo &elementInfo = d->elementsInfo[index];
+            struct Private::ElementInfo &elementInfo = d->elementsInfo[index.row()];
 
             elementInfo.relativeOffsetToCategory = i;
 
-            d->elementDictionary.insert(d->proxyModel->index(j, 0),
-                                        d->proxyModel->mapFromSource(index));
+            QModelIndex theNewIndex = d->proxyModel->sourceModel()->index(index.row(), column);
 
-            d->invertedElementDictionary.insert(d->proxyModel->mapFromSource(index),
-                                                d->proxyModel->index(j, 0));
+            d->elementDictionary.insert(j,
+                                        d->proxyModel->mapFromSource(theNewIndex));
 
+            d->invertedElementDictionary.insert(d->proxyModel->mapFromSource(theNewIndex).row(),
+                                                d->proxyModel->index(j, column));
+
             i++;
             j++;
         }
 
         i = 0;
     }
+#endif
 
     d->updateScrollbars();
 }
@@ -1282,7 +1250,7 @@
                             int end)
 {
     if ((viewMode() == KCategorizedView::IconMode) && d->proxyModel &&
-        d->itemCategorizer)
+        d->categoryDrawer)
     {
         // Force the view to update all elements
         rowsInsertedArtifficial(parent, start, end);
@@ -1292,7 +1260,7 @@
 void KCategorizedView::updateGeometries()
 {
     if ((viewMode() != KCategorizedView::IconMode) || !d->proxyModel ||
-        !d->itemCategorizer)
+        !d->categoryDrawer)
     {
         QListView::updateGeometries();
         return;
@@ -1306,7 +1274,7 @@
 void KCategorizedView::slotSortingRoleChanged()
 {
     if ((viewMode() == KCategorizedView::IconMode) && d->proxyModel &&
-        d->itemCategorizer)
+        d->categoryDrawer)
     {
         // Force the view to update all elements
         rowsInsertedArtifficial(QModelIndex(), 0, d->proxyModel->rowCount() - 1);
Index: apps/dolphin/src/sidebartreeview.cpp
===================================================================
--- apps/dolphin/src/sidebartreeview.cpp	(revisión: 708805)
+++ apps/dolphin/src/sidebartreeview.cpp	(copia de trabajo)
@@ -20,8 +20,8 @@
 #include "sidebartreeview.h"
 
 #include "dolphincontroller.h"
+#include "dolphinmodel.h"
 
-#include <kdirmodel.h>
 #include <kfileitemdelegate.h>
 #include <QKeyEvent>
 #include <QPainter>
@@ -59,12 +59,12 @@
 {
     if (event->type() == QEvent::Polish) {
         // hide all columns except of the 'Name' column
-        hideColumn(KDirModel::Size);
-        hideColumn(KDirModel::ModifiedTime);
-        hideColumn(KDirModel::Permissions);
-        hideColumn(KDirModel::Owner);
-        hideColumn(KDirModel::Group);
-        hideColumn(KDirModel::Type);
+        hideColumn(DolphinModel::Size);
+        hideColumn(DolphinModel::ModifiedTime);
+        hideColumn(DolphinModel::Permissions);
+        hideColumn(DolphinModel::Owner);
+        hideColumn(DolphinModel::Group);
+        hideColumn(DolphinModel::Type);
         header()->hide();
     }
 
Index: apps/dolphin/src/dolphiniconsview.h
===================================================================
--- apps/dolphin/src/dolphiniconsview.h	(revisión: 708805)
+++ apps/dolphin/src/dolphiniconsview.h	(copia de trabajo)
@@ -21,7 +21,6 @@
 #define DOLPHINICONSVIEW_H
 
 #include <kcategorizedview.h>
-#include <kitemcategorizer.h>
 
 #include <QSize>
 #include <QStyleOption>
@@ -36,7 +35,8 @@
  * It is also possible that instead of the icon a preview of the item
  * content is shown.
  */
-class LIBDOLPHINPRIVATE_EXPORT DolphinIconsView : public KCategorizedView
+//class LIBDOLPHINPRIVATE_EXPORT DolphinIconsView : public KCategorizedView
+class LIBDOLPHINPRIVATE_EXPORT DolphinIconsView : public QListView
 {
     Q_OBJECT
 
Index: apps/dolphin/src/CMakeLists.txt
===================================================================
--- apps/dolphin/src/CMakeLists.txt	(revisión: 708805)
+++ apps/dolphin/src/CMakeLists.txt	(copia de trabajo)
@@ -14,9 +14,9 @@
     dolphindetailsview.cpp
     dolphiniconsview.cpp
     dolphincolumnview.cpp
-    dolphinitemcategorizer.cpp
     kcategorizedview.cpp
-    kitemcategorizer.cpp
+    kcategorydrawer.cpp
+    dolphinmodel.cpp
     dolphinsettings.cpp
     viewproperties.cpp
     dolphinsortfilterproxymodel.cpp
Index: apps/dolphin/src/dolphinview.h
===================================================================
--- apps/dolphin/src/dolphinview.h	(revisión: 708805)
+++ apps/dolphin/src/dolphinview.h	(copia de trabajo)
@@ -41,7 +41,7 @@
 class KDirLister;
 class KFileItemDelegate;
 class KUrl;
-class KDirModel;
+class DolphinModel;
 class DolphinColumnView;
 class DolphinDetailsView;
 class DolphinIconsView;
@@ -116,7 +116,7 @@
      * @param url             Specifies the content which should be shown.
      * @param dirLister       Used directory lister. The lister is not owned
      *                        by the view and won't get deleted.
-     * @param dirModel        Used directory model. The model is not owned
+     * @param dolphinModel    Used directory model. The model is not owned
      *                        by the view and won't get deleted.
      * @param proxyModel      Used proxy model which specifies the sorting. The
      *                        model is not owned by the view and won't get
@@ -125,7 +125,7 @@
     DolphinView(QWidget* parent,
                 const KUrl& url,
                 KDirLister* dirLister,
-                KDirModel* dirModel,
+                DolphinModel* dolphinModel,
                 DolphinSortFilterProxyModel* proxyModel);
 
     virtual ~DolphinView();
@@ -509,7 +509,7 @@
 
     /**
      * Returns true if the index is valid and represents
-     * the column KDirModel::Name.
+     * the column DolphinModel::Name.
      */
     bool isValidNameIndex(const QModelIndex& index) const;
 
@@ -563,7 +563,7 @@
     DolphinColumnView* m_columnView;
     KFileItemDelegate* m_fileItemDelegate;
 
-    KDirModel* m_dirModel;
+    DolphinModel* m_dolphinModel;
     KDirLister* m_dirLister;
     DolphinSortFilterProxyModel* m_proxyModel;
 
Index: apps/dolphin/src/kcategorizedview.h
===================================================================
--- apps/dolphin/src/kcategorizedview.h	(revisión: 708805)
+++ apps/dolphin/src/kcategorizedview.h	(copia de trabajo)
@@ -25,7 +25,7 @@
 
 #include <libdolphin_export.h>
 
-class KItemCategorizer;
+class KCategoryDrawer;
 
 /**
   * @short Item view for listing items
@@ -52,16 +52,9 @@
 
     virtual QRect visualRect(const QModelIndex &index) const;
 
-    /**
-      * Will return the current categorizer. If none set, this method will
-      * return 0
-      */
-    KItemCategorizer *itemCategorizer() const;
+    KCategoryDrawer *categoryDrawer() const;
 
-    /**
-      * Sets the categorizer to be used. Causes the item view to repaint
-      */
-    void setItemCategorizer(KItemCategorizer *itemCategorizer);
+    void setCategoryDrawer(KCategoryDrawer *categoryDrawer);
 
     virtual QModelIndex indexAt(const QPoint &point) const;
 
Index: runtime/kuiserver/uiserver.cpp
===================================================================
--- runtime/kuiserver/uiserver.cpp	(revisión: 708805)
+++ runtime/kuiserver/uiserver.cpp	(copia de trabajo)
@@ -355,9 +355,11 @@
 
 void UIServer::applySettings()
 {
+#if 0
      KSystemTrayIcon *m_systemTray = new KSystemTrayIcon(this);
      m_systemTray->setIcon(KSystemTrayIcon::loadIcon("display")); // found something better ? (ereslibre)
      m_systemTray->show();
+#endif
 }
 
 void UIServer::slotActionPerformed(int actionId, int jobId)
