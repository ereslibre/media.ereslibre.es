Index: khtml/khtmlview.cpp
===================================================================
--- khtml/khtmlview.cpp	(revisión: 797670)
+++ khtml/khtmlview.cpp	(copia de trabajo)
@@ -1055,7 +1055,7 @@
 void KHTMLView::closeChildDialogs()
 {
     QList<QDialog *> dlgs = findChildren<QDialog *>();
-    foreach (QDialog *dlg, dlgs)
+    Q_FOREACH (QDialog *dlg, dlgs)
     {
         KDialog* dlgbase = dynamic_cast<KDialog*>( dlg );
         if ( dlgbase ) {
@@ -2115,7 +2115,7 @@
     }
 
     QObjectList children = w->children();
-    foreach (QObject* object, children) {
+    Q_FOREACH (QObject* object, children) {
 	QWidget *widget = qobject_cast<QWidget*>(object);
 	if (widget)
 	    handleWidget(widget, view);
@@ -2176,7 +2176,7 @@
           return;
       }
 
-      foreach(QObject* cw, w->children()) {
+      Q_FOREACH(QObject* cw, w->children()) {
           if (cw->isWidgetType() && ! static_cast<QWidget*>(cw)->isWindow()
                                  && !(static_cast<QWidget*>(cw)->windowModality() & Qt::ApplicationModal)) {
               setInPaintEventFlag(static_cast<QWidget*>(cw), b);
@@ -2673,7 +2673,7 @@
         return;
 
     QList<KParts::ReadOnlyPart*> frames = m_part->frames();
-    foreach( KParts::ReadOnlyPart* cur, frames ) {
+    Q_FOREACH( KParts::ReadOnlyPart* cur, frames ) {
         if( !qobject_cast<KHTMLPart*>(cur) )
             continue;
         KHTMLPart* part = static_cast< KHTMLPart* >( cur );
@@ -2729,7 +2729,7 @@
     ElementImpl* node = doc->findAccessKeyElement( c );
     if( !node ) {
         QList<KParts::ReadOnlyPart*> frames = m_part->frames();
-        foreach( KParts::ReadOnlyPart* cur, frames ) {
+        Q_FOREACH( KParts::ReadOnlyPart* cur, frames ) {
             if( !qobject_cast<KHTMLPart*>(cur) )
                 continue;
             KHTMLPart* part = static_cast< KHTMLPart* >( cur );
@@ -4207,7 +4207,7 @@
             !visibleRect.intersects(QRect(xp, yp, it.value()->width(), it.value()->height())))
             toRemove.append(rw);
     }
-    foreach (RenderWidget* r, toRemove)
+    Q_FOREACH (RenderWidget* r, toRemove)
         if ( (w = d->visibleWidgets.take(r) ) )
             w->move( 0, -500000);
 }
Index: khtml/misc/loader.cpp
===================================================================
--- khtml/misc/loader.cpp	(revisión: 797670)
+++ khtml/misc/loader.cpp	(copia de trabajo)
@@ -1380,11 +1380,11 @@
 {
     int res = 0;
 
-    foreach( Request* req, m_requestsPending )
+    Q_FOREACH( Request* req, m_requestsPending )
         if ( req->m_docLoader == dl )
             res++;
 
-    foreach( Request* req, m_requestsLoading)
+    Q_FOREACH( Request* req, m_requestsLoading)
         if ( req->m_docLoader == dl )
             res++;
 
@@ -1487,7 +1487,7 @@
 
 #ifndef NDEBUG
     bool crash = false;
-    foreach (CachedObject* co, *cache) {
+    Q_FOREACH (CachedObject* co, *cache) {
         if (!co->canDelete()) {
             kDebug( 6060 ) << " Object in cache still linked to";
             kDebug( 6060 ) << " -> URL: " << co->url();
@@ -1496,14 +1496,14 @@
 //         assert(co->canDelete());
         }
     }
-    foreach (CachedObject* co, *freeList) {
+    Q_FOREACH (CachedObject* co, *freeList) {
         if (!co->canDelete()) {
             kDebug( 6060 ) << " Object in freelist still linked to";
             kDebug( 6060 ) << " -> URL: " << co->url();
             kDebug( 6060 ) << " -> #clients: " << co->count();
             crash = true;
             /*
-            foreach (CachedObjectClient* cur, (*co->m_clients)))
+            Q_FOREACH (CachedObjectClient* cur, (*co->m_clients)))
             {
                 if (dynamic_cast<RenderObject*>(cur)) {
                     kDebug( 6060 ) << " --> RenderObject";
@@ -1627,7 +1627,7 @@
     int scripts = 0;
     int stylesheets = 0;
     int sound = 0;
-    foreach (CachedObject* o, *cache)
+    Q_FOREACH (CachedObject* o, *cache)
     {
         switch(o->type()) {
         case CachedObject::Image:
@@ -1674,7 +1674,7 @@
     cache->remove( key );
     removeFromLRUList( object );
 
-    foreach( DocLoader* dl, *docloader )
+    Q_FOREACH( DocLoader* dl, *docloader )
         dl->removeCachedObject( object );
 
     if ( !object->free() ) {
Index: khtml/misc/paintbuffer.h
===================================================================
--- khtml/misc/paintbuffer.h	(revisión: 797670)
+++ khtml/misc/paintbuffer.h	(copia de trabajo)
@@ -96,7 +96,7 @@
          m_painter.setWorldTransform(p->worldTransform());
          m_painter.translate( -m_off );
          m_painter.setClipRegion(m_region = rr);
-         //foreach(QRect rrr, m_region.rects())
+         //Q_FOREACH(QRect rrr, m_region.rects())
          //    kDebug() << rrr;
 
          if (!doFill) {
Index: khtml/khtml_part.cpp
===================================================================
--- khtml/khtml_part.cpp	(revisión: 797670)
+++ khtml/khtml_part.cpp	(copia de trabajo)
@@ -1833,7 +1833,7 @@
     removeJSErrorExtension();
     setSuppressedPopupIndicator( false );
     d->m_openableSuppressedPopups = 0;
-    foreach ( KHTMLPart* part, d->m_suppressedPopupOriginParts ) {
+    Q_FOREACH ( KHTMLPart* part, d->m_suppressedPopupOriginParts ) {
       if (part) {
         KJS::Window *w = KJS::Window::retrieveWindow( part );
         if (w)
@@ -4038,7 +4038,7 @@
   QList<QSslCertificate> certChain;
   bool certChainOk = d->m_ssl_in_use;
   if (certChainOk) {
-    foreach (const QString &s, sl) {
+    Q_FOREACH (const QString &s, sl) {
       certChain.append(QSslCertificate(s.toAscii())); //or is it toLocal8Bit or whatever?
       if (certChain.last().isNull()) {
         certChainOk = false;
@@ -4066,7 +4066,7 @@
     QStringList sl = d->m_ssl_peer_chain.split('\x01', QString::SkipEmptyParts);
     QList<QSslCertificate> certChain;
     bool decodedOk = true;
-    foreach (const QString &s, sl) {
+    Q_FOREACH (const QString &s, sl) {
         certChain.append(QSslCertificate(s.toAscii())); //or is it toLocal8Bit or whatever?
         if (certChain.last().isNull()) {
             decodedOk = false;
@@ -4076,7 +4076,7 @@
 
     sl = d->m_ssl_cert_errors.split('\n', QString::SkipEmptyParts);
     QList<QSslError::SslError> errors;
-    foreach (const QString &s, sl) {
+    Q_FOREACH (const QString &s, sl) {
         bool didConvert;
         QSslError::SslError error = static_cast<QSslError::SslError>(s.toInt(&didConvert));
         if (!didConvert) {
@@ -7377,7 +7377,7 @@
 }
 
 void KHTMLPart::showSuppressedPopups() {
-    foreach ( KHTMLPart* part, d->m_suppressedPopupOriginParts ) {
+    Q_FOREACH ( KHTMLPart* part, d->m_suppressedPopupOriginParts ) {
       if (part) {
         KJS::Window *w = KJS::Window::retrieveWindow( part );
         if (w) {
Index: khtml/ecma/debugger/callstackdock.cpp
===================================================================
--- khtml/ecma/debugger/callstackdock.cpp	(revisión: 797670)
+++ khtml/ecma/debugger/callstackdock.cpp	(copia de trabajo)
@@ -74,7 +74,7 @@
     m_view->setRowCount(ic->callStack.count());
 
     int row = 0;
-    foreach (const CallStackEntry &entry, ic->callStack)
+    Q_FOREACH (const CallStackEntry &entry, ic->callStack)
     {
         int displayRow = ic->callStack.count() - row - 1; //Want newest entry on top
         QTableWidgetItem *function = new QTableWidgetItem(entry.name);
Index: khtml/ecma/debugger/debugwindow.cpp
===================================================================
--- khtml/ecma/debugger/debugwindow.cpp	(revisión: 797670)
+++ khtml/ecma/debugger/debugwindow.cpp	(copia de trabajo)
@@ -411,7 +411,7 @@
 void DebugWindow::cleanupDocument(DebugDocument::Ptr doc)
 {
     // Remove all fragments from the sid map
-    foreach (int sid, doc->fragments())
+    Q_FOREACH (int sid, doc->fragments())
     {
         m_docForSid.remove(sid);
         // Remove from the IU-key map if needed.
@@ -438,7 +438,7 @@
     // Go through, and kill all the fragments from here.
     QList<DebugDocument::Ptr> docs = m_docsForIntrp[interp];
 
-    foreach (DebugDocument::Ptr doc, docs)
+    Q_FOREACH (DebugDocument::Ptr doc, docs)
         cleanupDocument(doc);
 
     m_docsForIntrp.remove(interp);
@@ -507,7 +507,7 @@
         if (uiURL.isEmpty())
         {
             // Scan through all contexts, and see which one matches
-            foreach (InterpreterContext* ic, m_contexts)
+            Q_FOREACH (InterpreterContext* ic, m_contexts)
             {
                 if (!ic->execContexts.isEmpty() && ic->execContexts.top() == exec)
                 {
@@ -1016,14 +1016,14 @@
 void DebugWindow::enterModality()
 {
     QWidgetList widgets = QApplication::allWidgets();
-    foreach (QWidget *widget, widgets)
+    Q_FOREACH (QWidget *widget, widgets)
         widget->installEventFilter(this);
 }
 
 void DebugWindow::leaveModality()
 {
     QWidgetList widgets = QApplication::allWidgets();
-    foreach (QWidget *widget, widgets)
+    Q_FOREACH (QWidget *widget, widgets)
         widget->removeEventFilter(this);
 }
 
Index: khtml/ecma/debugger/debugdocument.cpp
===================================================================
--- khtml/ecma/debugger/debugdocument.cpp	(revisión: 797670)
+++ khtml/ecma/debugger/debugdocument.cpp	(copia de trabajo)
@@ -225,12 +225,12 @@
     if (lastLine == -1)
     {
         lastLine = 0;
-        foreach(const SourceFragment &fragment, m_codeFragments)
+        Q_FOREACH(const SourceFragment &fragment, m_codeFragments)
             lastLine = qMax(fragment.lastLine(), lastLine);
     }
 
     QStringList lines;
-    foreach (const SourceFragment &fragment, m_codeFragments)
+    Q_FOREACH (const SourceFragment &fragment, m_codeFragments)
     {
         // See if this fragment is in the [firstLine, lastLine] range.
         if (!fragment.inRange(firstLine, lastLine))
@@ -299,7 +299,7 @@
     if (imark)
     {
         QVector<int>& bps = breakpoints();
-        foreach (int bpLine, bps)
+        Q_FOREACH (int bpLine, bps)
             imark->addMark(bpLine - 1, KTextEditor::MarkInterface::BreakpointActive);
     }
 
Index: khtml/ecma/debugger/scriptsdock.cpp
===================================================================
--- khtml/ecma/debugger/scriptsdock.cpp	(revisión: 797670)
+++ khtml/ecma/debugger/scriptsdock.cpp	(copia de trabajo)
@@ -119,7 +119,7 @@
     QHash<QString, QStandardItem*> parents;
 
     QStandardItem *top = m_model->invisibleRootItem();
-    foreach (KJS::DebugDocument *document, m_documents)
+    Q_FOREACH (KJS::DebugDocument *document, m_documents)
     {
         QString domain = QUrl(document->url()).host();
         if (domain.isEmpty())
Index: khtml/ecma/kjs_html.cpp
===================================================================
--- khtml/ecma/kjs_html.cpp	(revisión: 797670)
+++ khtml/ecma/kjs_html.cpp	(copia de trabajo)
@@ -3080,7 +3080,7 @@
     else  {
       // multiple items, return a collection
       QList<SharedPtr<DOM::NodeImpl> > nodes;
-      foreach (DOM::NodeImpl* node, matches)
+      Q_FOREACH (DOM::NodeImpl* node, matches)
         nodes.append(node);
 #ifdef KJS_VERBOSE
       kDebug(6070) << "returning list of " << matches.count() << " nodes";
Index: khtml/ecma/kjs_window.cpp
===================================================================
--- khtml/ecma/kjs_window.cpp	(revisión: 797670)
+++ khtml/ecma/kjs_window.cpp	(copia de trabajo)
@@ -1776,7 +1776,7 @@
 
   QList<SuppressedWindowInfo> suppressedWindowInfo = m_suppressedWindowInfo;
   m_suppressedWindowInfo.clear();
-  foreach ( const SuppressedWindowInfo &info, suppressedWindowInfo ) {
+  Q_FOREACH ( const SuppressedWindowInfo &info, suppressedWindowInfo ) {
     executeOpenWindow(exec, info.url, info.frameName, info.features);
   }
 }
@@ -2252,7 +2252,7 @@
         DateTimeMS curTime          = DateTimeMS::now();
         DateTimeMS earliestDispatch = curTime.addMSecs(5);
         int delay = pauseStart.msecsTo(curTime);
-        foreach (ScheduledAction *action, scheduledActions) {
+        Q_FOREACH (ScheduledAction *action, scheduledActions) {
             action->nextTime = action->nextTime.addMSecs(delay);
             if (earliestDispatch > action->nextTime)
                 action->nextTime = earliestDispatch;
@@ -2293,7 +2293,7 @@
 
 void WindowQObject::clearTimeout(int timerId)
 {
-  foreach (ScheduledAction *action, scheduledActions)
+  Q_FOREACH (ScheduledAction *action, scheduledActions)
   {
     if (action->timerId == timerId)
     {
@@ -2312,7 +2312,7 @@
 
 void WindowQObject::mark()
 {
-  foreach (ScheduledAction *action, scheduledActions)
+  Q_FOREACH (ScheduledAction *action, scheduledActions)
   {
     action->mark();
   }
@@ -2336,14 +2336,14 @@
   // Work out which actions are to be executed. We take a separate copy of
   // this list since the main one may be modified during action execution
   QList<ScheduledAction*> toExecute;
-  foreach (ScheduledAction *action, scheduledActions)
+  Q_FOREACH (ScheduledAction *action, scheduledActions)
   {
     if (current >= action->nextTime)
       toExecute.append(action);
   }
 
   // ### verify that the window can't be closed (and action deleted) during execution
-  foreach (ScheduledAction *action, toExecute)
+  Q_FOREACH (ScheduledAction *action, toExecute)
   {
     if (!scheduledActions.count(action)) // removed by clearTimeout()
       continue;
Index: khtml/rendering/render_flow.cpp
===================================================================
--- khtml/rendering/render_flow.cpp	(revisión: 797670)
+++ khtml/rendering/render_flow.cpp	(copia de trabajo)
@@ -390,7 +390,7 @@
     }
 
     if (i.phase == PaintActionOutline && i.outlineObjects) {
-          foreach (RenderFlow* oo, *i.outlineObjects)
+          Q_FOREACH (RenderFlow* oo, *i.outlineObjects)
               if (oo->isRenderInline())
                   static_cast<RenderInline*>(oo)->paintOutlines(i.p, _tx, _ty);
           i.outlineObjects->clear();
Index: khtml/rendering/render_layer.cpp
===================================================================
--- khtml/rendering/render_layer.cpp	(revisión: 797670)
+++ khtml/rendering/render_layer.cpp	(copia de trabajo)
@@ -1083,7 +1083,7 @@
 
     // Paint any child layers that have overflow.
     if (m_overflowList)
-        foreach (RenderLayer* layer, *m_overflowList)
+        Q_FOREACH (RenderLayer* layer, *m_overflowList)
             layer->paintLayer(rootLayer, p, paintDirtyRect, selectionOnly);
 
     // Now walk the sorted list of children with positive z-indices.
Index: khtml/rendering/render_replaced.cpp
===================================================================
--- khtml/rendering/render_replaced.cpp	(revisión: 797670)
+++ khtml/rendering/render_replaced.cpp	(copia de trabajo)
@@ -575,7 +575,7 @@
           return;
       }
 
-      foreach(QObject* o, w->children()) {
+      Q_FOREACH(QObject* o, w->children()) {
           QWidget* const cw = static_cast<QWidget*>(o);
           if (o->isWidgetType() && ! cw->isWindow()
                                 && !(cw->windowModality() & Qt::ApplicationModal)) {
Index: khtml/css/css_ruleimpl.cpp
===================================================================
--- khtml/css/css_ruleimpl.cpp	(revisión: 797670)
+++ khtml/css/css_ruleimpl.cpp	(copia de trabajo)
@@ -379,7 +379,7 @@
 {
     if (m_selector) {
         DOMString str;
-        foreach (CSSSelector *s, *m_selector) {
+        Q_FOREACH (CSSSelector *s, *m_selector) {
             if (s != m_selector->at(0))
                 str += ", ";
             str += s->selectorText();
Index: khtml/css/cssstyleselector.cpp
===================================================================
--- khtml/css/cssstyleselector.cpp	(revisión: 797670)
+++ khtml/css/cssstyleselector.cpp	(copia de trabajo)
@@ -252,7 +252,7 @@
     authorStyle = 0;
     implicitStyle = 0;
 
-    foreach (StyleSheetImpl* sh, styleSheets->styleSheets) {
+    Q_FOREACH (StyleSheetImpl* sh, styleSheets->styleSheets) {
         if ( sh->isCSSStyleSheet() ) {
             if ( static_cast<CSSStyleSheetImpl*>(sh)->implicit() ) {
                 if (!implicitStyle)
Index: khtml/css/css_stylesheetimpl.cpp
===================================================================
--- khtml/css/css_stylesheetimpl.cpp	(revisión: 797670)
+++ khtml/css/css_stylesheetimpl.cpp	(copia de trabajo)
@@ -344,7 +344,7 @@
 
 StyleSheetListImpl::~StyleSheetListImpl()
 {
-    foreach (StyleSheetImpl* sh, styleSheets)
+    Q_FOREACH (StyleSheetImpl* sh, styleSheets)
         sh->deref();
 }
 
@@ -366,7 +366,7 @@
 {
     // hack so implicit BODY stylesheets don't get counted here
     unsigned long l = 0;
-    foreach (StyleSheetImpl* sh, styleSheets) {
+    Q_FOREACH (StyleSheetImpl* sh, styleSheets) {
         if (!sh->isCSSStyleSheet() || !static_cast<CSSStyleSheetImpl*>(sh)->implicit())
             ++l;
     }
@@ -376,7 +376,7 @@
 StyleSheetImpl *StyleSheetListImpl::item ( unsigned long index )
 {
     unsigned long l = 0;
-    foreach (StyleSheetImpl* sh, styleSheets) {
+    Q_FOREACH (StyleSheetImpl* sh, styleSheets) {
         if (!sh->isCSSStyleSheet() || !static_cast<CSSStyleSheetImpl*>(sh)->implicit()) {
             if (l == index)
                 return sh;
Index: khtml/xml/dom_docimpl.cpp
===================================================================
--- khtml/xml/dom_docimpl.cpp	(revisión: 797670)
+++ khtml/xml/dom_docimpl.cpp	(copia de trabajo)
@@ -2291,14 +2291,14 @@
 
     // Include programmatically added style sheets
     if (m_addedStyleSheets) {
-        foreach (StyleSheetImpl* sh, m_addedStyleSheets->styleSheets) {
+        Q_FOREACH (StyleSheetImpl* sh, m_addedStyleSheets->styleSheets) {
             if (sh->isCSSStyleSheet() && !sh->disabled())
                 m_styleSheets->add(sh);
         }
     }
 
     // De-reference all the stylesheets in the old list
-    foreach ( StyleSheetImpl* sh, oldStyleSheets)
+    Q_FOREACH ( StyleSheetImpl* sh, oldStyleSheets)
         sh->deref();
 
     rebuildStyleSelector();
Index: khtml/test_regression.cpp
===================================================================
--- khtml/test_regression.cpp	(revisión: 797670)
+++ khtml/test_regression.cpp	(copia de trabajo)
@@ -806,7 +806,7 @@
     for (; testcase_index < args->count(); testcase_index++)
         tests << args->arg(testcase_index);
     if (tests.count() > 0)
-        foreach (QString test, tests) {
+        Q_FOREACH (QString test, tests) {
 	    result = regressionTest->runTests(test,true);
             if (!result) break;
         }
Index: khtml/imload/decoders/gifloader.cpp
===================================================================
--- khtml/imload/decoders/gifloader.cpp	(revisión: 797670)
+++ khtml/imload/decoders/gifloader.cpp	(copia de trabajo)
@@ -139,7 +139,7 @@
             canvasDrawRegion -= frameInfo[frame].geom;
             QVector<QRect> srcRects = canvasDrawRegion.rects();
     
-            foreach (const QRect& r, srcRects)
+            Q_FOREACH (const QRect& r, srcRects)
                 p->drawPixmap(QPoint(dx + r.x() - sx, dy + r.y() - sy), canvas, r);
         }
         else
Index: cmake/automoc/kde4automoc.cpp
===================================================================
--- cmake/automoc/kde4automoc.cpp	(revisión: 797670)
+++ cmake/automoc/kde4automoc.cpp	(copia de trabajo)
@@ -117,7 +117,7 @@
     Q_ASSERT(line == "MOC_INCLUDES:\n");
     line = dotFiles.readLine().trimmed();
     const QStringList incPaths = QString::fromUtf8(line).split(';');
-    foreach (const QString &path, incPaths) {
+    Q_FOREACH (const QString &path, incPaths) {
         if (!path.isEmpty()) {
             mocIncludes << "-I" + path;
         }
@@ -140,7 +140,7 @@
     QRegExp qObjectRegExp("[\n]\\s*Q_OBJECT\\b");
     QStringList headerExtensions;
     headerExtensions << ".h" << ".hpp" << ".hxx" << ".H";
-    foreach (const QString &absFilename, sourceFiles) {
+    Q_FOREACH (const QString &absFilename, sourceFiles) {
         //qDebug() << absFilename;
         const QFileInfo sourceFileInfo(absFilename);
         if (absFilename.endsWith(".cpp") || absFilename.endsWith(".cc") ||
@@ -196,7 +196,7 @@
                             basename = basename.right(basename.length() - 4);
                         }
                         bool headerFound = false;
-                        foreach (const QString &ext, headerExtensions) {
+                        Q_FOREACH (const QString &ext, headerExtensions) {
                             QString sourceFilePath = absPath + basename + ext;
                             if (QFile::exists(sourceFilePath)) {
                                 headerFound = true;
Index: interfaces/kimproxy/library/kimproxy.cpp
===================================================================
--- interfaces/kimproxy/library/kimproxy.cpp	(revisión: 797670)
+++ interfaces/kimproxy/library/kimproxy.cpp	(copia de trabajo)
@@ -219,7 +219,7 @@
 			const KService::List offers = KServiceTypeTrader::self()->query( IM_SERVICE_TYPE );
 			KService::List::const_iterator offer;
 			QStringList registeredApps = QDBusConnection::sessionBus().interface()->registeredServiceNames();
-			foreach (const QString &app, registeredApps)
+			Q_FOREACH (const QString &app, registeredApps)
 			{
 				//kDebug( 790 ) << " considering: " << *app;
 				//for each offer
Index: interfaces/ktexteditor/smartrange.cpp
===================================================================
--- interfaces/ktexteditor/smartrange.cpp	(revisión: 797670)
+++ interfaces/ktexteditor/smartrange.cpp	(copia de trabajo)
@@ -65,7 +65,7 @@
     // Don't need to check if children should be confined, they already are
     return false;
 
-  foreach (SmartRange* child, m_childRanges)
+  Q_FOREACH (SmartRange* child, m_childRanges)
     child->confineToRange(*this);
 
   return true;
@@ -160,10 +160,10 @@
     m_childRanges.prepend(newChild);
   }
 
-  foreach (SmartRangeNotifier* n, m_notifiers)
+  Q_FOREACH (SmartRangeNotifier* n, m_notifiers)
     emit n->childRangeInserted(this, newChild);
 
-  foreach (SmartRangeWatcher* w, m_watchers)
+  Q_FOREACH (SmartRangeWatcher* w, m_watchers)
     w->childRangeInserted(this, newChild);
 }
 
@@ -173,10 +173,10 @@
   if (index != -1) {
     m_childRanges.removeAt(index);
 
-    foreach (SmartRangeNotifier* n, m_notifiers)
+    Q_FOREACH (SmartRangeNotifier* n, m_notifiers)
       emit n->childRangeInserted(this, child);
 
-    foreach (SmartRangeWatcher* w, m_watchers)
+    Q_FOREACH (SmartRangeWatcher* w, m_watchers)
       w->childRangeInserted(this, child);
   }
 }
@@ -187,7 +187,7 @@
     return 0L;
 
   if (contains(input)) {
-    foreach (SmartRange* r, m_childRanges)
+    Q_FOREACH (SmartRange* r, m_childRanges)
       if (r->contains(input))
         return r->mostSpecificRange(input);
 
@@ -243,7 +243,7 @@
     if (!first && rangesEntered)
       rangesEntered->push(const_cast<SmartRange*>(this));
 
-    foreach (SmartRange* r, m_childRanges) {
+    Q_FOREACH (SmartRange* r, m_childRanges) {
       int result = r->positionRelativeToCursor(pos);
       if (result == 0)
         return r->deepestRangeContainingInternal(pos, rangesEntered, rangesExited);
@@ -311,7 +311,7 @@
 
 void SmartRange::clearChildRanges()
 {
-  foreach (SmartRange* r, m_childRanges)
+  Q_FOREACH (SmartRange* r, m_childRanges)
     r->removeText();
 }
 
@@ -327,7 +327,7 @@
 void SmartRange::clearAndDeleteChildRanges( )
 {
   // FIXME: Probably more efficient to prevent them from unlinking themselves?
-  foreach (SmartRange* r, m_childRanges)
+  Q_FOREACH (SmartRange* r, m_childRanges)
     r->removeText();
 
   qDeleteAll(m_childRanges);
@@ -351,10 +351,10 @@
   if (m_parentRange)
     m_parentRange->insertChildRange(this);
 
-  foreach (SmartRangeNotifier* n, m_notifiers)
+  Q_FOREACH (SmartRangeNotifier* n, m_notifiers)
     emit n->parentRangeChanged(this, m_parentRange, oldParent);
 
-  foreach (SmartRangeWatcher* w, m_watchers)
+  Q_FOREACH (SmartRangeWatcher* w, m_watchers)
     w->parentRangeChanged(this, m_parentRange, oldParent);
 }
 
@@ -367,10 +367,10 @@
 
   m_attribute = attribute;
 
-  foreach (SmartRangeNotifier* n, m_notifiers)
+  Q_FOREACH (SmartRangeNotifier* n, m_notifiers)
     emit n->rangeAttributeChanged(this, attribute, prev);
 
-  foreach (SmartRangeWatcher* w, m_watchers)
+  Q_FOREACH (SmartRangeWatcher* w, m_watchers)
     w->rangeAttributeChanged(this, attribute, prev);
 }
 
@@ -447,7 +447,7 @@
 
   // SmartCursor and its subclasses take care of adjusting ranges if the tree
   // structure is being used.
-  foreach (SmartRangeNotifier* n, m_notifiers)
+  Q_FOREACH (SmartRangeNotifier* n, m_notifiers)
     if (n->wantsDirectChanges()) {
       emit n->rangePositionChanged(this);
       emit n->rangeContentsChanged(this);
@@ -456,7 +456,7 @@
         emit n->rangeEliminated(this);
     }
 
-  foreach (SmartRangeWatcher* w, m_watchers)
+  Q_FOREACH (SmartRangeWatcher* w, m_watchers)
     if (w->wantsDirectChanges()) {
       w->rangePositionChanged(this);
       w->rangeContentsChanged(this);
Index: knotify/config/knotifyeventlist.cpp
===================================================================
--- knotify/config/knotifyeventlist.cpp	(revisión: 797670)
+++ knotify/config/knotifyeventlist.cpp	(copia de trabajo)
@@ -71,7 +71,7 @@
 
 	int mc_x=0;
 	QSize iconsSize = option.decorationSize;
-	foreach(const KIcon &icon, iconList)
+	Q_FOREACH(const KIcon &icon, iconList)
 	{
 		icon.paint(painter, rect.left() + mc_x + 4, rect.top() + (rect.height() - iconsSize.height()) / 2, iconsSize.width(), iconsSize.height());
 		mc_x += iconsSize.width() + 4;
@@ -114,7 +114,7 @@
 	QRegExp rx("^Event/([^/]*)$");
 	conflist=conflist.filter( rx );
 
-	foreach (const QString& group , conflist )
+	Q_FOREACH (const QString& group , conflist )
 	{
                 KConfigGroup cg(config, group);
 		rx.indexIn(group);
@@ -137,7 +137,7 @@
 
 void KNotifyEventList::save( )
 {
-	foreach( KNotifyEventListItem *it , m_elements )
+	Q_FOREACH( KNotifyEventListItem *it , m_elements )
 	{
 		it->save();
 	}
Index: kde3support/kdeui/k3buttonbox.cpp
===================================================================
--- kde3support/kdeui/k3buttonbox.cpp	(revisión: 797670)
+++ kde3support/kdeui/k3buttonbox.cpp	(copia de trabajo)
@@ -166,7 +166,7 @@
   // resize all buttons
   const QSize bs = bestButtonSize();
 
-  foreach(Item *item, data->buttons) {
+  Q_FOREACH(Item *item, data->buttons) {
     QPushButton* const b = item->button;
     if(b) {
       if(item->noexpand)
@@ -186,7 +186,7 @@
     int fs = width() - 2 * data->border;
     int stretch = 0;
     {
-      foreach(Item *item, data->buttons) {
+      Q_FOREACH(Item *item, data->buttons) {
         QPushButton* const b = item->button;
         if(b) {
           fs -= b->width();
@@ -204,7 +204,7 @@
     // distribute buttons
     int x_pos = data->border;
     {
-      foreach(Item *item, data->buttons) {
+      Q_FOREACH(Item *item, data->buttons) {
 
         QPushButton* const b = item->button;
         if(b) {
@@ -223,7 +223,7 @@
     int fs = height() - 2 * data->border;
     int stretch = 0;
     {
-      foreach(Item *item, data->buttons) {
+      Q_FOREACH(Item *item, data->buttons) {
 
         QPushButton* const b = item->button;
         if(b)
@@ -238,7 +238,7 @@
     // distribute buttons
     int y_pos = data->border;
     {
-      foreach(Item *item, data->buttons) {
+      Q_FOREACH(Item *item, data->buttons) {
 
         QPushButton* const b = item->button;
         if(b) {
@@ -262,7 +262,7 @@
   QSize s(0, 0);
 
   // calculate optimal size
-  foreach(Item *item, data->buttons) {
+  Q_FOREACH(Item *item, data->buttons) {
 
     QPushButton* const b = item->button;
 
@@ -292,7 +292,7 @@
 
     const QSize bs = bestButtonSize();
 
-    foreach(Item *item, data->buttons) {
+    Q_FOREACH(Item *item, data->buttons) {
 
       QPushButton* const b = item->button;
 
Index: kde3support/kdeui/k3aboutdialog.cpp
===================================================================
--- kde3support/kdeui/k3aboutdialog.cpp	(revisión: 797670)
+++ kde3support/kdeui/k3aboutdialog.cpp	(copia de trabajo)
@@ -770,7 +770,7 @@
 
   int numChild = 0;
   const QList<QObject*> l = children(); // silence please
-  foreach (QObject *o, l) {
+  Q_FOREACH (QObject *o, l) {
 	  if (o->isWidgetType())
 	  {
 		  ++numChild;
@@ -826,7 +826,7 @@
   setMinimumSize(s);
 
   const QList<QObject*> l = children(); // silence please
-  foreach (QObject *o, l) {
+  Q_FOREACH (QObject *o, l) {
 	if (o->isWidgetType())
 	{
         static_cast<QWidget *>(o)->setMinimumWidth(s.width());
@@ -933,7 +933,7 @@
     {
       cx=qMax(cx, cont->sizeHint().width());
       cy+=cont->sizeHint().height()+Grid;
-      foreach(K3AboutContributor* currEntry, contributors)
+      Q_FOREACH(K3AboutContributor* currEntry, contributors)
 	{
 	  cy+=currEntry->sizeHint().height();
 	}
@@ -1012,7 +1012,7 @@
     } else {
       cont->hide();
     }
-  foreach(K3AboutContributor *currEntry, contributors)
+  Q_FOREACH(K3AboutContributor *currEntry, contributors)
     {
       tempy=currEntry->sizeHint().height();
       // y+=Grid;
Index: kde3support/kdeui/k3dockwidget.cpp
===================================================================
--- kde3support/kdeui/k3dockwidget.cpp	(revisión: 797670)
+++ kde3support/kdeui/k3dockwidget.cpp	(copia de trabajo)
@@ -1682,7 +1682,7 @@
     // search all children if it tries to dock back to a child
     bool found = false;
     QList<K3DockWidget *> cl = findChildren<K3DockWidget *>();
-	foreach ( K3DockWidget *obj, cl ) {
+    Q_FOREACH ( K3DockWidget *obj, cl ) {
 		while ( !found && obj!= 0 ) {
   		QWidget* widg = qobject_cast<QWidget*>(obj);
 			if( widg == formerBrotherDockWidget)
@@ -1801,7 +1801,7 @@
 void K3DockManager::activate()
 {
   K3DockWidget * obj;
-  foreach ( QObject *o, *childDock ) {
+  Q_FOREACH ( QObject *o, *childDock ) {
   	obj=(K3DockWidget*)o;
     if ( obj->widget ) obj->widget->show();
     if ( !obj->parentDockTabGroup() ){
@@ -2014,7 +2014,7 @@
 {
   if ( !p->children().isEmpty() ) {
     QWidget *w;
-    foreach( QObject* o, p->children() )
+    Q_FOREACH( QObject* o, p->children() )
     {
       if ( o->isWidgetType() ) {
         w = (QWidget*)o;
@@ -2033,7 +2033,7 @@
 {
   if ( !p->children().isEmpty() ) {
     QWidget *w;
-    foreach( QObject* o, p->children() )
+    Q_FOREACH( QObject* o, p->children() )
     {
       if ( o->isWidgetType() ) {
         w = (QWidget*)o;
@@ -2246,7 +2246,7 @@
 {
   QDomElement el = doc.createElement(tagName);
 
-  foreach( const QString &s, list )
+  Q_FOREACH( const QString &s, list )
   {
     QDomElement subel = doc.createElement(subTagName);
     subel.appendChild(doc.createTextNode(s));
@@ -2819,7 +2819,7 @@
 
   // firstly, only the common dockwidgets,
   // they must be restored before e.g. tabgroups are restored
-  foreach( const QString &oname, nameList )
+  Q_FOREACH( const QString &oname, nameList )
   {
     cg.changeGroup( group );
     QString type = cg.readEntry( oname + ":type", QString() );
@@ -2855,7 +2855,7 @@
   }
 
   // secondly, after the common dockwidgets, restore the groups and tabgroups
-  foreach( const QString &oname, nameList )
+  Q_FOREACH( const QString &oname, nameList )
   {
     cg.changeGroup( group );
     QString type = cg.readEntry( oname + ":type", QString() );
@@ -2906,7 +2906,7 @@
 
   // thirdly, now that all ordinary dockwidgets are created,
   // iterate them again and link the toplevel ones of them with their corresponding dockwidget for the dockback action
-  foreach( const QString &oname, nameList )
+  Q_FOREACH( const QString &oname, nameList )
   {
     cg.changeGroup( group );
     QString type = cg.readEntry( oname + ":type", QString() );
@@ -3236,7 +3236,7 @@
 #endif
     QList<QWidget *> list = findChildren<QWidget*>();
 
-    foreach( QWidget *w, list )
+    Q_FOREACH( QWidget *w, list )
     {
       w->setGeometry(QRect(QPoint(0,0),size()));
     }
Index: kde3support/kdeui/k3popupmenu.cpp
===================================================================
--- kde3support/kdeui/k3popupmenu.cpp	(revisión: 797670)
+++ kde3support/kdeui/k3popupmenu.cpp	(copia de trabajo)
@@ -248,7 +248,7 @@
     d->keySeq += keyString;
     int seqLen = d->keySeq.length();
 
-    foreach (a, actions()) {
+    Q_FOREACH (a, actions()) {
         // don't search disabled entries
         if (!a->isEnabled())
             continue;
Index: kde3support/tests/kdockwidgetdemo.cpp
===================================================================
--- kde3support/tests/kdockwidgetdemo.cpp	(revisión: 797670)
+++ kde3support/tests/kdockwidgetdemo.cpp	(copia de trabajo)
@@ -646,7 +646,7 @@
 
     listView()->setUpdatesEnabled( false );
     QFileInfoList files = thisDir.entryInfoList();
-    foreach ( const QFileInfo &f, files ){
+    Q_FOREACH ( const QFileInfo &f, files ){
       if ( f.fileName() != "." && f.fileName() != ".." && f.isDir() )
         (void)new Directory( this, f.fileName() );
     }
Index: kde3support/tests/kcommandtest.cpp
===================================================================
--- kde3support/tests/kcommandtest.cpp	(revisión: 797670)
+++ kde3support/tests/kcommandtest.cpp	(copia de trabajo)
@@ -40,7 +40,7 @@
 static QString commandListToString( const QList<K3Command *>& commands )
 {
     QStringList lst;
-    foreach( K3Command* cmd, commands )
+    Q_FOREACH( K3Command* cmd, commands )
         lst.append( cmd->name() );
     return lst.join(",");
 }
Index: kde3support/kunittest/tester.cpp
===================================================================
--- kde3support/kunittest/tester.cpp	(revisión: 797670)
+++ kde3support/kunittest/tester.cpp	(copia de trabajo)
@@ -70,7 +70,7 @@
         if ( allSlots.contains("setUp()") )
             invokeMember("setUp()");
 
-        foreach ( const QByteArray &sl, allSlots )
+        Q_FOREACH ( const QByteArray &sl, allSlots )
         {
             if ( sl.startsWith("test") )
             {
Index: kde3support/kunittest/runner.cpp
===================================================================
--- kde3support/kunittest/runner.cpp	(revisión: 797670)
+++ kde3support/kunittest/runner.cpp	(copia de trabajo)
@@ -233,7 +233,7 @@
         if ( test->inherits("KUnitTest::SlotTester") )
         {
             SlotTester *sltest = static_cast<SlotTester*>(test);
-            foreach( TestResults* res, sltest->resultsList() )
+            Q_FOREACH( TestResults* res, sltest->resultsList() )
             {
                 numPass += res->passed() + res->xpasses();
                 numFail += res->errors() + res->xfails();
Index: kate/render/katerenderrange.cpp
===================================================================
--- kate/render/katerenderrange.cpp	(revisión: 797670)
+++ kate/render/katerenderrange.cpp	(copia de trabajo)
@@ -50,7 +50,7 @@
     return KTextEditor::Cursor(INT_MAX, INT_MAX);
   }
   
-  foreach (KTextEditor::SmartRange* child, r->childRanges()) {
+  Q_FOREACH (KTextEditor::SmartRange* child, r->childRanges()) {
     if (child->start() > m_currentPos)
       return child->start();
   }
@@ -111,7 +111,7 @@
       *a += *a2;
 
     if (m_useDynamic && r2->hasDynamic())
-      foreach (KateDynamicAnimation* anim, r2->dynamicAnimations())
+      Q_FOREACH (KateDynamicAnimation* anim, r2->dynamicAnimations())
         anim->mergeToAttribute(a);
 
     m_attribs.push(a);
@@ -183,7 +183,7 @@
 
 void RenderRangeList::appendRanges(const QList<KTextEditor::SmartRange*>& startingRanges, bool useDynamic, KateView* view)
 {
-  foreach (KTextEditor::SmartRange* range, startingRanges)
+  Q_FOREACH (KTextEditor::SmartRange* range, startingRanges)
     append(new SmartRenderRange(static_cast<KateSmartRange*>(range), useDynamic, view));
 }
 
@@ -191,7 +191,7 @@
 {
   KTextEditor::Cursor ret = m_currentPos;
   bool first = true;
-  foreach (KateRenderRange* r, *this) {
+  Q_FOREACH (KateRenderRange* r, *this) {
     if (first) {
       ret = r->nextBoundary();
       first = false;
@@ -209,7 +209,7 @@
 {
   bool ret = false;
 
-  foreach (KateRenderRange* r, *this)
+  Q_FOREACH (KateRenderRange* r, *this)
     ret |= r->advanceTo(pos);
 
   return ret;
@@ -217,7 +217,7 @@
 
 bool RenderRangeList::hasAttribute() const
 {
-  foreach (KateRenderRange* r, *this)
+  Q_FOREACH (KateRenderRange* r, *this)
     if (r->currentAttribute())
       return true;
 
@@ -228,7 +228,7 @@
 {
   KTextEditor::Attribute a;
 
-  foreach (KateRenderRange* r, *this)
+  Q_FOREACH (KateRenderRange* r, *this)
     if (KTextEditor::Attribute::Ptr a2 = r->currentAttribute())
       a += *a2;
 
Index: kate/render/katelayoutcache.cpp
===================================================================
--- kate/render/katelayoutcache.cpp	(revisión: 797670)
+++ kate/render/katelayoutcache.cpp	(copia de trabajo)
@@ -186,7 +186,7 @@
 KateTextLayout KateLayoutCache::textLayout( const KTextEditor::Cursor & realCursor ) const
 {
   /*if (realCursor >= viewCacheStart() && (realCursor < viewCacheEnd() || realCursor == viewCacheEnd() && !m_textLayouts.last().wrap()))
-    foreach (const KateTextLayout& l, m_textLayouts)
+    Q_FOREACH (const KateTextLayout& l, m_textLayouts)
       if (l.line() == realCursor.line() && (l.endCol() < realCursor.column() || !l.wrap()))
         return l;*/
 
@@ -197,7 +197,7 @@
 {
   /*if (m_textLayouts.count() && (realLine >= m_textLayouts.first().line() && _viewLine >= m_textLayouts.first().viewLine()) &&
       (realLine <= m_textLayouts.last().line() && _viewLine <= m_textLayouts.first().viewLine()))
-    foreach (const KateTextLayout& l, m_textLayouts)
+    Q_FOREACH (const KateTextLayout& l, m_textLayouts)
       if (l.line() == realLine && l.viewLine() == _viewLine)
         return const_cast<KateTextLayout&>(l);*/
 
@@ -320,7 +320,7 @@
 {
   kDebug() << "Printing values for " << m_textLayouts.count() << " lines:";
   if (m_textLayouts.count())
-  foreach (const KateTextLayout& t, m_textLayouts)
+  Q_FOREACH (const KateTextLayout& t, m_textLayouts)
     if (t.isValid())
       t.debugOutput();
     else
Index: kate/render/katerenderer.cpp
===================================================================
--- kate/render/katerenderer.cpp	(revisión: 797670)
+++ kate/render/katerenderer.cpp	(copia de trabajo)
@@ -610,7 +610,7 @@
         c = m_caretOverrideColor;
 
       } else {
-        foreach (const QTextLayout::FormatRange &r, range->layout()->additionalFormats())
+        Q_FOREACH (const QTextLayout::FormatRange &r, range->layout()->additionalFormats())
           if ( (r.start <= cursor->column() ) && ( (r.start + r.length)  > cursor->column()) ) {
             c = r.format.foreground().color();
             break;
@@ -787,7 +787,7 @@
   bool needShiftX = (maxwidth != -1)
                  && (m_view->config()->dynWordWrapAlignIndent() > 0);
 
-  forever {
+  Q_FOREVER {
     QTextLine line = l->createLine();
     if (!line.isValid())
       break;
Index: kate/plugins/kdatatool/kate_kdatatool.cpp
===================================================================
--- kate/plugins/kdatatool/kate_kdatatool.cpp	(revisión: 797670)
+++ kate/plugins/kdatatool/kate_kdatatool.cpp	(copia de trabajo)
@@ -96,7 +96,7 @@
 	m_wordUnderCursor.clear();
 
 	// unplug old actions, if any:
-	foreach (QAction *ac, m_actionList) {
+	Q_FOREACH (QAction *ac, m_actionList) {
 		m_menu->removeAction(ac);
 	}
 	if (m_notAvailable) {
@@ -165,7 +165,7 @@
 		SLOT( slotToolActivated( const KDataToolInfo &, const QString & ) ),
                                                             actionCollection());
 
-	foreach (QAction* ac, m_actionList)
+	Q_FOREACH (QAction* ac, m_actionList)
 		m_menu->addAction(ac);
 
 	if( m_actionList.isEmpty() ) {
Index: kate/plugins/wordcompletion/docwordcompletion.cpp
===================================================================
--- kate/plugins/wordcompletion/docwordcompletion.cpp	(revisión: 797670)
+++ kate/plugins/wordcompletion/docwordcompletion.cpp	(copia de trabajo)
@@ -225,7 +225,7 @@
 
     // If the property has been set for the plugin in general, let's set that
     // property to that value on all views where the plugin has been loaded.
-    foreach (DocWordCompletionPluginView *view, m_views)
+    Q_FOREACH (DocWordCompletionPluginView *view, m_views)
     {
         view->setTreshold(t);
     }
@@ -242,7 +242,7 @@
 
     // If the property has been set for the plugin in general, let's set that
     // property to that value on all views where the plugin has been loaded.
-    foreach (DocWordCompletionPluginView *view, m_views)
+    Q_FOREACH (DocWordCompletionPluginView *view, m_views)
     {
         view->setAutoPopupEnabled(enable);
         view->toggleAutoPopup();
Index: kate/plugins/timedate/timedate.cpp
===================================================================
--- kate/plugins/timedate/timedate.cpp	(revisión: 797670)
+++ kate/plugins/timedate/timedate.cpp	(copia de trabajo)
@@ -101,7 +101,7 @@
 
     // If the property has been set for the plugin in general, let's set that
     // property to that value on all views where the plugin has been loaded.
-    foreach (TimeDatePluginView *pluginView, m_views)
+    Q_FOREACH (TimeDatePluginView *pluginView, m_views)
     {
         pluginView->setFormat(format);
     }
Index: kate/dialogs/katedialogs.cpp
===================================================================
--- kate/dialogs/katedialogs.cpp	(revisión: 797670)
+++ kate/dialogs/katedialogs.cpp	(copia de trabajo)
@@ -738,7 +738,7 @@
   ui->cmbEncodingDetection->addItem (i18n("Disabled"));
   ui->cmbEncodingDetection->setCurrentIndex(0);
 
-  foreach(const QStringList &encodingsForScript, KGlobal::charsets()->encodingsByScript())
+  Q_FOREACH(const QStringList &encodingsForScript, KGlobal::charsets()->encodingsByScript())
   {
     KEncodingDetector::AutoDetectScript scri=KEncodingDetector::scriptForName(encodingsForScript.at(0));
     if (KEncodingDetector::hasAutoDetectionForScript(scri))
@@ -804,7 +804,7 @@
   plugins.clear();
 
   int i = 0;
-  foreach (const KatePartPluginInfo &info, KatePartPluginManager::self()->pluginList())
+  Q_FOREACH (const KatePartPluginInfo &info, KatePartPluginManager::self()->pluginList())
   {
     KPluginInfo it(info.service);
     it.setPluginEnabled(info.load);
@@ -1023,7 +1023,7 @@
 void KateHlDownloadDialog::slotUser1()
 {
   QString destdir=KGlobal::dirs()->saveLocation("data","katepart/syntax/");
-  foreach (QTreeWidgetItem *it, list->selectedItems())
+  Q_FOREACH (QTreeWidgetItem *it, list->selectedItems())
   {
     KUrl src(it->text(4));
     QString filename=src.fileName(KUrl::ObeyTrailingSlash);
Index: kate/mode/katemodemanager.cpp
===================================================================
--- kate/mode/katemodemanager.cpp	(revisión: 797670)
+++ kate/mode/katemodemanager.cpp	(copia de trabajo)
@@ -172,7 +172,7 @@
   KConfigGroup config(&katerc, QString());
 
   QStringList newg;
-  foreach (const KateFileType *type, v)
+  Q_FOREACH (const KateFileType *type, v)
   {
     config.changeGroup(type->name);
 
@@ -252,7 +252,7 @@
 
   QList<KateFileType*> types;
 
-  foreach (KateFileType *type, m_types)
+  Q_FOREACH (KateFileType *type, m_types)
   {
     if (type->mimetypes.indexOf (mt->name()) > -1)
       types.append (type);
@@ -263,7 +263,7 @@
     int pri = -1;
     QString name;
 
-    foreach (KateFileType *type, types)
+    Q_FOREACH (KateFileType *type, types)
     {
       if (type->priority > pri)
       {
@@ -283,13 +283,13 @@
 {
   KateFileType * match = NULL;
   int minPrio = -1;
-  foreach (KateFileType *type, m_types)
+  Q_FOREACH (KateFileType *type, m_types)
   {
     if (type->priority <= minPrio) {
       continue;
     }
 
-    foreach (const QString &wildcard, type->wildcards)
+    Q_FOREACH (const QString &wildcard, type->wildcards)
     {
       if (KateWildcardMatcher::exactMatch(fileName, wildcard)) {
         match = type;
Index: kate/mode/katemodeconfigpage.cpp
===================================================================
--- kate/mode/katemodeconfigpage.cpp	(revisión: 797670)
+++ kate/mode/katemodeconfigpage.cpp	(copia de trabajo)
@@ -117,7 +117,7 @@
   m_types.clear();
 
   // deep copy...
-  foreach (KateFileType *type, KateGlobal::self()->modeManager()->list())
+  Q_FOREACH (KateFileType *type, KateGlobal::self()->modeManager()->list())
   {
     KateFileType *t = new KateFileType ();
     *t = *type;
@@ -143,7 +143,7 @@
 
   ui->cmbFiletypes->clear ();
 
-  foreach (KateFileType *type, m_types) {
+  Q_FOREACH (KateFileType *type, m_types) {
     if (type->section.length() > 0)
       ui->cmbFiletypes->addItem(type->section + QString ("/") + type->name);
     else
Index: kate/smart/katesmartregion.cpp
===================================================================
--- kate/smart/katesmartregion.cpp	(revisión: 797670)
+++ kate/smart/katesmartregion.cpp	(copia de trabajo)
@@ -49,7 +49,7 @@
 {
   *m_bounding = KTextEditor::Range::invalid();
 
-  foreach (KateSmartRange* range, m_source) {
+  Q_FOREACH (KateSmartRange* range, m_source) {
     if (!m_bounding->isValid())
       *m_bounding = *range;
     else
Index: kate/smart/katesmartmanager.cpp
===================================================================
--- kate/smart/katesmartmanager.cpp	(revisión: 797670)
+++ kate/smart/katesmartmanager.cpp	(copia de trabajo)
@@ -254,7 +254,7 @@
   }
 
   // Range feedback
-  foreach (KateSmartRange* range, m_topRanges) {
+  Q_FOREACH (KateSmartRange* range, m_topRanges) {
     KateSmartRange* mostSpecific = feedbackRange(*edit, range);
 
     if (!mostSpecific)
@@ -274,7 +274,7 @@
   if (range->end() < edit.start())
     return mostSpecific;
 
-  foreach (SmartRange* child, range->childRanges())
+  Q_FOREACH (SmartRange* child, range->childRanges())
     if (!mostSpecific)
       mostSpecific = feedbackRange(edit, static_cast<KateSmartRange*>(child));
     else
@@ -301,10 +301,10 @@
 {
   //kDebug() << "Was " << edit.oldRange() << " now " << edit.newRange() << " numcursors feedback " << m_feedbackCursors.count() << " normal " << m_normalCursors.count();
 
-  foreach (KateSmartCursor* cursor, m_feedbackCursors)
+  Q_FOREACH (KateSmartCursor* cursor, m_feedbackCursors)
     cursor->translate(edit);
 
-  foreach (KateSmartCursor* cursor, m_normalCursors)
+  Q_FOREACH (KateSmartCursor* cursor, m_normalCursors)
     cursor->translate(edit);
 }
 
@@ -319,7 +319,7 @@
   m_startLine = m_newStartLine;
   m_endLine = m_newEndLine;
 
-  foreach (KateSmartCursor* cursor, m_feedbackCursors)
+  Q_FOREACH (KateSmartCursor* cursor, m_feedbackCursors)
     cursor->translated(edit);
 }
 
@@ -334,7 +334,7 @@
     return;
 
   // Todo: don't need to provide positionChanged to all feedback cursors?
-  foreach (KateSmartCursor* cursor, m_feedbackCursors)
+  Q_FOREACH (KateSmartCursor* cursor, m_feedbackCursors)
     cursor->shifted();
 }
 
@@ -357,11 +357,11 @@
 {
   Q_ASSERT(m_next);
 
-  foreach (KateSmartCursor* cursor, next()->feedbackCursors())
+  Q_FOREACH (KateSmartCursor* cursor, next()->feedbackCursors())
     cursor->migrate(this);
   m_feedbackCursors += next()->feedbackCursors();
 
-  foreach (KateSmartCursor* cursor, next()->normalCursors())
+  Q_FOREACH (KateSmartCursor* cursor, next()->normalCursors())
     cursor->migrate(this);
   m_normalCursors += next()->normalCursors();
 
@@ -412,11 +412,11 @@
   Q_ASSERT(currentGroup);
   Q_ASSERT(currentGroup == m_firstGroup);
 
-  forever {
+  Q_FOREVER {
     if (!currentGroup->previous())
       Q_ASSERT(currentGroup->startLine() == 0);
 
-    foreach (KateSmartCursor* cursor, currentGroup->feedbackCursors()) {
+    Q_FOREACH (KateSmartCursor* cursor, currentGroup->feedbackCursors()) {
       Q_ASSERT(currentGroup->containsLine(cursor->line()));
       Q_ASSERT(cursor->smartGroup() == currentGroup);
     }
@@ -484,7 +484,7 @@
 
 void KateSmartGroup::deleteCursorsInternal( QSet< KateSmartCursor * > & set )
 {
-  foreach (KateSmartCursor* c, set.toList()) {
+  Q_FOREACH (KateSmartCursor* c, set.toList()) {
     if (!c->range() && !c->isInternal()) {
       set.remove(c);
       delete c;
@@ -494,7 +494,7 @@
 
 void KateSmartManager::deleteRanges( bool includingInternal )
 {
-  foreach (KateSmartRange* range, m_topRanges.toList()) {
+  Q_FOREACH (KateSmartRange* range, m_topRanges.toList()) {
     if (includingInternal || !range->isInternal()) {
       range->deleteChildRanges();
       delete range;
@@ -583,7 +583,7 @@
 {
   Cursor ret = cursor;
 
-  foreach (KateEditInfo* edit, doc()->history()->editsBetweenRevisions(usingRevision()))
+  Q_FOREACH (KateEditInfo* edit, doc()->history()->editsBetweenRevisions(usingRevision()))
     translate(edit, ret, insertBehavior);
 
   return ret;
@@ -593,7 +593,7 @@
 {
   Range ret = range;
 
-  foreach (KateEditInfo* edit, doc()->history()->editsBetweenRevisions(usingRevision())) {
+  Q_FOREACH (KateEditInfo* edit, doc()->history()->editsBetweenRevisions(usingRevision())) {
     translate(edit, ret.start(), insertBehavior & KTextEditor::SmartRange::ExpandLeft ? SmartCursor::StayOnInsert : SmartCursor::MoveOnInsert);
     translate(edit, ret.end(), insertBehavior & KTextEditor::SmartRange::ExpandRight ? SmartCursor::MoveOnInsert : SmartCursor::StayOnInsert);
   }
Index: kate/smart/katesmartrange.cpp
===================================================================
--- kate/smart/katesmartrange.cpp	(revisión: 797670)
+++ kate/smart/katesmartrange.cpp	(copia de trabajo)
@@ -58,18 +58,18 @@
 
 KateSmartRange::~KateSmartRange()
 {
-  foreach (KTextEditor::SmartRangeNotifier* n, notifiers()) {
+  Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers()) {
     emit static_cast<KateSmartRangeNotifier*>(n)->rangeDeleted(this);
     // FIXME delete the notifier
   }
 
-  foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+  Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
     w->rangeDeleted(this);
 
   if (m_start)
     kateDocument()->smartManager()->rangeDeleted(this);
 
-  foreach (KateSmartRangePtr* ptr, m_pointers)
+  Q_FOREACH (KateSmartRangePtr* ptr, m_pointers)
     ptr->deleted();
 }
 
@@ -114,41 +114,41 @@
 
   if (kStart().lastPosition() != kStart()) {
     // position changed
-    foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+    Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
       emit static_cast<KateSmartRangeNotifier*>(n)->rangePositionChanged(this);
-    foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+    Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
       w->rangePositionChanged(this);
   }
 
   if (kStart().lastPosition() <= edit.oldRange().end()) {
     // contents changed
-    foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+    Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
       emit static_cast<KateSmartRangeNotifier*>(n)->rangeContentsChanged(this);
-    foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+    Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
       w->rangeContentsChanged(this);
 
     /*if (kStart().lastPosition() >= edit.start() && kStart().lastPosition() < edit.oldRange().end()) {
       // first character deleted
-      foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+      Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
         emit static_cast<KateSmartRangeNotifier*>(n)->firstCharacterDeleted(this);
-      foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+      Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
         w->firstCharacterDeleted(this);
     }
 
     if (kEnd().lastPosition() >= edit.start() && kEnd().lastPosition() <= edit.oldRange().end()) {
       // last character deleted
-      foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+      Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
         emit static_cast<KateSmartRangeNotifier*>(n)->lastCharacterDeleted(this);
-      foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+      Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
         w->lastCharacterDeleted(this);
     }*/
   }
 
   if (start() == end() && kStart().lastPosition() != kEnd().lastPosition()) {
     // range eliminated
-    foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+    Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
       emit static_cast<KateSmartRangeNotifier*>(n)->rangeEliminated(this);
-    foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+    Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
       w->rangeEliminated(this);
   }
 
@@ -159,9 +159,9 @@
 void KateSmartRange::feedbackMostSpecific( KateSmartRange * mostSpecific )
 {
   // most specific range feedback
-  foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+  Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
     emit static_cast<KateSmartRangeNotifier*>(n)->rangeContentsChanged(this, mostSpecific);
-  foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+  Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
     w->rangeContentsChanged(this, mostSpecific);
 }
 
@@ -169,29 +169,29 @@
 {
   if (mouse) {
     if (entered) {
-      foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+      Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
         emit static_cast<KateSmartRangeNotifier*>(n)->mouseEnteredRange(this, view);
-      foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+      Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
         w->mouseEnteredRange(this, view);
 
     } else {
-      foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+      Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
         emit static_cast<KateSmartRangeNotifier*>(n)->mouseExitedRange(this, view);
-      foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+      Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
         w->mouseExitedRange(this, view);
     }
 
   } else {
     if (entered) {
-      foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+      Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
         emit static_cast<KateSmartRangeNotifier*>(n)->caretEnteredRange(this, view);
-      foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+      Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
         w->caretEnteredRange(this, view);
 
     } else {
-      foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+      Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
         emit static_cast<KateSmartRangeNotifier*>(n)->caretExitedRange(this, view);
-      foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+      Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
         w->caretExitedRange(this, view);
     }
   }
@@ -201,9 +201,9 @@
 {
   if (kStart().lastPosition() != kStart()) {
     // position changed
-    foreach (KTextEditor::SmartRangeNotifier* n, notifiers())
+    Q_FOREACH (KTextEditor::SmartRangeNotifier* n, notifiers())
       emit static_cast<KateSmartRangeNotifier*>(n)->rangePositionChanged(this);
-    foreach (KTextEditor::SmartRangeWatcher* w, watchers())
+    Q_FOREACH (KTextEditor::SmartRangeWatcher* w, watchers())
       w->rangePositionChanged(this);
   }
 
@@ -247,7 +247,7 @@
 
 /*KateDynamicAnimation * KateSmartRange::dynamicForView( const KateView * const view) const
 {
-  foreach (KateDynamicAnimation* anim, m_dynamic)
+  Q_FOREACH (KateDynamicAnimation* anim, m_dynamic)
     if (anim->view() == view)
       return anim;
 
Index: kate/syntax/katehighlight.cpp
===================================================================
--- kate/syntax/katehighlight.cpp	(revisión: 797670)
+++ kate/syntax/katehighlight.cpp	(copia de trabajo)
@@ -504,7 +504,7 @@
   list.clear();
   createKateExtendedAttribute(list);
 
-  foreach (KateExtendedAttribute::Ptr p, list)
+  Q_FOREACH (KateExtendedAttribute::Ptr p, list)
   {
     Q_ASSERT(p);
 
@@ -552,7 +552,7 @@
 
   list.clear();
 
-  foreach (KateExtendedAttribute::Ptr attribute, attributes)
+  Q_FOREACH (KateExtendedAttribute::Ptr attribute, attributes)
     list.append(KateExtendedAttribute::Ptr(new KateExtendedAttribute(*attribute.data())));
 }
 
@@ -571,7 +571,7 @@
 
   QStringList settings;
 
-  foreach (const KateExtendedAttribute::Ptr& p, list)
+  Q_FOREACH (const KateExtendedAttribute::Ptr& p, list)
   {
     Q_ASSERT(p);
 
Index: kate/syntax/katecodefolding.cpp
===================================================================
--- kate/syntax/katecodefolding.cpp	(revisión: 797670)
+++ kate/syntax/katecodefolding.cpp	(copia de trabajo)
@@ -221,7 +221,7 @@
       info->topLevel = false; //we are definitly not toplevel
       findAllNodesOpenedOrClosedAt(line); //lookup all nodes, which start or and at the given line
 
-      foreach (KateCodeFoldingNode* node, nodesForLine)
+      Q_FOREACH (KateCodeFoldingNode* node, nodesForLine)
       {
         uint startLine = getStartLine(node);
 
Index: kate/syntax/katesyntaxmanager.cpp
===================================================================
--- kate/syntax/katesyntaxmanager.cpp	(revisión: 797670)
+++ kate/syntax/katesyntaxmanager.cpp	(copia de trabajo)
@@ -371,7 +371,7 @@
   if (lastCtxsReset.elapsed() < KATE_DYNAMIC_CONTEXTS_RESET_DELAY)
     return false;
 
-  foreach (KateHighlighting *hl, hlList)
+  Q_FOREACH (KateHighlighting *hl, hlList)
     hl->dropDynamicContexts();
 
   dynamicCtxsCount = 0;
Index: kate/utils/katepartpluginmanager.cpp
===================================================================
--- kate/utils/katepartpluginmanager.cpp	(revisión: 797670)
+++ kate/utils/katepartpluginmanager.cpp	(copia de trabajo)
@@ -71,7 +71,7 @@
   KService::List traderList = KServiceTypeTrader::self()->
       query("KTextEditor/Plugin", "([X-KDE-Version] >= 4.0) and ([X-KDE-Version] <= 4.0)");
 
-  foreach(const KService::Ptr &ptr, traderList)
+  Q_FOREACH(const KService::Ptr &ptr, traderList)
   {
     KatePartPluginInfo info;
 
@@ -139,7 +139,7 @@
   KConfigGroup cg = KConfigGroup(m_config, "Kate Part Plugins");
 
   // disable all plugin if no config...
-  foreach (const KatePartPluginInfo &plugin, m_pluginList)
+  Q_FOREACH (const KatePartPluginInfo &plugin, m_pluginList)
     plugin.load = cg.readEntry (plugin.service->library(), false)
                || cg.readEntry (plugin.service->property("X-KDE-PluginInfo-Name").toString(), false);
 
@@ -149,7 +149,7 @@
 void KatePartPluginManager::writeConfig()
 {
   KConfigGroup cg = KConfigGroup( m_config, "Kate Part Plugins" );
-  foreach(const KatePartPluginInfo &it, m_pluginList)
+  Q_FOREACH(const KatePartPluginInfo &it, m_pluginList)
   {
     cg.writeEntry (it.saveName(), it.load);
   }
@@ -203,11 +203,11 @@
     return;
 
   // register docs and views
-  foreach (KTextEditor::Document *doc, KateGlobal::self()->documents()) {
+  Q_FOREACH (KTextEditor::Document *doc, KateGlobal::self()->documents()) {
     if (!doc)
       continue;
 
-    foreach (KTextEditor::View *view, doc->views()) {
+    Q_FOREACH (KTextEditor::View *view, doc->views()) {
       if (!view)
         continue;
 
@@ -230,11 +230,11 @@
     return;
 
   // de-register docs and views
-  foreach (KTextEditor::Document *doc, KateGlobal::self()->documents()) {
+  Q_FOREACH (KTextEditor::Document *doc, KateGlobal::self()->documents()) {
     if (!doc)
       continue;
 
-    foreach (KTextEditor::View *view, doc->views()) {
+    Q_FOREACH (KTextEditor::View *view, doc->views()) {
       if (!view)
         continue;
 
Index: kate/utils/katedynamicanimation.cpp
===================================================================
--- kate/utils/katedynamicanimation.cpp	(revisión: 797670)
+++ kate/utils/katedynamicanimation.cpp	(copia de trabajo)
@@ -58,7 +58,7 @@
     if (view())
       view()->renderer()->dynamicRegion().removeRange(m_range);
     else
-      foreach (KTextEditor::View* view, document()->views())
+      Q_FOREACH (KTextEditor::View* view, document()->views())
         static_cast<KateView*>(view)->renderer()->dynamicRegion().removeRange(m_range);
   }
 }
Index: kate/utils/kateschema.cpp
===================================================================
--- kate/utils/kateschema.cpp	(revisión: 797670)
+++ kate/utils/kateschema.cpp	(copia de trabajo)
@@ -922,7 +922,7 @@
   if (!view) return;
 
   QString id=view->renderer()->config()->schema();
-   foreach(QAction *a,menu()->actions()) {
+   Q_FOREACH(QAction *a,menu()->actions()) {
 	a->setChecked(a->data().toString()==id);
 
 	}
Index: kate/utils/kateconfig.cpp
===================================================================
--- kate/utils/kateconfig.cpp	(revisión: 797670)
+++ kate/utils/kateconfig.cpp	(copia de trabajo)
@@ -1107,7 +1107,7 @@
 void KateRendererConfig::reloadSchema()
 {
   if ( isGlobal() )
-    foreach (KateView* view, KateGlobal::self()->views() )
+    Q_FOREACH (KateView* view, KateGlobal::self()->views() )
       view->renderer()->config()->reloadSchema();
 
   else if ( m_renderer && m_schemaSet )
Index: kate/utils/katetemplatehandler.cpp
===================================================================
--- kate/utils/katetemplatehandler.cpp	(revisión: 797670)
+++ kate/utils/katetemplatehandler.cpp	(copia de trabajo)
@@ -201,7 +201,7 @@
   uint col = insertPosition.column();
   uint colInText = 0;
 
-  foreach (const KateTemplateHandlerPlaceHolderInfo& info, buildList)
+  Q_FOREACH (const KateTemplateHandlerPlaceHolderInfo& info, buildList)
   {
     bool firstOccurrence=false;
     KateTemplatePlaceHolder *ph = m_dict[ info.placeholder ];
@@ -297,7 +297,7 @@
   //Q_ASSERT( !m_doc->isEditRunning() );
 
 
-    foreach ( KTextEditor::SmartRange* range, ph->ranges )
+    Q_FOREACH ( KTextEditor::SmartRange* range, ph->ranges )
   {
     if ( range == m_currentRange ) continue;
     kDebug(13020)<<"KateTemplateHandler::slotTextInserted: updating a range";
@@ -330,7 +330,7 @@
   {
     KateTemplatePlaceHolder *ph = m_tabOrder.at( i );
 
-    foreach ( KTextEditor::SmartRange* range, ph->ranges)
+    Q_FOREACH ( KTextEditor::SmartRange* range, ph->ranges)
     {
       if ( range->contains( cursor ) )
       {
Index: kate/utils/kateprinter.cpp
===================================================================
--- kate/utils/kateprinter.cpp	(revisión: 797670)
+++ kate/utils/kateprinter.cpp	(copia de trabajo)
@@ -498,7 +498,7 @@
           y += 1 + innerMargin;
 
           int _widest( 0 );
-          foreach (KateExtendedAttribute::Ptr attribute, _attributes)
+          Q_FOREACH (KateExtendedAttribute::Ptr attribute, _attributes)
             _widest = qMax(QFontMetrics(attribute->font()).width(attribute->name().section(':',1,1)), _widest);
 
           int _guideCols = _w/( _widest + innerMargin );
@@ -509,7 +509,7 @@
 
           _titleFont.setUnderline(true);
           QString _currentHlName;
-          foreach (KateExtendedAttribute::Ptr attribute, _attributes)
+          Q_FOREACH (KateExtendedAttribute::Ptr attribute, _attributes)
           {
             QString _hl = attribute->name().section(':',0,0);
             QString _name = attribute->name().section(':',1,1);
Index: kate/tests/kateregression.cpp
===================================================================
--- kate/tests/kateregression.cpp	(revisión: 797670)
+++ kate/tests/kateregression.cpp	(copia de trabajo)
@@ -211,12 +211,12 @@
 
 void KateRegression::checkSignalExpectations( )
 {
-  foreach (CursorExpectation* e, m_cursorExpectations)
+  Q_FOREACH (CursorExpectation* e, m_cursorExpectations)
     e->checkExpectationsFulfilled();
   qDeleteAll(m_cursorExpectations);
   m_cursorExpectations.clear();
 
-  foreach (RangeExpectation* e, m_rangeExpectations)
+  Q_FOREACH (RangeExpectation* e, m_rangeExpectations)
     e->checkExpectationsFulfilled();
   qDeleteAll(m_rangeExpectations);
   m_rangeExpectations.clear();
Index: kate/tests/arbitraryhighlighttest.cpp
===================================================================
--- kate/tests/arbitraryhighlighttest.cpp	(revisión: 797670)
+++ kate/tests/arbitraryhighlighttest.cpp	(copia de trabajo)
@@ -102,7 +102,7 @@
 
   text = currentRange->document()->textLines(textNeeded);
 
-  foreach (const QString &string, text) {
+  Q_FOREACH (const QString &string, text) {
     for (int i = 0; i < string.length(); ++i) {
       if (string.at(i) == openBrace) {
         currentRange = smart()->newSmartRange(current, currentRange->end(), currentRange);
@@ -129,7 +129,7 @@
 void ArbitraryHighlightTest::outputRange( KTextEditor::SmartRange * range, KTextEditor::SmartRange * mostSpecific )
 {
   kDebug() << (mostSpecific == range ? "==> " : "       ") << QString(range->depth(), ' ') << *range;
-  foreach (SmartRange* child, range->childRanges())
+  Q_FOREACH (SmartRange* child, range->childRanges())
     outputRange(child, mostSpecific);
 }
 
Index: kate/script/katescriptmanager.cpp
===================================================================
--- kate/script/katescriptmanager.cpp	(revisión: 797670)
+++ kate/script/katescriptmanager.cpp	(copia de trabajo)
@@ -52,7 +52,7 @@
 KateIndentScript *KateScriptManager::indenter(const QString &language)
 {
   KateIndentScript *highestPriorityIndenter = 0;
-  foreach(KateIndentScript *indenter, m_languageToIndenters.value(language.toLower())) {
+  Q_FOREACH(KateIndentScript *indenter, m_languageToIndenters.value(language.toLower())) {
     // don't overwrite if there is already a result with a higher priority
     if(highestPriorityIndenter && indenter->information().priority < highestPriorityIndenter->information().priority) {
       kDebug(13050) << "KateScriptManager::indenter: Not overwriting indenter for '"
@@ -181,7 +181,7 @@
         }
         information.priority = convertedToInt ? priority : 0;
         KateIndentScript *script = new KateIndentScript(*fileit, information);
-        foreach(QString language, information.indentLanguages) {
+        Q_FOREACH(QString language, information.indentLanguages) {
           m_languageToIndenters[language.toLower()].push_back(script);
         }
         m_scripts.push_back(script);
@@ -302,7 +302,7 @@
 
   KJS::List params;
 
-  foreach(const QString &a, args)
+  Q_FOREACH(const QString &a, args)
     params.append(KJS::jsString(a));
 
   KJS::JSValue *val = inter->callFunction(kateView, inter->interpreter()->globalObject(), KJS::Identifier(cmd),
Index: kate/completion/katecompletionmodel.cpp
===================================================================
--- kate/completion/katecompletionmodel.cpp	(revisión: 797670)
+++ kate/completion/katecompletionmodel.cpp	(copia de trabajo)
@@ -177,8 +177,8 @@
       case Qt::TextAlignmentRole:
         if (isColumnMergingEnabled() && m_columnMerges.count()) {
           int c = 0;
-          foreach (const QList<int>& list, m_columnMerges) {
-            foreach (int column, list) {
+          Q_FOREACH (const QList<int>& list, m_columnMerges) {
+            Q_FOREACH (int column, list) {
               if (c++ == index.column()) {
                 if (column == CodeCompletionModel::Scope)
                   if (list.count() == 1)
@@ -200,7 +200,7 @@
     // Merge text for column merging
     if (role == Qt::DisplayRole && m_columnMerges.count() && isColumnMergingEnabled()) {
       QString text;
-      foreach (int column, m_columnMerges[index.column()]) {
+      Q_FOREACH (int column, m_columnMerges[index.column()]) {
         QModelIndex sourceIndex = mapToSource(createIndex(index.row(), column, index.internalPointer()));
         text.append(sourceIndex.data(role).toString());
       }
@@ -259,7 +259,7 @@
 
   int bestMatch = -1;
   //Iterate through all argument-hints and find the best match-quality
-  foreach( const ModelRow& row, m_argumentHints->rows )
+  Q_FOREACH( const ModelRow& row, m_argumentHints->rows )
   {
     if( realIndex.model() != row.first )
       continue; //We can only match within the same source-model
@@ -512,7 +512,7 @@
 {
   clearGroups();
 
-  foreach (CodeCompletionModel* sourceModel, m_completionModels)
+  Q_FOREACH (CodeCompletionModel* sourceModel, m_completionModels)
     for (int i = 0; i < sourceModel->rowCount(); ++i)
       createItems(HierarchicalModelHandler(sourceModel), sourceModel->index(i, 0));
 
@@ -563,7 +563,7 @@
   for (int i = start; i <= end; ++i)
     affectedGroups += createItems(handler, parent.isValid() ? parent.child(i, 0) :  handler.model()->index(i, 0), true);
     
-  foreach (Group* g, affectedGroups)
+  Q_FOREACH (Group* g, affectedGroups)
       hideOrShowGroup(g);
   
     emit contentGeometryChanged();
@@ -581,7 +581,7 @@
     affectedGroups += deleteItems(index);
   }
 
-  foreach (Group* g, affectedGroups)
+  Q_FOREACH (Group* g, affectedGroups)
     hideOrShowGroup(g);
   
   contentGeometryChanged();
@@ -791,14 +791,14 @@
   if (!hasGroups())
     return index(m_ungrouped->rows.indexOf(modelRowPair(sourceIndex)), sourceIndex.column(), QModelIndex());
 
-  foreach (Group* g, m_rowTable) {
+  Q_FOREACH (Group* g, m_rowTable) {
     int row = g->rows.indexOf(modelRowPair(sourceIndex));
     if (row != -1)
       return index(row, sourceIndex.column(), QModelIndex());
   }
 
   // Copied from above
-  foreach (Group* g, m_emptyGroups) {
+  Q_FOREACH (Group* g, m_emptyGroups) {
     int row = g->rows.indexOf(modelRowPair(sourceIndex));
     if (row != -1)
       return index(row, sourceIndex.column(), QModelIndex());
@@ -833,10 +833,10 @@
   if (!hasGroups())
     changeCompletions(m_ungrouped, completion, changeType);
   else {
-    foreach (Group* g, m_rowTable)
+    Q_FOREACH (Group* g, m_rowTable)
       if(g != m_argumentHints)
         changeCompletions(g, completion, changeType);
-    foreach (Group* g, m_emptyGroups)
+    Q_FOREACH (Group* g, m_emptyGroups)
       if(g != m_argumentHints)
         changeCompletions(g, completion, changeType);
 
@@ -853,11 +853,11 @@
     changeCompletions(m_ungrouped, m_currentMatch, Change);
 
   } else {
-    foreach (Group* g, m_rowTable)
+    Q_FOREACH (Group* g, m_rowTable)
       if(g != m_argumentHints)
         changeCompletions(g, m_currentMatch, Change);
 
-    foreach (Group* g, m_emptyGroups)
+    Q_FOREACH (Group* g, m_emptyGroups)
       if(g != m_argumentHints)
         changeCompletions(g, m_currentMatch, Change);
 
@@ -1130,7 +1130,7 @@
     kDebug() << "Model groupless, " << m_ungrouped->rows.count() << " items.";
   else {
     kDebug() << "Model grouped (" << m_rowTable.count() << " groups):";
-    foreach (Group* g, m_rowTable)
+    Q_FOREACH (Group* g, m_rowTable)
       kDebug() << "Group" << g << "count" << g->rows.count();
   }
 }
@@ -1225,9 +1225,9 @@
   /* Debugging - dump column merge list
 
   QString columnMerge;
-  foreach (const QList<int>& list, m_columnMerges) {
+  Q_FOREACH (const QList<int>& list, m_columnMerges) {
     columnMerge += '[';
-    foreach (int column, list) {
+    Q_FOREACH (int column, list) {
       columnMerge += QString::number(column) + " ";
     }
     columnMerge += "] ";
@@ -1236,8 +1236,8 @@
   kDebug() << k_funcinfo << columnMerge;*/
 
   int c = 0;
-  foreach (const QList<int>& list, m_columnMerges) {
-    foreach (int column, list) {
+  Q_FOREACH (const QList<int>& list, m_columnMerges) {
+    Q_FOREACH (int column, list) {
       if (column == sourceColumn)
         return c;
     }
@@ -1539,7 +1539,7 @@
   qStableSort(prefilter.begin(), prefilter.end());
   //int oldRowCount = rows.count();
   rows.clear();
-  foreach (const Item& i, prefilter)
+  Q_FOREACH (const Item& i, prefilter)
     if (i.isVisible())
       rows.append(i.sourceRow());
 
@@ -1565,10 +1565,10 @@
 
 void KateCompletionModel::resort( )
 {
-  foreach (Group* g, m_rowTable)
+  Q_FOREACH (Group* g, m_rowTable)
     g->resort();
 
-  foreach (Group* g, m_emptyGroups)
+  Q_FOREACH (Group* g, m_emptyGroups)
     g->resort();
   
   emit contentGeometryChanged();
@@ -1642,11 +1642,11 @@
 {
   m_ungrouped->refilter();
 
-  foreach (Group* g, m_rowTable)
+  Q_FOREACH (Group* g, m_rowTable)
     if(g != m_argumentHints)
       g->refilter();
 
-  foreach (Group* g, m_emptyGroups)
+  Q_FOREACH (Group* g, m_emptyGroups)
     if(g != m_argumentHints)
       g->refilter();
 
@@ -1658,7 +1658,7 @@
 void KateCompletionModel::Group::refilter( )
 {
   rows.clear();
-  foreach (const Item& i, prefilter)
+  Q_FOREACH (const Item& i, prefilter)
     if (!i.isFiltered())
       rows.append(i.sourceRow());
 }
@@ -1846,7 +1846,7 @@
 
   m_completionModels = models;
 
-  foreach (KTextEditor::CodeCompletionModel* model, models) {
+  Q_FOREACH (KTextEditor::CodeCompletionModel* model, models) {
     connect(model, SIGNAL(rowsInserted(const QModelIndex&, int, int)), SLOT(slotRowsInserted(const QModelIndex&, int, int)));
     connect(model, SIGNAL(rowsRemoved(const QModelIndex&, int, int)), SLOT(slotRowsRemoved(const QModelIndex&, int, int)));
     connect(model, SIGNAL(modelReset()), SLOT(slotModelReset()));
@@ -1887,7 +1887,7 @@
   BestMatchMap matches;
   ///@todo Cache the CodeCompletionModel::BestMatchesCount
   int maxMatches = 50; //We cannot do too many operations here, because they are all executed whenever a character is added. Would be nice if we could split the operations up somewhat using a timer.
-  foreach (Group* g, m_rowTable) {
+  Q_FOREACH (Group* g, m_rowTable) {
     if( g == m_bestMatches )
       continue;
     for( int a = 0; a < g->rows.size(); a++ )
@@ -1954,7 +1954,7 @@
 
 void KateCompletionModel::clearCompletionModels(bool skipReset)
 {
-  foreach (CodeCompletionModel * model, m_completionModels)
+//   Q_FOREACH (CodeCompletionModel * model, m_completionModels)
     model->disconnect(this);
 
   m_completionModels.clear();
Index: kate/completion/katecompletionconfig.cpp
===================================================================
--- kate/completion/katecompletionconfig.cpp	(revisión: 797670)
+++ kate/completion/katecompletionconfig.cpp	(copia de trabajo)
@@ -102,9 +102,9 @@
 
   QList<int> mergedColumns;
   if (!m_model->columnMerges().isEmpty()) {
-    foreach (const QList<int>& list, m_model->columnMerges()) {
+    Q_FOREACH (const QList<int>& list, m_model->columnMerges()) {
       bool first = true;
-      foreach (int column, list) {
+      Q_FOREACH (int column, list) {
         QTreeWidgetItem* item = new QTreeWidgetItem(ui->columnMergeTree, column);
         item->setText(0, KateCompletionModel::columnName(column) + QString(" %1").arg(column));
         item->setCheckState(1, first ? Qt::Unchecked : Qt::Checked);
Index: kate/completion/expandingtree/expandingwidgetmodel.cpp
===================================================================
--- kate/completion/expandingtree/expandingwidgetmodel.cpp	(revisión: 797670)
+++ kate/completion/expandingtree/expandingwidgetmodel.cpp	(copia de trabajo)
@@ -105,7 +105,7 @@
 void ExpandingWidgetModel::clearExpanding() {
     clearMatchQualities();
     m_expandState.clear();
-    foreach( QPointer<QWidget> widget, m_expandingWidgets )
+    Q_FOREACH( QPointer<QWidget> widget, m_expandingWidgets )
       delete widget;
     m_expandingWidgets.clear();
 }
Index: kate/completion/expandingtree/expandingdelegate.cpp
===================================================================
--- kate/completion/expandingtree/expandingdelegate.cpp	(revisión: 797670)
+++ kate/completion/expandingtree/expandingdelegate.cpp	(copia de trabajo)
@@ -61,7 +61,7 @@
   m_cachedHighlights = createHighlighting(index, option);
 
   /*kDebug() << "Highlights for line:";
-  foreach (const QTextLayout::FormatRange& fr, m_cachedHighlights)
+  Q_FOREACH (const QTextLayout::FormatRange& fr, m_cachedHighlights)
     kDebug() << fr.start << " len " << fr.length << " format ";*/
 
   QItemDelegate::paint(painter, option, index);
@@ -150,7 +150,7 @@
   }
 
   /*kDebug() << "Highlights for text [" << text << "] col start " << m_currentColumnStart << ":";
-  foreach (const QTextLayout::FormatRange& fr, additionalFormats)
+  Q_FOREACH (const QTextLayout::FormatRange& fr, additionalFormats)
     kDebug() << fr.start << " len " << fr.length << "foreground" << fr.format.foreground() << "background" << fr.format.background();*/
 
   layout.setAdditionalFormats(additionalFormats);
Index: kate/completion/katecompletionwidget.cpp
===================================================================
--- kate/completion/katecompletionwidget.cpp	(revisión: 797670)
+++ kate/completion/katecompletionwidget.cpp	(copia de trabajo)
@@ -105,7 +105,7 @@
   //We need to do this, because else the focus goes to nirvana without any control when the completion-widget is clicked.
   setFocusPolicy(Qt::ClickFocus);
 
-  foreach (QWidget* childWidget, findChildren<QWidget*>())
+  Q_FOREACH (QWidget* childWidget, findChildren<QWidget*>())
     childWidget->setFocusPolicy(Qt::NoFocus);
 }
 
@@ -114,7 +114,7 @@
 
 void KateCompletionWidget::modelContentChanged() {
   int realItemCount = 0;
-  foreach (KTextEditor::CodeCompletionModel* model, m_presentationModel->completionModels())
+  Q_FOREACH (KTextEditor::CodeCompletionModel* model, m_presentationModel->completionModels())
     realItemCount += model->rowCount();
   kDebug() << "content changed, item count " << realItemCount << "\n";
   if( !m_isSuspended && !isVisible() && realItemCount != 0 ) {
@@ -241,7 +241,7 @@
   if (model)
     model->completionInvoked(view(), word, invocationType);
   else
-    foreach (KTextEditor::CodeCompletionModel* model, m_sourceModels)
+    Q_FOREACH (KTextEditor::CodeCompletionModel* model, m_sourceModels)
       model->completionInvoked(view(), word, invocationType);
 
   kDebug () << "msdofjdsoifdsflkdsjf";
Index: kate/completion/kateargumenthintmodel.cpp
===================================================================
--- kate/completion/kateargumenthintmodel.cpp	(revisión: 797670)
+++ kate/completion/kateargumenthintmodel.cpp	(copia de trabajo)
@@ -52,7 +52,7 @@
   }
 
   for( QMap<int, QList<int> >::const_iterator it = m_depths.begin(); it != m_depths.end(); ++it ) {
-    foreach( int row, *it )
+    Q_FOREACH( int row, *it )
       m_rows.push_front(row);//Insert rows in reversed order
     m_rows.push_front( -it.key() );
   }
Index: kate/view/kateview.cpp
===================================================================
--- kate/view/kateview.cpp	(revisión: 797670)
+++ kate/view/kateview.cpp	(copia de trabajo)
@@ -227,10 +227,10 @@
 
   m_doc->removeView( this );
 
-  foreach (KTextEditor::SmartRange* range, m_externalHighlights)
+  Q_FOREACH (KTextEditor::SmartRange* range, m_externalHighlights)
     removeExternalHighlight(range);
 
-  foreach (KTextEditor::SmartRange* range, m_internalHighlights)
+  Q_FOREACH (KTextEditor::SmartRange* range, m_internalHighlights)
     removeInternalHighlight(range);
 
   delete m_viewInternal;
@@ -575,7 +575,7 @@
   slotSelectionChanged ();
 
   ac->addAssociatedWidget(m_viewInternal);
-  foreach (QAction* action, ac->actions())
+  Q_FOREACH (QAction* action, ac->actions())
     action->setShortcutContext(Qt::WidgetWithChildrenShortcut);
 
   connect (this, SIGNAL(selectionChanged(KTextEditor::View*)), this, SLOT(slotSelectionChanged()));
@@ -821,7 +821,7 @@
     slotLostFocus();
 
   m_editActions->addAssociatedWidget(m_viewInternal);
-  foreach (QAction* action, m_editActions->actions())
+  Q_FOREACH (QAction* action, m_editActions->actions())
     action->setShortcutContext(Qt::WidgetWithChildrenShortcut);
 }
 
@@ -886,14 +886,14 @@
 
 void KateView::slotGotFocus()
 {
-  foreach(QAction *action, editActionCollection()->actions())
+  Q_FOREACH(QAction *action, editActionCollection()->actions())
     action->setEnabled(true);
   emit focusIn ( this );
 }
 
 void KateView::slotLostFocus()
 {
-  foreach(QAction *action, editActionCollection()->actions())
+  Q_FOREACH(QAction *action, editActionCollection()->actions())
     action->setEnabled(false);
   emit focusOut ( this );
 }
Index: kate/view/kateviewinternal.cpp
===================================================================
--- kate/view/kateviewinternal.cpp	(revisión: 797670)
+++ kate/view/kateviewinternal.cpp	(copia de trabajo)
@@ -230,7 +230,7 @@
     //kDebug() << *range;
   }
 
-  foreach (KTextEditor::SmartRange* child, range->childRanges())
+  Q_FOREACH (KTextEditor::SmartRange* child, range->childRanges())
     removeWatcher(child, watcher);
 }
 
@@ -247,7 +247,7 @@
     //kDebug() << *range;
   }
 
-  foreach (KTextEditor::SmartRange* child, range->childRanges())
+  Q_FOREACH (KTextEditor::SmartRange* child, range->childRanges())
     addWatcher(child, watcher);
 }
 
@@ -3218,7 +3218,7 @@
     return;
   }
 
-  foreach (DynamicRangeHL* hl, m_dynamicHighlights) {
+  Q_FOREACH (DynamicRangeHL* hl, m_dynamicHighlights) {
     // FIXME if deletion signal was emitted in proper order, the hasParent hack would not be required
     if (hl->mouseAnimations.contains(range))
       delete hl->mouseAnimations.take(range);
@@ -3307,7 +3307,7 @@
 {
   QMutexLocker lock(m_doc->smartMutex());
 
-  foreach (DynamicRangeHL* hl, m_dynamicHighlights) {
+  Q_FOREACH (DynamicRangeHL* hl, m_dynamicHighlights) {
     QStack<KTextEditor::SmartRange*> enterStack, exitStack;
     KTextEditor::SmartRange* oldRange = mouse ? hl->mouseOver : hl->caretOver;
     KTextEditor::SmartRange* newRange;
@@ -3320,12 +3320,12 @@
       if (newRange && !oldRange)
         enterStack.prepend(newRange);
 
-      foreach (KTextEditor::SmartRange* exitedRange, exitStack) {
+      Q_FOREACH (KTextEditor::SmartRange* exitedRange, exitStack) {
         endDynamic(hl, static_cast<KateSmartRange*>(exitedRange), mouse ? KTextEditor::Attribute::ActivateMouseIn : KTextEditor::Attribute::ActivateCaretIn);
         static_cast<KateSmartRange*>(exitedRange)->feedbackMouseCaretChange(m_view, mouse, false);
       }
 
-      foreach (KTextEditor::SmartRange* enteredRange, enterStack) {
+      Q_FOREACH (KTextEditor::SmartRange* enteredRange, enterStack) {
         static_cast<KateSmartRange*>(enteredRange)->feedbackMouseCaretChange(m_view, mouse, true);
         startDynamic(hl, static_cast<KateSmartRange*>(enteredRange), mouse ? KTextEditor::Attribute::ActivateMouseIn : KTextEditor::Attribute::ActivateCaretIn);
       }
@@ -3536,7 +3536,7 @@
     m_imPreedit->clearAndDeleteChildRanges();
 
     int decorationColumn = 0;
-    foreach (const QInputMethodEvent::Attribute &a, e->attributes()) {
+    Q_FOREACH (const QInputMethodEvent::Attribute &a, e->attributes()) {
       if (a.type == QInputMethodEvent::Cursor) {
         newCursor = m_imPreedit->start() + KTextEditor::Cursor(0, a.start);
         hideCursor = !a.length;
Index: kate/document/katebuffer.cpp
===================================================================
--- kate/document/katebuffer.cpp	(revisión: 797670)
+++ kate/document/katebuffer.cpp	(copia de trabajo)
@@ -764,7 +764,7 @@
   if (l.isEmpty()) return false;
   QString txt=textline->string();
   kDebug(13020)<<"checking empty line regexp";
-  foreach(const QRegExp &re,l) {
+  Q_FOREACH(const QRegExp &re,l) {
     if (re.exactMatch(txt)) return true;
   }
   kDebug(13020)<<"no matches";
Index: kate/document/katedocument.cpp
===================================================================
--- kate/document/katedocument.cpp	(revisión: 797670)
+++ kate/document/katedocument.cpp	(copia de trabajo)
@@ -567,7 +567,7 @@
 
   QList<KTextEditor::Mark> msave;
 
-  foreach (KTextEditor::Mark* mark, m_marks)
+  Q_FOREACH (KTextEditor::Mark* mark, m_marks)
     msave.append(*mark);
 
   editStart ();
@@ -580,7 +580,7 @@
 
   editEnd ();
 
-  foreach (const KTextEditor::Mark& mark, msave)
+  Q_FOREACH (const KTextEditor::Mark& mark, msave)
     setMark (mark.line, mark.type);
 
   return true;
@@ -593,7 +593,7 @@
 
   QList<KTextEditor::Mark> msave;
 
-  foreach (KTextEditor::Mark* mark, m_marks)
+  Q_FOREACH (KTextEditor::Mark* mark, m_marks)
     msave.append(*mark);
 
   editStart ();
@@ -606,7 +606,7 @@
 
   editEnd ();
 
-  foreach (const KTextEditor::Mark& mark, msave)
+  Q_FOREACH (const KTextEditor::Mark& mark, msave)
     setMark (mark.line, mark.type);
 
   return true;
@@ -617,7 +617,7 @@
   if (!isReadWrite())
     return false;
 
-  foreach (KateView *view, m_views) {
+  Q_FOREACH (KateView *view, m_views) {
     view->clear();
     view->tagAll();
     view->update();
@@ -751,7 +751,7 @@
   if (l)
     insertColumnExpanded = l->toVirtualColumn( insertColumn, tabWidth );
 
-  foreach (const QString &text, textLines)
+  Q_FOREACH (const QString &text, textLines)
   {
     int pos = 0;
     for (; pos < text.length(); pos++)
@@ -903,7 +903,7 @@
     return false;
 
   bool success = true;
-  foreach (const QString &string, text)
+  Q_FOREACH (const QString &string, text)
     // FIXME assumes no \n in each string
     success &= editInsertLine (line++, string);
 
@@ -987,7 +987,7 @@
   else
     undoCancel();
 
-  foreach(KateView *view,m_views)
+  Q_FOREACH(KateView *view,m_views)
   {
     view->editStart ();
   }
@@ -1093,7 +1093,7 @@
   smartMutex()->unlock();
 
   // edit end for all views !!!!!!!!!
-  foreach(KateView *view, m_views)
+  Q_FOREACH(KateView *view, m_views)
     view->editEnd (m_buffer->editTagStart(), m_buffer->editTagEnd(), m_buffer->editTagFrom());
 
   if (m_buffer->editChanged())
@@ -3405,7 +3405,7 @@
     if (!m_postLoadFilterChecks.isEmpty())
     {
       LoadSaveFilterCheckPlugins *lscps=loadSaveFilterCheckPlugins();
-      foreach(const QString& checkplugin, m_postLoadFilterChecks)
+      Q_FOREACH(const QString& checkplugin, m_postLoadFilterChecks)
       {
          lscps->postLoadFilter(checkplugin,this);
       }
@@ -3415,7 +3415,7 @@
   //
   // update views
   //
-  foreach (KateView * view, m_views)
+  Q_FOREACH (KateView * view, m_views)
   {
     // This is needed here because inserting the text moves the view's start position (it is a SmartCursor)
     view->setCursorPosition(KTextEditor::Cursor());
@@ -3619,7 +3619,7 @@
   if (!m_preSavePostDialogFilterChecks.isEmpty())
   {
     LoadSaveFilterCheckPlugins *lscps=loadSaveFilterCheckPlugins();
-    foreach(const QString& checkplugin, m_preSavePostDialogFilterChecks)
+    Q_FOREACH(const QString& checkplugin, m_preSavePostDialogFilterChecks)
     {
        if (lscps->preSavePostDialogFilterCheck(checkplugin,this)==false)
          return false;
@@ -3829,7 +3829,7 @@
   m_buffer->setHighlight(0);
 
   // update all our views
-  foreach (KateView * view, m_views )
+  Q_FOREACH (KateView * view, m_views )
   {
     view->clearSelection(); // fix bug #118588
     view->clear();
@@ -3851,7 +3851,7 @@
   {
     KParts::ReadWritePart::setReadWrite (rw);
 
-    foreach( KateView* view, m_views)
+    Q_FOREACH( KateView* view, m_views)
     {
       view->slotUpdate();
       view->slotReadWriteChanged ();
@@ -3864,7 +3864,7 @@
   if (isModified() != m) {
     KParts::ReadWritePart::setModified (m);
 
-    foreach( KateView* view,m_views)
+    Q_FOREACH( KateView* view,m_views)
     {
       view->slotUpdate();
     }
@@ -3893,7 +3893,7 @@
 
 void KateDocument::makeAttribs(bool needInvalidate)
 {
-  foreach(KateView *view,m_views)
+  Q_FOREACH(KateView *view,m_views)
     view->renderer()->updateAttributes ();
 
   if (needInvalidate)
@@ -4941,7 +4941,7 @@
 
 void KateDocument::tagLines(int start, int end)
 {
-  foreach(KateView *view,m_views)
+  Q_FOREACH(KateView *view,m_views)
     view->tagLines (start, end, true);
 }
 
@@ -4954,19 +4954,19 @@
     end.setColumn(sc);
   }
 */
-  foreach (KateView* view, m_views)
+  Q_FOREACH (KateView* view, m_views)
     view->tagLines(start, end, true);
 }
 
 void KateDocument::repaintViews(bool paintOnlyDirty)
 {
-  foreach(KateView *view,m_views)
+  Q_FOREACH(KateView *view,m_views)
     view->repaintText(paintOnlyDirty);
 }
 
 void KateDocument::tagAll()
 {
-  foreach(KateView *view,m_views)
+  Q_FOREACH(KateView *view,m_views)
   {
     view->tagAll();
     view->updateView (true);
@@ -5277,7 +5277,7 @@
     // save cursor positions for all views
     QVector<KTextEditor::Cursor> cursorPositions;
     cursorPositions.reserve(m_views.size());
-    foreach (KateView *v, m_views)
+    Q_FOREACH (KateView *v, m_views)
       cursorPositions.append( v->cursorPosition() );
 
     m_reloading = true;
@@ -5401,7 +5401,7 @@
   emit undoChanged ();
   tagAll();
 
-  foreach (KateView * view,m_views)
+  Q_FOREACH (KateView * view,m_views)
   {
     view->updateDocumentConfig ();
   }
@@ -5432,7 +5432,7 @@
 
   // views!
   KateView *v;
-  foreach (v,m_views)
+  Q_FOREACH (v,m_views)
   {
     v->config()->configStart();
     v->renderer()->config()->configStart();
@@ -5453,7 +5453,7 @@
   if (!onlyViewAndRenderer)
     m_config->configEnd();
 
-  foreach (v,m_views)
+  Q_FOREACH (v,m_views)
   {
     v->config()->configEnd();
     v->renderer()->config()->configEnd();
@@ -5649,7 +5649,7 @@
   bool state;
   int n;
   QColor c;
-  foreach (v,m_views)
+  Q_FOREACH (v,m_views)
   {
     if ( var == "dynamic-word-wrap" && checkBoolValue( val, &state ) )
       v->config()->setDynWordWrap( state );
@@ -5880,7 +5880,7 @@
 
           // views!
           KateView *v;
-          foreach (v,m_views)
+          Q_FOREACH (v,m_views)
           {
             v->config()->configStart();
             v->renderer()->config()->configStart();
@@ -5889,7 +5889,7 @@
           readVariableLine( KateGlobal::self()->modeManager()->fileType(newType).varLine );
 
           m_config->configEnd();
-          foreach (v,m_views)
+          Q_FOREACH (v,m_views)
           {
             v->config()->configEnd();
             v->renderer()->config()->configEnd();
@@ -6060,7 +6060,7 @@
     emit dynamicHighlightAdded(static_cast<KateSmartRange*>(topRange));
   }
 
-  foreach (KateView * view, m_views)
+  Q_FOREACH (KateView * view, m_views)
     view->addExternalHighlight(topRange, supportDynamic);
 }
 
@@ -6069,7 +6069,7 @@
   if (!m_documentHighlights.contains(topRange))
     return;
 
-  foreach (KateView * view, m_views)
+  Q_FOREACH (KateView * view, m_views)
     view->removeExternalHighlight(topRange);
 
   m_documentHighlights.removeAll(topRange);
@@ -6154,7 +6154,7 @@
 void KateDocument::clearSmartInterface( )
 {
   clearDocumentHighlights();
-  foreach (KateView* view, m_views)
+  Q_FOREACH (KateView* view, m_views)
     clearViewHighlights(view);
 
   clearDocumentActions();
Index: kjsembed/kjsembed/slotproxy.cpp
===================================================================
--- kjsembed/kjsembed/slotproxy.cpp	(revisión: 797670)
+++ kjsembed/kjsembed/slotproxy.cpp	(copia de trabajo)
@@ -165,7 +165,7 @@
 #ifdef DEBUG_SLOTPROXY
     qDebug() << "SlotProxy::convertArguments(): obj=" << this << " m_signature=" << m_signature << " offset=" << offset << " params=" << params ;
 #endif
-    foreach( const QByteArray &param, params )
+    Q_FOREACH( const QByteArray &param, params )
     {
 #ifdef DEBUG_SLOTPROXY
         int type = QMetaType::type( param.constData() );
Index: kjsembed/kjsembed/variant_binding.cpp
===================================================================
--- kjsembed/kjsembed/variant_binding.cpp	(revisión: 797670)
+++ kjsembed/kjsembed/variant_binding.cpp	(copia de trabajo)
@@ -360,7 +360,7 @@
         {
             KJS::List items;
             QList<QVariant> lst = value.toList();
-            foreach( const QVariant &item, lst)
+            Q_FOREACH( const QVariant &item, lst)
             {
                 items.append( convertToValue( exec, item ) );
             }
Index: kfile/kfilewidget.cpp
===================================================================
--- kfile/kfilewidget.cpp	(revisión: 797670)
+++ kfile/kfilewidget.cpp	(copia de trabajo)
@@ -265,7 +265,7 @@
     KUrl u;
     KUrlComboBox *pathCombo = d->urlNavigator->editor();
 #ifdef Q_WS_WIN
-    foreach( const QFileInfo &drive,QFSFileEngine::drives() )
+    Q_FOREACH( const QFileInfo &drive,QFSFileEngine::drives() )
     {
         u.setPath( drive.filePath() );
         pathCombo->addDefaultUrl(u,
@@ -616,7 +616,7 @@
             bool multi = (mode() & KFile::Files) != 0;
             QString endQuote = QLatin1String("\" ");
             QString name, files;
-            foreach (const KFileItem &fileItem, items) {
+            Q_FOREACH (const KFileItem &fileItem, items) {
                 name = fileItem.name();
                 if ( multi ) {
                     name.prepend( QLatin1Char( '"' ) );
@@ -650,7 +650,7 @@
             else { // multi (dirs and/or files)
                 d->url = d->ops->url();
                 KUrl::List urlList;
-                foreach (const KFileItem &item, items) {
+                Q_FOREACH (const KFileItem &item, items) {
                     urlList.append(item.url());
                 }
                 d->urlList = urlList;
@@ -1002,7 +1002,7 @@
 
     static const QString &begin = KGlobal::staticQString(" \"");
     QString text;
-    foreach (const KFileItem &fileItem, list) {
+    Q_FOREACH (const KFileItem &fileItem, list) {
         text.append( begin ).append( fileItem.name() ).append( QLatin1Char( '"' ) );
     }
 
Index: kfile/kdiroperator.cpp
===================================================================
--- kfile/kdiroperator.cpp	(revisión: 797670)
+++ kfile/kdiroperator.cpp	(copia de trabajo)
@@ -478,7 +478,7 @@
     const QItemSelection selection = d->proxyModel->mapSelectionToSource(d->itemView->selectionModel()->selection());
 
     const QModelIndexList indexList = selection.indexes();
-    foreach(const QModelIndex &index, indexList) {
+    Q_FOREACH(const QModelIndex &index, indexList) {
         KFileItem item = d->dirModel->itemForIndex(index);
         if (!item.isNull()) {
             itemList.append(item);
@@ -704,7 +704,7 @@
 
     KUrl::List urls;
     QStringList files;
-    foreach (const KFileItem &item, items) {
+    Q_FOREACH (const KFileItem &item, items) {
         const KUrl url = item.url();
         urls.append(url);
         files.append(url.pathOrUrl());
@@ -762,7 +762,7 @@
 
     KUrl::List urls;
     QStringList files;
-    foreach (const KFileItem &item, items) {
+    Q_FOREACH (const KFileItem &item, items) {
         const KUrl url = item.url();
         urls.append(url);
         files.append(url.pathOrUrl());
@@ -1531,7 +1531,7 @@
 
     if (d->completeListDirty) {   // create the list of all possible completions
         const KFileItemList itemList = d->dirLister->items();
-        foreach (const KFileItem &item, itemList) {
+        Q_FOREACH (const KFileItem &item, itemList) {
             d->completion.addItem(item.name());
             if (item.isDir()) {
                 d->dirCompletion.addItem(item.name());
@@ -1656,7 +1656,7 @@
 
 #if (QT_VERSION >= QT_VERSION_CHECK(4, 4, 0))
     d->actionCollection->addAssociatedWidget(parentWidget());
-    foreach (QAction* action, d->actionCollection->actions())
+    Q_FOREACH (QAction* action, d->actionCollection->actions())
       action->setShortcutContext(Qt::WidgetWithChildrenShortcut);
 #endif
 }
Index: kfile/kurlnavigator.cpp
===================================================================
--- kfile/kurlnavigator.cpp	(revisión: 797670)
+++ kfile/kurlnavigator.cpp	(copia de trabajo)
@@ -719,7 +719,7 @@
 
     // check whether buttons must be hidden at all...
     int requiredButtonWidth = 0;
-    foreach (KUrlNavigatorButton* button, m_navButtons) {
+    Q_FOREACH (KUrlNavigatorButton* button, m_navButtons) {
         requiredButtonWidth += button->minimumWidth();
     }
     if (requiredButtonWidth > availableWidth) {
@@ -770,7 +770,7 @@
 
 void KUrlNavigator::Private::deleteButtons()
 {
-    foreach (KUrlNavigatorButton* button, m_navButtons) {
+    Q_FOREACH (KUrlNavigatorButton* button, m_navButtons) {
         button->hide();
         button->deleteLater();
     }
Index: kfile/kfileplacesmodel.cpp
===================================================================
--- kfile/kfileplacesmodel.cpp	(revisión: 797670)
+++ kfile/kfileplacesmodel.cpp	(copia de trabajo)
@@ -260,7 +260,7 @@
 
     const QList<Solid::Device> &deviceList = Solid::Device::listFromQuery(predicate);
 
-    foreach(const Solid::Device &device, deviceList) {
+    Q_FOREACH(const Solid::Device &device, deviceList) {
         availableDevices << device.udi();
     }
 
@@ -399,7 +399,7 @@
     }
 
     // Add bookmarks for the remaining devices, they were previously unknown
-    foreach (const QString &udi, devices) {
+    Q_FOREACH (const QString &udi, devices) {
         bookmark = KFilePlacesItem::createDeviceBookmark(bookmarkManager, udi);
 
         KFilePlacesItem *item = new KFilePlacesItem(bookmarkManager,
@@ -457,7 +457,7 @@
 
     QDataStream stream(&itemData, QIODevice::WriteOnly);
 
-    foreach (const QModelIndex &index, indexes) {
+    Q_FOREACH (const QModelIndex &index, indexes) {
         KUrl itemUrl = url(index);
         if (itemUrl.isValid())
             urls << itemUrl;
@@ -527,7 +527,7 @@
 
         KBookmarkGroup group = d->bookmarkManager->root();
 
-        foreach (const KUrl &url, urls) {
+        Q_FOREACH (const KUrl &url, urls) {
             KMimeType::Ptr mimetype = KMimeType::findByUrl(url);
 
             if (!mimetype->is("inode/directory")) {
Index: kfile/kfiletreeview.cpp
===================================================================
--- kfile/kfiletreeview.cpp	(revisión: 797670)
+++ kfile/kfiletreeview.cpp	(copia de trabajo)
@@ -128,7 +128,7 @@
         return urls;
 
     const QModelIndexList indexes = selectionModel()->selection().indexes();
-    foreach (const QModelIndex &index, indexes) {
+    Q_FOREACH (const QModelIndex &index, indexes) {
         const KUrl url = d->urlForProxyIndex(index);
         if (url.isValid())
             urls.append(url);
Index: kfile/kfileplacesselector.cpp
===================================================================
--- kfile/kfileplacesselector.cpp	(revisión: 797670)
+++ kfile/kfileplacesselector.cpp	(copia de trabajo)
@@ -185,7 +185,7 @@
     if (urlList.isEmpty()) {
         return;
     }
-    foreach(const KUrl &url, urlList) {
+    Q_FOREACH(const KUrl &url, urlList) {
         KMimeType::Ptr mimetype = KMimeType::findByUrl(url);
         if (mimetype->is("inode/directory")) {
             m_placesModel->addPlace(url.fileName(), url);
Index: kfile/kprotocolcombo.cpp
===================================================================
--- kfile/kprotocolcombo.cpp	(revisión: 797670)
+++ kfile/kprotocolcombo.cpp	(copia de trabajo)
@@ -127,7 +127,7 @@
     menu->clear();
 
     int i = 0;
-    foreach (const QString &protocol, m_protocols) {
+    Q_FOREACH (const QString &protocol, m_protocols) {
         QAction *action = menu->addAction(protocol);
         action->setData(i++);
     }
Index: kross/test/main.cpp
===================================================================
--- kross/test/main.cpp	(revisión: 797670)
+++ kross/test/main.cpp	(copia de trabajo)
@@ -163,7 +163,7 @@
     Kross::Manager::self().addObject( testobj1 );
     Kross::Manager::self().addObject( testobj2 );
 
-    foreach(const QString &file, scriptfiles) {
+    Q_FOREACH(const QString &file, scriptfiles) {
         result = runScriptFile(file);
         if(result != ERROR_OK)
             break;
Index: kross/kjs/kjsscript.cpp
===================================================================
--- kross/kjs/kjsscript.cpp	(revisión: 797670)
+++ kross/kjs/kjsscript.cpp	(copia de trabajo)
@@ -252,7 +252,7 @@
         // do it using findChildren since the slotproxy's are handcraftet QObject's and don't
         // implement all of the QObject functionality. Also it seems KjsEmbed does some wired
         // things with the slotproxy's what prevents us from doing it another more nicer way.
-        foreach( QObject* child, obj->children() )
+        Q_FOREACH( QObject* child, obj->children() )
             if( KJSEmbed::SlotProxy* proxy = dynamic_cast< KJSEmbed::SlotProxy* >(child) )
                 delete proxy;
         //delete kjsobj; //don't delete since that will be done by kjs, right?
@@ -301,7 +301,7 @@
         return;
     }
 
-    foreach(QObject* object, d->m_autoconnect) {
+    Q_FOREACH(QObject* object, d->m_autoconnect) {
         const QMetaObject* metaobject = object->metaObject();
         const int count = metaobject->methodCount();
         for(int i = 0; i < count; ++i) {
@@ -397,7 +397,7 @@
     }
 
     KJS::List kjsargs;
-    foreach(const QVariant variant, args) {
+    Q_FOREACH(const QVariant variant, args) {
         if( qVariantCanConvert< QWidget* >(variant) ) {
             if( QWidget* widget = qvariant_cast< QWidget* >(variant) ) {
                 kjsargs.append( KJSEmbed::createQObject(exec, widget, KJSEmbed::ObjectBinding::QObjOwned) );
Index: kross/qts/values_p.h
===================================================================
--- kross/qts/values_p.h	(revisión: 797670)
+++ kross/qts/values_p.h	(copia de trabajo)
@@ -70,7 +70,7 @@
                     return QVariant();
                 }
                 QScriptValueList arguments;
-                foreach(const QVariant &v, args)
+                Q_FOREACH(const QVariant &v, args)
                     arguments << engine()->newVariant(v);
                 QScriptValue result = function.call(m_object, arguments);
                 return result.toVariant();
@@ -278,7 +278,7 @@
 
         // register UI widgets
         QUiLoader loader;
-        foreach(QString widgetname, loader.availableWidgets()) {
+        Q_FOREACH(QString widgetname, loader.availableWidgets()) {
             QScriptValue proto = engine->newObject();
             proto.setProperty("className", QScriptValue(engine, widgetname));
             QScriptValue func = engine->newFunction(createWidget);
Index: kross/qts/main.cpp
===================================================================
--- kross/qts/main.cpp	(revisión: 797670)
+++ kross/qts/main.cpp	(copia de trabajo)
@@ -90,7 +90,7 @@
 
     engine->importExtension("kross").toString();
 
-    foreach(const QString &file, files)
+    Q_FOREACH(const QString &file, files)
         runScriptFile(engine, file);
 
     delete engine;
Index: kross/qts/script.cpp
===================================================================
--- kross/qts/script.cpp	(revisión: 797670)
+++ kross/qts/script.cpp	(copia de trabajo)
@@ -217,7 +217,7 @@
     }
 
     QScriptValueList arguments;
-    foreach(const QVariant &v, args)
+    Q_FOREACH(const QVariant &v, args)
         arguments << d->m_engine->newVariant(v);
     QScriptValue result = function.call(d->m_self, arguments);
     return result.toVariant();
Index: kross/core/manager.cpp
===================================================================
--- kross/core/manager.cpp	(revisión: 797670)
+++ kross/core/manager.cpp	(copia de trabajo)
@@ -76,7 +76,7 @@
         const QString err = QString("Error: %1").arg(lib.errorString());
 
         //TODO move that functionality out of Kross since we like to be Qt-only
-        foreach(const QString &dir, KStandardDirs().resourceDirs("module")) {
+        Q_FOREACH(const QString &dir, KStandardDirs().resourceDirs("module")) {
             lib.setFileName( QFileInfo(dir, libname).filePath() );
             lib.setLoadHints( QLibrary::ExportExternalSymbolsHint );
             if( lib.load() )
@@ -85,7 +85,7 @@
 
         /*
         if( ! lib.isLoaded() ) {
-            foreach(QString path, QCoreApplication::instance()->libraryPaths()) {
+            Q_FOREACH(QString path, QCoreApplication::instance()->libraryPaths()) {
                 lib.setFileName( QFileInfo(path, libname).filePath() );
                 lib.setLoadHints( QLibrary::ExportExternalSymbolsHint );
                 if( lib.load() )
@@ -238,7 +238,7 @@
     for(QHash<QString, InterpreterInfo*>::Iterator it = d->interpreterinfos.begin(); it != d->interpreterinfos.end(); ++it) {
         if( ! it.value() )
             continue;
-        foreach(const QString &wildcard, it.value()->wildcard().split(" ", QString::SkipEmptyParts)) {
+        Q_FOREACH(const QString &wildcard, it.value()->wildcard().split(" ", QString::SkipEmptyParts)) {
             rx.setPattern( wildcard );
             if( rx.exactMatch(file) )
                 return it.value()->interpreterName();
Index: kross/core/actioncollection.cpp
===================================================================
--- kross/core/actioncollection.cpp	(revisión: 797670)
+++ kross/core/actioncollection.cpp	(copia de trabajo)
@@ -310,7 +310,7 @@
     if( ! d->enabled )
         element.setAttribute("enabled", d->enabled);
 
-    foreach(Action* a, actions()) {
+    Q_FOREACH(Action* a, actions()) {
         Q_ASSERT(a);
         #ifdef KROSS_ACTIONCOLLECTION_DEBUG
             krossdebug( QString("  ActionCollection::writeXml action.objectName=\"%1\" action.file=\"%2\"").arg(a->objectName()).arg(a->file()) );
@@ -320,7 +320,7 @@
             element.appendChild(e);
     }
 
-    foreach(const QString &name, d->collectionnames) {
+    Q_FOREACH(const QString &name, d->collectionnames) {
         ActionCollection* c = d->collections[name];
         if( ! c ) continue;
         QDomElement e = c->writeXml();
@@ -336,13 +336,13 @@
     QDomDocument document;
     QDomElement root = document.createElement("KrossScripting");
 
-    foreach(Action* a, actions()) {
+    Q_FOREACH(Action* a, actions()) {
         QDomElement e = a->toDomElement();
         if( ! e.isNull() )
             root.appendChild(e);
     }
 
-    foreach(const QString &name, d->collectionnames) {
+    Q_FOREACH(const QString &name, d->collectionnames) {
         ActionCollection* c = d->collections[name];
         if( ! c ) continue;
         QDomElement e = c->writeXml();
Index: kross/modules/form.cpp
===================================================================
--- kross/modules/form.cpp	(revisión: 797670)
+++ kross/modules/form.cpp	(copia de trabajo)
@@ -425,7 +425,7 @@
 {
     Q_UNUSED(current);
     //kDebug() << "FormDialog::slotCurrentPageChanged current=" << current->name();
-    //foreach(QWidget* widget, current->widget()->findChildren< QWidget* >("")) widget->setFocus();
+    //Q_FOREACH(QWidget* widget, current->widget()->findChildren< QWidget* >("")) widget->setFocus();
 }
 
 /*********************************************************************************
Index: kross/ui/plugin.cpp
===================================================================
--- kross/ui/plugin.cpp	(revisión: 797670)
+++ kross/ui/plugin.cpp	(copia de trabajo)
@@ -78,7 +78,7 @@
         Kross::Manager::self().actionCollection()->readXmlFile(d->userActionsFile);
     }
     else {
-        foreach(QString f, allActionFiles) {
+        Q_FOREACH(QString f, allActionFiles) {
             Kross::Manager::self().actionCollection()->readXmlFile(f);
         }
     }
@@ -94,7 +94,7 @@
 {
     QDomElement menuElement = d->menuFromName(collection->name(), document);
 
-    foreach(Kross::Action* action, collection->actions()) {
+    Q_FOREACH(Kross::Action* action, collection->actions()) {
         // Create and append new Menu element if doesn't exist
         if(menuElement.isNull()) {
             menuElement = document.createElement("Menu");
@@ -130,7 +130,7 @@
         actionCollection()->addAction(action->name(), action);
     }
 
-    foreach(QString collectionname, collection->collections()) {
+    Q_FOREACH(QString collectionname, collection->collections()) {
         Kross::ActionCollection* c = collection->collection(collectionname);
         if(c->isEnabled()) {
             buildDomDocument(document, c);
Index: kross/ui/model.cpp
===================================================================
--- kross/ui/model.cpp	(revisión: 797670)
+++ kross/ui/model.cpp	(copia de trabajo)
@@ -340,7 +340,7 @@
     QByteArray encodedData;
 
     QDataStream stream(&encodedData, QIODevice::WriteOnly);
-    foreach(const QModelIndex &index, indexes) {
+    Q_FOREACH(const QModelIndex &index, indexes) {
         //if( ! index.isValid() ) continue;
         //QString text = data(index, Qt::DisplayRole).toString();
         QString path = fullPath(index);
Index: kross/ui/view.cpp
===================================================================
--- kross/ui/view.cpp	(revisión: 797670)
+++ kross/ui/view.cpp	(copia de trabajo)
@@ -210,7 +210,7 @@
         d->fileedit = new KUrlRequester(w);
         filelabel->setBuddy(d->fileedit);
         QStringList mimetypes;
-        foreach(const QString &interpretername, Manager::self().interpreters()) {
+        Q_FOREACH(const QString &interpretername, Manager::self().interpreters()) {
             InterpreterInfo* info = Manager::self().interpreterInfo(interpretername);
             Q_ASSERT( info );
             mimetypes.append( info->mimeTypes().join(" ").trimmed() );
@@ -413,7 +413,7 @@
     bool startenabled = selectionModel()->hasSelection();
     bool stopenabled = false;
     bool hasselection = selectionModel()->selectedIndexes().count() > 0;
-    foreach(const QModelIndex &index, itemSelection().indexes()) {
+    Q_FOREACH(const QModelIndex &index, itemSelection().indexes()) {
         Action* action = ActionCollectionModel::action(index);
         if( startenabled && ! action )
             startenabled = false;
@@ -452,7 +452,7 @@
     if( ! selectionModel() ) return;
     QAction* stopaction = d->collection->action("stop");
 
-    foreach(const QModelIndex &index, itemSelection().indexes()) {
+    Q_FOREACH(const QModelIndex &index, itemSelection().indexes()) {
         if( ! index.isValid() )
             continue;
         if( stopaction ) {
@@ -471,7 +471,7 @@
 void ActionCollectionView::slotStop()
 {
     if( ! selectionModel() ) return;
-    foreach(const QModelIndex &index, itemSelection().indexes()) {
+    Q_FOREACH(const QModelIndex &index, itemSelection().indexes()) {
         if( ! index.isValid() )
             continue;
         Action* action = ActionCollectionModel::action(index);
@@ -489,7 +489,7 @@
     if( ! selectionModel() ) return;
     Action* action = 0;
     ActionCollection* collection = 0;
-    foreach(const QModelIndex &index, itemSelection().indexes()) {
+    Q_FOREACH(const QModelIndex &index, itemSelection().indexes()) {
         if( ! index.isValid() ) continue;
         if( Action* a = ActionCollectionModel::action(index) )
             action = a;
@@ -530,7 +530,7 @@
 #if 0
     if( ! selectionModel() ) return;
     ActionCollection* collection = 0;
-    foreach(QModelIndex index, itemSelection().indexes()) {
+    Q_FOREACH(QModelIndex index, itemSelection().indexes()) {
         if( ! index.isValid() ) continue;
         if( ActionCollectionModel::action(index) ) {
             //TODO propably add the item right after the current selected one?
Index: phonon/factory.cpp
===================================================================
--- phonon/factory.cpp	(revisión: 797670)
+++ phonon/factory.cpp	(copia de trabajo)
@@ -105,14 +105,14 @@
         // could not load a backend through the platform plugin. Falling back to the default
         // (finding the first loadable backend).
         const QLatin1String suffix("/phonon_backend/");
-        foreach (QString libPath, QCoreApplication::libraryPaths()) {
+        Q_FOREACH (QString libPath, QCoreApplication::libraryPaths()) {
             libPath += suffix;
             const QDir dir(libPath);
             if (!dir.exists()) {
                 pDebug() << Q_FUNC_INFO << dir.absolutePath() << "does not exist";
                 continue;
             }
-            foreach (const QString &pluginName, dir.entryList(QDir::Files)) {
+            Q_FOREACH (const QString &pluginName, dir.entryList(QDir::Files)) {
                 QPluginLoader pluginLoader(libPath + pluginName);
                 if (!pluginLoader.load()) {
                     pDebug() << Q_FUNC_INFO << "  load failed:"
@@ -162,7 +162,7 @@
 
 FactoryPrivate::~FactoryPrivate()
 {
-    foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+    Q_FOREACH (MediaNodePrivate *bp, mediaNodePrivateList) {
         bp->deleteBackendObject();
     }
     if (objects.size() > 0) {
@@ -221,7 +221,7 @@
 void FactoryPrivate::phononBackendChanged()
 {
     if (m_backendObject) {
-        foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+        Q_FOREACH (MediaNodePrivate *bp, mediaNodePrivateList) {
             bp->deleteBackendObject();
         }
         if (objects.size() > 0) {
@@ -231,7 +231,7 @@
                 "backendswitching possible.";
             // in case there were objects deleted give 'em a chance to recreate
             // them now
-            foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+            Q_FOREACH (MediaNodePrivate *bp, mediaNodePrivateList) {
                 bp->createBackendObject();
             }
             return;
@@ -240,7 +240,7 @@
         m_backendObject = 0;
     }
     createBackend();
-    foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+    Q_FOREACH (MediaNodePrivate *bp, mediaNodePrivateList) {
         bp->createBackendObject();
     }
     emit backendChanged();
@@ -300,14 +300,14 @@
 #endif
         const QString suffix(QLatin1String("/phonon_platform/"));
         Q_ASSERT(QCoreApplication::instance());
-        foreach (QString libPath, QCoreApplication::libraryPaths()) {
+        Q_FOREACH (QString libPath, QCoreApplication::libraryPaths()) {
             libPath += suffix;
             const QDir dir(libPath);
             if (!dir.exists()) {
                 pDebug() << Q_FUNC_INFO << dir.absolutePath() << "does not exist";
                 continue;
             }
-            foreach (const QString &pluginName, dir.entryList(QDir::Files)) {
+            Q_FOREACH (const QString &pluginName, dir.entryList(QDir::Files)) {
                 QPluginLoader pluginLoader(libPath + pluginName);
                 if (!pluginLoader.load()) {
                     pDebug() << Q_FUNC_INFO << "  platform plugin load failed:"
Index: phonon/medianode.cpp
===================================================================
--- phonon/medianode.cpp	(revisión: 797670)
+++ phonon/medianode.cpp	(copia de trabajo)
@@ -64,7 +64,7 @@
 
     MediaNodePrivate::~MediaNodePrivate()
     {
-        foreach (MediaNodeDestructionHandler *handler, handlers) {
+        Q_FOREACH (MediaNodeDestructionHandler *handler, handlers) {
             handler->phononObjectDestroyed(this);
         }
         Factory::deregisterFrontendObject(this);
Index: phonon/objectdescriptionmodel.cpp
===================================================================
--- phonon/objectdescriptionmodel.cpp	(revisión: 797670)
+++ phonon/objectdescriptionmodel.cpp	(copia de trabajo)
@@ -321,7 +321,7 @@
         }
     }
     d->model->beginInsertRows(QModelIndex(), row, row + toInsert.size() - 1);
-    foreach (const QExplicitlySharedDataPointer<ObjectDescriptionData> &obj, toInsert) {
+    Q_FOREACH (const QExplicitlySharedDataPointer<ObjectDescriptionData> &obj, toInsert) {
         d->data.insert(row, obj);
     }
     d->model->endInsertRows();
Index: phonon/libkaudiodevicelist/audiodevice.cpp
===================================================================
--- phonon/libkaudiodevicelist/audiodevice.cpp	(revisión: 797670)
+++ phonon/libkaudiodevicelist/audiodevice.cpp	(copia de trabajo)
@@ -44,9 +44,9 @@
     }
 
     QStringList ids = device.deviceIds();
-    foreach (const QString &mixerControlName, mixerControlNames) {
+    Q_FOREACH (const QString &mixerControlName, mixerControlNames) {
         QStringList tmp;
-        foreach (QString id, ids) {
+        Q_FOREACH (QString id, ids) {
             id.replace(QLatin1Char('"'), QLatin1String("\\\""));
             tmp << QString("phonon_softvol:CARD=\"%1\",NAME=\"%2\",SLAVE=\"%3\"")
                 .arg(0)
Index: phonon/libkaudiodevicelist/hardwaredatabase.cpp
===================================================================
--- phonon/libkaudiodevicelist/hardwaredatabase.cpp	(revisión: 797670)
+++ phonon/libkaudiodevicelist/hardwaredatabase.cpp	(copia de trabajo)
@@ -133,7 +133,7 @@
     QStringList allIds = dbFile.groupList();
     QHash<uint, quint32> offsets;
     offsets.reserve(allIds.count());
-    foreach (const QString &uniqueId, allIds) {
+    Q_FOREACH (const QString &uniqueId, allIds) {
         offsets.insertMulti(qHash(uniqueId), cacheFile.pos());
         const KConfigGroup group = dbFile.group(uniqueId);
         name = group.readEntry("name", QString());
@@ -232,7 +232,7 @@
     int pref;
     quint8 isAdvanced;
 
-    foreach (const BucketEntry &entry, bucket) {
+    Q_FOREACH (const BucketEntry &entry, bucket) {
         if (entry.hash == h) {
             m_cacheFile->seek(entry.offset);
             cacheStream >> readUdi;
Index: phonon/libkaudiodevicelist/audiodeviceenumerator.cpp
===================================================================
--- phonon/libkaudiodevicelist/audiodeviceenumerator.cpp	(revisión: 797670)
+++ phonon/libkaudiodevicelist/audiodeviceenumerator.cpp	(copia de trabajo)
@@ -68,7 +68,7 @@
 
     // ask Solid for the available audio hardware
     const QList<Solid::Device> devices = Solid::Device::listFromQuery("AudioInterface.deviceType  & 'AudioInput|AudioOutput'");
-    foreach (const Solid::Device &device, devices) {
+    Q_FOREACH (const Solid::Device &device, devices) {
         AudioDevice dev(device, config);
         if (dev.isValid()) {
             if (dev.isCaptureDevice()) {
@@ -88,7 +88,7 @@
 
     // now look in the config file for disconnected devices
     QStringList groupList = config->groupList();
-    foreach (const QString &groupName, groupList) {
+    Q_FOREACH (const QString &groupName, groupList) {
         if (alreadyFoundCards.contains(groupName) || !groupName.startsWith(QLatin1String("Audio"))) {
             continue;
         }
@@ -223,7 +223,7 @@
         }
 #endif
     }
-    foreach (const DeviceHint &deviceHint, deviceHints) {
+    Q_FOREACH (const DeviceHint &deviceHint, deviceHints) {
         AudioDevice dev(deviceHint.name, deviceHint.description, config);
         if (dev.isPlaybackDevice()) {
             playbackdevicelist << dev;
@@ -278,7 +278,7 @@
     // This looks horrible but allows us to quickly find out which
     // AudioDevices have duplicate names with the scope of an AudioDriver
     QHash<Solid::AudioInterface::AudioDriver, QHash<QString, int> > cardNames;
-    foreach (AudioDevice dev, *devicelist) {
+    Q_FOREACH (AudioDevice dev, *devicelist) {
         cardNames[dev.d->driver][dev.d->cardName]++;
     }
 
@@ -332,22 +332,22 @@
     snd_config_update();
     findVirtualDevices();
 
-    foreach (const AudioDevice &dev, oldCapturedevicelist) {
+    Q_FOREACH (const AudioDevice &dev, oldCapturedevicelist) {
         if (!capturedevicelist.contains(dev)) {
             emit q.deviceUnplugged(dev);
         }
     }
-    foreach (const AudioDevice &dev, oldPlaybackdevicelist) {
+    Q_FOREACH (const AudioDevice &dev, oldPlaybackdevicelist) {
         if (!playbackdevicelist.contains(dev)) {
             emit q.deviceUnplugged(dev);
         }
     }
-    foreach (const AudioDevice &dev, playbackdevicelist) {
+    Q_FOREACH (const AudioDevice &dev, playbackdevicelist) {
         if (!oldPlaybackdevicelist.contains(dev)) {
             emit q.devicePlugged(dev);
         }
     }
-    foreach (const AudioDevice &dev, capturedevicelist) {
+    Q_FOREACH (const AudioDevice &dev, capturedevicelist) {
         if (!oldCapturedevicelist.contains(dev)) {
             emit q.devicePlugged(dev);
         }
@@ -366,7 +366,7 @@
         AudioDevice dev(_device, config);
         if (dev.isValid()) {
             if (dev.isCaptureDevice()) {
-                foreach (const AudioDevice &listedDev, capturedevicelist) {
+                Q_FOREACH (const AudioDevice &listedDev, capturedevicelist) {
                     if (listedDev == dev && !listedDev.isAvailable()) {
                         // listedDev is the same devices as dev but shown as unavailable
                         kDebug(603) << "removing from capturedevicelist: " << listedDev.cardName();
@@ -377,7 +377,7 @@
                 capturedevicelist << dev;
             }
             if (dev.isPlaybackDevice()) {
-                foreach (const AudioDevice &listedDev, playbackdevicelist) {
+                Q_FOREACH (const AudioDevice &listedDev, playbackdevicelist) {
                     if (listedDev == dev && !listedDev.isAvailable()) {
                         // listedDev is the same devices as dev but shown as unavailable
                         kDebug(603) << "removing from playbackdevicelist: " << listedDev.cardName();
@@ -397,7 +397,7 @@
 {
     kDebug(603) << udi;
     AudioDevice dev;
-    foreach (const AudioDevice &listedDev, capturedevicelist) {
+    Q_FOREACH (const AudioDevice &listedDev, capturedevicelist) {
         if (listedDev.d->udi == udi && listedDev.isAvailable()) {
             // listedDev is the same devices as was removed
             kDebug(603) << "removing from capturedevicelist: " << listedDev.cardName();
@@ -406,7 +406,7 @@
             break;
         }
     }
-    foreach (const AudioDevice &listedDev, playbackdevicelist) {
+    Q_FOREACH (const AudioDevice &listedDev, playbackdevicelist) {
         if (listedDev.d->udi == udi && listedDev.isAvailable()) {
             // listedDev is the same devices as was removed
             kDebug(603) << "removing from playbackdevicelist: " << listedDev.cardName();
Index: phonon/mediasource.cpp
===================================================================
--- phonon/mediasource.cpp	(revisión: 797670)
+++ phonon/mediasource.cpp	(copia de trabajo)
@@ -112,7 +112,7 @@
     : d(new MediaSourcePrivate(Link))
 {
     d->linkedSources = mediaList;
-    foreach (MediaSource ms, mediaList) {
+    Q_FOREACH (MediaSource ms, mediaList) {
         Q_ASSERT(ms.type() != Link);
     }
 }
Index: phonon/backendcapabilities.cpp
===================================================================
--- phonon/backendcapabilities.cpp	(revisión: 797670)
+++ phonon/backendcapabilities.cpp	(copia de trabajo)
@@ -101,7 +101,7 @@
     QList<T> ret; \
     if (backendIface) { \
         QList<int> deviceIndexes = backendIface->objectDescriptionIndexes(Phonon::T ## Type); \
-        foreach (int i, deviceIndexes) \
+        Q_FOREACH (int i, deviceIndexes) \
             ret.append(T::fromIndex(i)); \
     } \
     qSort(ret.begin(), ret.end(), sortByInitialPreference<T>); \
@@ -115,7 +115,7 @@
     QList<T ## Description> ret; \
     if (backendIface) { \
         QList<int> deviceIndexes = backendIface->objectDescriptionIndexes(Phonon::T ## Type); \
-        foreach (int i, deviceIndexes) \
+        Q_FOREACH (int i, deviceIndexes) \
             ret.append(T ## Description::fromIndex(i)); \
     } \
     qSort(ret.begin(), ret.end(), sortByInitialPreference<T ## Description>); \
@@ -126,7 +126,7 @@
 {
     QList<AudioOutputDevice> ret;
     const QList<int> deviceIndexes = GlobalConfig().audioOutputDeviceListFor(Phonon::NoCategory);
-    foreach (int i, deviceIndexes) {
+    Q_FOREACH (int i, deviceIndexes) {
         ret.append(AudioOutputDevice::fromIndex(i));
     }
     return ret;
@@ -146,7 +146,7 @@
     QList<EffectDescription> ret;
     if (backendIface) {
         QList<int> deviceIndexes = backendIface->objectDescriptionIndexes(Phonon::EffectType);
-        foreach (int i, deviceIndexes) {
+        Q_FOREACH (int i, deviceIndexes) {
             ret.append(EffectDescription::fromIndex(i));
         }
     }
Index: phonon/mediaobject.cpp
===================================================================
--- phonon/mediaobject.cpp	(revisión: 797670)
+++ phonon/mediaobject.cpp	(copia de trabajo)
@@ -287,14 +287,14 @@
 
 void MediaObject::enqueue(const QList<MediaSource> &sources)
 {
-    foreach (const MediaSource &m, sources) {
+    Q_FOREACH (const MediaSource &m, sources) {
         enqueue(m);
     }
 }
 
 void MediaObject::enqueue(const QList<QUrl> &urls)
 {
-    foreach (const QUrl &url, urls) {
+    Q_FOREACH (const QUrl &url, urls) {
         enqueue(url);
     }
 }
@@ -481,7 +481,7 @@
         state = backendState;
     }
 
-    foreach (FrontendInterfacePrivate *f, interfaceList) {
+    Q_FOREACH (FrontendInterfacePrivate *f, interfaceList) {
         f->_backendObjectChanged();
     }
 
Index: phonon/audiooutput.cpp
===================================================================
--- phonon/audiooutput.cpp	(revisión: 797670)
+++ phonon/audiooutput.cpp	(copia de trabajo)
@@ -227,7 +227,7 @@
         }
         if (outputDeviceIndex == deviceList.takeFirst()) { // removing the first device so that
             // if it's the same device as the one we tried we only try all the following
-            foreach (int devIndex, deviceList) {
+            Q_FOREACH (int devIndex, deviceList) {
                 if (pINTERFACE_CALL(setOutputDevice(devIndex))) {
                     handleAutomaticDeviceChange(devIndex, AudioOutputPrivate::FallbackChange);
                     break; // found one that works
@@ -262,7 +262,7 @@
     // outputDeviceIndex identifies a failing device
     // fall back in the preference list of output devices
     QList<int> deviceList = GlobalConfig().audioOutputDeviceListFor(category);
-    foreach (int devIndex, deviceList) {
+    Q_FOREACH (int devIndex, deviceList) {
         // if it's the same device as the one that failed, ignore it
         if (outputDeviceIndex != devIndex) {
             if (pINTERFACE_CALL(setOutputDevice(devIndex))) {
@@ -279,7 +279,7 @@
     // let's see if there's a usable device higher in the preference list
     QList<int> deviceList = GlobalConfig().audioOutputDeviceListFor(category);
     DeviceChangeType changeType = HigherPreferenceChange;
-    foreach (int devIndex, deviceList) {
+    Q_FOREACH (int devIndex, deviceList) {
         pDebug() << devIndex;
         if (outputDeviceIndex == devIndex) {
             AudioOutputDevice info = AudioOutputDevice::fromIndex(devIndex);
Index: phonon/platform_kde/kdepluginfactory.cpp
===================================================================
--- phonon/platform_kde/kdepluginfactory.cpp	(revisión: 797670)
+++ phonon/platform_kde/kdepluginfactory.cpp	(copia de trabajo)
@@ -137,10 +137,10 @@
     if (0 == backend) {
         const QLatin1String suffix("/phonon_backend/");
         const QStringList libFilter(newService->library() + QLatin1String(".*"));
-        foreach (QString libPath, QCoreApplication::libraryPaths()) {
+        Q_FOREACH (QString libPath, QCoreApplication::libraryPaths()) {
             libPath += suffix;
             const QDir dir(libPath);
-            foreach (const QString &pluginName, dir.entryList(libFilter, QDir::Files)) {
+            Q_FOREACH (const QString &pluginName, dir.entryList(libFilter, QDir::Files)) {
                 QPluginLoader pluginLoader(libPath + pluginName);
                 backend = pluginLoader.instance();
                 if (backend) {
Index: phonon/tests/backendcapabilitiestest.cpp
===================================================================
--- phonon/tests/backendcapabilitiestest.cpp	(revisión: 797670)
+++ phonon/tests/backendcapabilitiestest.cpp	(copia de trabajo)
@@ -60,7 +60,7 @@
     QStringList mimeTypes = BackendCapabilities::availableMimeTypes();
     QVERIFY(Factory::backend(false) != 0); // the backend should have been created at this point
     QVERIFY(mimeTypes.size() > 0); // a backend that doesn't know any mimetypes is useless
-    foreach (const QString &mimeType, mimeTypes) {
+    Q_FOREACH (const QString &mimeType, mimeTypes) {
         qDebug("%s", qPrintable(mimeType));
         QVERIFY(BackendCapabilities::isMimeTypeAvailable(mimeType));
     }
Index: phonon/tests/guitest/pathitem.cpp
===================================================================
--- phonon/tests/guitest/pathitem.cpp	(revisión: 797670)
+++ phonon/tests/guitest/pathitem.cpp	(copia de trabajo)
@@ -71,7 +71,7 @@
 {
     const qreal divisor = QGraphicsItem::children().count() + 1;
     int positionOnLine = 0;
-    foreach (QGraphicsItem *item, QGraphicsItem::children()) {
+    Q_FOREACH (QGraphicsItem *item, QGraphicsItem::children()) {
         item->setPos(QGraphicsPathItem::path().pointAtPercent(++positionOnLine / divisor) - item->boundingRect().center());
     }
 }
Index: phonon/tests/guitest/mygraphicsscene.cpp
===================================================================
--- phonon/tests/guitest/mygraphicsscene.cpp	(revisión: 797670)
+++ phonon/tests/guitest/mygraphicsscene.cpp	(copia de trabajo)
@@ -81,7 +81,7 @@
             //QMenu *effectMenu = popupMenu.addMenu("add Effect");
             QList<EffectDescription> effectList = Phonon::BackendCapabilities::availableAudioEffects();
             QHash<QAction *, EffectDescription> actionHash;
-            foreach (const EffectDescription &d, effectList) {
+            Q_FOREACH (const EffectDescription &d, effectList) {
                 QAction *subAction = popupMenu.addAction("add " + d.name());
                 actionHash.insert(subAction, d);
             }
Index: phonon/tests/guitest/main.cpp
===================================================================
--- phonon/tests/guitest/main.cpp	(revisión: 797670)
+++ phonon/tests/guitest/main.cpp	(copia de trabajo)
@@ -166,7 +166,7 @@
     QList<EffectDescription> effectList = Phonon::BackendCapabilities::availableAudioEffects();
     QSignalMapper *mapper = new QSignalMapper(menu);
     connect(mapper, SIGNAL(mapped(int)), SLOT(addEffect(int)));
-    foreach (const EffectDescription &d, effectList) {
+    Q_FOREACH (const EffectDescription &d, effectList) {
         QAction *subAction = menu->addAction(d.name(), mapper, SLOT(map()));
         mapper->setMapping(subAction, d.index());
     }
Index: phonon/tests/guitest/mediaobjectitem.cpp
===================================================================
--- phonon/tests/guitest/mediaobjectitem.cpp	(revisión: 797670)
+++ phonon/tests/guitest/mediaobjectitem.cpp	(copia de trabajo)
@@ -200,7 +200,7 @@
     QString metaData;
     const QMultiMap<QString, QString> map = m_media.metaData();
     const QStringList keys = map.keys();
-    foreach (const QString &key, keys) {
+    Q_FOREACH (const QString &key, keys) {
         metaData += key + QLatin1String(": ") + QStringList(map.values(key)).join(QLatin1String("\n")) + "\n";
     }
     m_metaDataLabel->setText(metaData.left(metaData.length() - 1));
Index: phonon/tests/audiodevicelisttest.cpp
===================================================================
--- phonon/tests/audiodevicelisttest.cpp	(revisión: 797670)
+++ phonon/tests/audiodevicelisttest.cpp	(copia de trabajo)
@@ -42,9 +42,9 @@
 void SimpleTest::listDevices()
 {
     QList<AudioDevice> deviceList = AudioDeviceEnumerator::availablePlaybackDevices();
-    foreach (const AudioDevice &dev, deviceList) {
+    Q_FOREACH (const AudioDevice &dev, deviceList) {
         qDebug() << dev.cardName() << dev.deviceIds() << dev.iconName() << dev.isAvailable();
-        foreach (const QString &id, dev.deviceIds()) {
+        Q_FOREACH (const QString &id, dev.deviceIds()) {
             QVERIFY(dev.deviceIds().count(id) == 1);
         }
     }
Index: phonon/tests/lockfreequeuetest2.cpp
===================================================================
--- phonon/tests/lockfreequeuetest2.cpp	(revisión: 797670)
+++ phonon/tests/lockfreequeuetest2.cpp	(copia de trabajo)
@@ -125,7 +125,7 @@
     QTime timeout;
     QVector<int> data;
     data.reserve(100);
-    forever {
+    Q_FOREVER {
         if (!empty && m_toProcess->isEmpty()) {
             empty = true;
             qDebug() << "nothing more to process";
@@ -147,7 +147,7 @@
         while (!m_doneProcessing->isEmpty()) {
             timeout = QTime();
             m_doneProcessing->dequeue(data);
-            foreach (int x, data) {
+            Q_FOREACH (int x, data) {
                 QVERIFY(x >= 0);
                 QVERIFY(x < NUMBER_OF_IDS);
                 QCOMPARE(received[x], (uchar)false);
@@ -168,10 +168,10 @@
     //qDebug() << "maximal enqueue time:" << MAX_ENQUEUE_TIME;
     //qDebug() << "maximal dequeue time:" << MAX_DEQUEUE_TIME;
     LockFreeQueueBase::KeepNodePoolMemoryManagement::clear();
-    foreach (ProcessThread *p, m_processors) {
+    Q_FOREACH (ProcessThread *p, m_processors) {
         p->quit();
     }
-    foreach (ProcessThread *p, m_processors) {
+    Q_FOREACH (ProcessThread *p, m_processors) {
         p->wait();
         delete p;
     }
Index: phonon/tests/fakebackend/mediaobject.cpp
===================================================================
--- phonon/tests/fakebackend/mediaobject.cpp	(revisión: 797670)
+++ phonon/tests/fakebackend/mediaobject.cpp	(copia de trabajo)
@@ -369,11 +369,11 @@
         for (int i = 0; i < bufferCount; ++i)
         {
             fillBuffer(&buffer);
-            foreach (AudioNode *an, m_audioNodes) {
+            Q_FOREACH (AudioNode *an, m_audioNodes) {
                 an->processBuffer(buffer);
             }
             fillFrameData(&frame);
-            foreach (VideoNode *vn, m_videoNodes) {
+            Q_FOREACH (VideoNode *vn, m_videoNodes) {
                 vn->processFrame(frame);
             }
         }
Index: phonon/tests/fakebackend/backend.cpp
===================================================================
--- phonon/tests/fakebackend/backend.cpp	(revisión: 797670)
+++ phonon/tests/fakebackend/backend.cpp	(copia de trabajo)
@@ -259,7 +259,7 @@
 bool Backend::startConnectionChange(QSet<QObject *> objects)
 {
     bool success = true;
-    foreach (QObject *o, objects) {
+    Q_FOREACH (QObject *o, objects) {
         MediaObject *mo = qobject_cast<MediaObject *>(o);
         if (mo) {
             success &= mo->wait();
@@ -315,7 +315,7 @@
 bool Backend::endConnectionChange(QSet<QObject *> objects)
 {
     bool success = true;
-    foreach (QObject *o, objects) {
+    Q_FOREACH (QObject *o, objects) {
         MediaObject *mo = qobject_cast<MediaObject *>(o);
         if (mo) {
             success &= mo->done();
@@ -326,7 +326,7 @@
 
 void Backend::freeSoundcardDevices()
 {
-    foreach (QPointer<AudioOutput> ao, m_audioOutputs)
+    Q_FOREACH (QPointer<AudioOutput> ao, m_audioOutputs)
         if (ao)
             ao->closeDevice();
 }
Index: phonon/tests/lockfreequeuetest.cpp
===================================================================
--- phonon/tests/lockfreequeuetest.cpp	(revisión: 797670)
+++ phonon/tests/lockfreequeuetest.cpp	(copia de trabajo)
@@ -86,7 +86,7 @@
                 m_noEventSent = true;
                 QVector<Command> commands(0xff);
                 m_receiveQueue->dequeue(commands);
-                foreach (const Command &c, commands) {
+                Q_FOREACH (const Command &c, commands) {
                     switch (c.command) {
                     case SetStreamSize:
                         QCOMPARE(c.data.type(), QVariant::Int);
@@ -213,7 +213,7 @@
                 m_noEventSent = true;
                 QVector<Command> commands(0xff);
                 m_receiveQueue->dequeue(commands);
-                foreach (const Command &c, commands) {
+                Q_FOREACH (const Command &c, commands) {
                     switch (c.command) {
                     case NeedData:
                         QCOMPARE(c.data.type(), QVariant::Int);
Index: phonon/kcm/outputdevicechoice.cpp
===================================================================
--- phonon/kcm/outputdevicechoice.cpp	(revisión: 797670)
+++ phonon/kcm/outputdevicechoice.cpp	(copia de trabajo)
@@ -296,7 +296,7 @@
 {
     const QList<Phonon::AudioOutputDevice> list = availableAudioOutputDevices();
     QHash<int, Phonon::AudioOutputDevice> hash;
-    foreach (const Phonon::AudioOutputDevice &dev, list) {
+    Q_FOREACH (const Phonon::AudioOutputDevice &dev, list) {
         hash.insert(dev.index(), dev);
     }
     for (int i = -1; i <= Phonon::LastCategory; ++i) {
@@ -307,14 +307,14 @@
         QList<Phonon::AudioOutputDevice> orderedList;
         if (model->rowCount() > 0) {
             QList<int> order = model->tupleIndexOrder();
-            foreach (int idx, order) {
+            Q_FOREACH (int idx, order) {
                 if (hashCopy.contains(idx)) {
                     orderedList << hashCopy.take(idx);
                 }
             }
             if (hashCopy.size() > 1) {
                 // keep the order of the original list
-                foreach (const Phonon::AudioOutputDevice &dev, list) {
+                Q_FOREACH (const Phonon::AudioOutputDevice &dev, list) {
                     if (hashCopy.contains(dev.index())) {
                         orderedList << hashCopy.take(dev.index());
                     }
@@ -337,7 +337,7 @@
             showCheckBox->isChecked()
             ? Phonon::GlobalConfig::ShowAdvancedDevices
             : Phonon::GlobalConfig::HideAdvancedDevices);
-    foreach (int i, deviceIndexes) {
+    Q_FOREACH (int i, deviceIndexes) {
         ret.append(Phonon::AudioOutputDevice::fromIndex(i));
     }
     return ret;
@@ -356,7 +356,7 @@
     m_outputModel[Phonon::NoCategory]->setModelData(list);
 
     QHash<int, Phonon::AudioOutputDevice> hash;
-    foreach (const Phonon::AudioOutputDevice &dev, list) {
+    Q_FOREACH (const Phonon::AudioOutputDevice &dev, list) {
         hash.insert(dev.index(), dev);
     }
     for (int i = 0; i <= Phonon::LastCategory; ++i) {
@@ -368,14 +368,14 @@
         QHash<int, Phonon::AudioOutputDevice> hashCopy(hash);
         const QList<int> order = outputDeviceGroup.value(configKey, QList<int>());
         QList<Phonon::AudioOutputDevice> orderedList;
-        foreach (int idx, order) {
+        Q_FOREACH (int idx, order) {
             if (hashCopy.contains(idx)) {
                 orderedList << hashCopy.take(idx);
             }
         }
         if (hashCopy.size() > 1) {
             // keep the order of the original list
-            foreach (const Phonon::AudioOutputDevice &dev, list) {
+            Q_FOREACH (const Phonon::AudioOutputDevice &dev, list) {
                 if (hashCopy.contains(dev.index())) {
                     orderedList << hashCopy.take(dev.index());
                 }
@@ -390,7 +390,7 @@
     QList<Phonon::AudioCaptureDevice> list2 = Phonon::BackendCapabilities::availableAudioCaptureDevices();
     QList<int> order = captureDeviceGroup.value(QLatin1String("DeviceOrder"), QList<int>());
     QList<Phonon::AudioCaptureDevice> orderedList;
-    foreach (int idx, order) {
+    Q_FOREACH (int idx, order) {
         for (int i = 0; i < list2.size(); ++i) {
             if (list2.at(i).index() == idx) {
                 orderedList << list2.takeAt(i);
@@ -398,7 +398,7 @@
             }
         }
     }
-    foreach (const Phonon::AudioCaptureDevice &dev, list2) {
+    Q_FOREACH (const Phonon::AudioCaptureDevice &dev, list2) {
         orderedList << dev;
     }
     m_captureModel.setModelData(orderedList);
@@ -482,12 +482,12 @@
     if (playbackModel && idx.isValid()) {
         const Phonon::AudioOutputDevice deviceToRemove = playbackModel->modelData(idx);
         const QList<Phonon::AudioDevice> deviceList = Phonon::AudioDeviceEnumerator::availablePlaybackDevices();
-        foreach (Phonon::AudioDevice dev, deviceList) {
+        Q_FOREACH (Phonon::AudioDevice dev, deviceList) {
             if (dev.index() == deviceToRemove.index()) {
                 // remove from persistent store
                 if (dev.ceaseToExist()) {
                     // remove from all models, idx.row() is only correct for the current model
-                    foreach (Phonon::AudioOutputDeviceModel *model, m_outputModel) {
+                    Q_FOREACH (Phonon::AudioOutputDeviceModel *model, m_outputModel) {
                         QList<Phonon::AudioOutputDevice> data = model->modelData();
                         for (int row = 0; row < data.size(); ++row) {
                             if (data[row] == deviceToRemove) {
@@ -507,7 +507,7 @@
         if (captureModel && idx.isValid()) {
             Phonon::AudioCaptureDevice deviceToRemove = captureModel->modelData(idx);
             QList<Phonon::AudioDevice> deviceList = Phonon::AudioDeviceEnumerator::availableCaptureDevices();
-            foreach (Phonon::AudioDevice dev, deviceList) {
+            Q_FOREACH (Phonon::AudioDevice dev, deviceList) {
                 if (dev.index() == deviceToRemove.index()) {
                     // remove from persistent store
                     if (dev.ceaseToExist()) {
@@ -589,21 +589,21 @@
     m_outputModel[Phonon::NoCategory]->setModelData(list);
 
     QHash<int, Phonon::AudioOutputDevice> hash;
-    foreach (const Phonon::AudioOutputDevice &dev, list) {
+    Q_FOREACH (const Phonon::AudioOutputDevice &dev, list) {
         hash.insert(dev.index(), dev);
     }
     for (int i = 0; i <= Phonon::LastCategory; ++i) {
         QHash<int, Phonon::AudioOutputDevice> hashCopy(hash);
         const QList<int> order = m_outputModel[i]->tupleIndexOrder();
         QList<Phonon::AudioOutputDevice> orderedList;
-        foreach (int idx, order) {
+        Q_FOREACH (int idx, order) {
             if (hashCopy.contains(idx)) {
                 orderedList << hashCopy.take(idx);
             }
         }
         if (hashCopy.size() > 1) {
             // keep the order of the original list
-            foreach (const Phonon::AudioOutputDevice &dev, list) {
+            Q_FOREACH (const Phonon::AudioOutputDevice &dev, list) {
                 if (hashCopy.contains(dev.index())) {
                     orderedList << hashCopy.take(dev.index());
                 }
Index: phonon/kcm/backendselection.cpp
===================================================================
--- phonon/kcm/backendselection.cpp	(revisión: 797670)
+++ phonon/kcm/backendselection.cpp	(copia de trabajo)
@@ -56,7 +56,7 @@
             "Type == 'Service' and [X-KDE-PhononBackendInfo-InterfaceVersion] == 1");
     // the offers are already sorted for preference
     loadServices(offers);
-    foreach (KCModuleProxy *proxy, m_kcms) {
+    Q_FOREACH (KCModuleProxy *proxy, m_kcms) {
         if (proxy) {
             proxy->load();
         }
@@ -105,7 +105,7 @@
 void BackendSelection::save()
 {
     // save embedded KCMs
-    foreach (KCModuleProxy *proxy, m_kcms) {
+    Q_FOREACH (KCModuleProxy *proxy, m_kcms) {
         if (proxy) {
             proxy->save();
         }
@@ -151,7 +151,7 @@
 
 void BackendSelection::defaults()
 {
-    foreach (KCModuleProxy *proxy, m_kcms) {
+    Q_FOREACH (KCModuleProxy *proxy, m_kcms) {
         if (proxy) {
             proxy->defaults();
         }
@@ -163,7 +163,7 @@
 void BackendSelection::selectionChanged()
 {
     KService::Ptr service;
-    foreach (QListWidgetItem *item, m_select->selectedItems()) {
+    Q_FOREACH (QListWidgetItem *item, m_select->selectedItems()) {
         service = m_services[item->text()];
         m_up->setEnabled(m_select->row(item) > 0);
         m_down->setEnabled(m_select->row(item) < m_select->count() - 1);
@@ -192,7 +192,7 @@
 void BackendSelection::up()
 {
     QList<QListWidgetItem *> selectedList = m_select->selectedItems();
-    foreach (QListWidgetItem *selected, selectedList)
+    Q_FOREACH (QListWidgetItem *selected, selectedList)
     {
         int row = m_select->row(selected);
         if (row > 0)
@@ -208,7 +208,7 @@
 void BackendSelection::down()
 {
     QList<QListWidgetItem *> selectedList = m_select->selectedItems();
-    foreach (QListWidgetItem *selected, selectedList)
+    Q_FOREACH (QListWidgetItem *selected, selectedList)
     {
         int row = m_select->row(selected);
         if (row + 1 < m_select->count())
Index: phonon/effect.cpp
===================================================================
--- phonon/effect.cpp	(revisión: 797670)
+++ phonon/effect.cpp	(copia de trabajo)
@@ -102,7 +102,7 @@
 {
     if (m_backendObject) {
         const QList<EffectParameter> parameters = pINTERFACE_CALL(parameters());
-        foreach (const EffectParameter &p, parameters) {
+        Q_FOREACH (const EffectParameter &p, parameters) {
             parameterValues[p] = pINTERFACE_CALL(parameterValue(p));
         }
     }
@@ -115,7 +115,7 @@
 
     // set up attributes
     const QList<EffectParameter> parameters = pINTERFACE_CALL(parameters());
-    foreach (const EffectParameter &p, parameters) {
+    Q_FOREACH (const EffectParameter &p, parameters) {
         pINTERFACE_CALL(setParameterValue(p, parameterValues[p]));
     }
 }
Index: phonon/path.cpp
===================================================================
--- phonon/path.cpp	(revisión: 797670)
+++ phonon/path.cpp	(copia de trabajo)
@@ -53,7 +53,7 @@
 
 PathPrivate::~PathPrivate()
 {
-    foreach (Effect *e, effects) {
+    Q_FOREACH (Effect *e, effects) {
         e->k_ptr->removeDestructionHandler(this);
     }
     delete effectsParent;
@@ -211,7 +211,7 @@
     QObjectList list;
     if (d->sourceNode)
         list << d->sourceNode->k_ptr->backendObject();
-    foreach(Effect *e, d->effects) {
+    Q_FOREACH(Effect *e, d->effects) {
         list << e->k_ptr->backendObject();
     }
     if (d->sinkNode)
@@ -235,7 +235,7 @@
         }
         d->sourceNode = 0;
 
-        foreach(Effect *e, d->effects) {
+        Q_FOREACH(Effect *e, d->effects) {
             e->k_ptr->removeDestructionHandler(d.data());
         }
         d->effects.clear();
@@ -254,11 +254,11 @@
 bool PathPrivate::executeTransaction( const QList<QObjectPair> &disconnections, const QList<QObjectPair> &connections)
 {
     QSet<QObject*> nodesForTransaction;
-    foreach(const QObjectPair &pair, disconnections) {
+    Q_FOREACH(const QObjectPair &pair, disconnections) {
         nodesForTransaction << pair.first;
         nodesForTransaction << pair.second;
     }
-    foreach(const QObjectPair &pair, connections) {
+    Q_FOREACH(const QObjectPair &pair, connections) {
         nodesForTransaction << pair.first;
         nodesForTransaction << pair.second;
     }
@@ -300,7 +300,7 @@
             }
 
             //and now let's reconnect the nodes that were disconnected: rollback
-            foreach(const QObjectPair &pair, disconnections) {
+            Q_FOREACH(const QObjectPair &pair, disconnections) {
                 bool success = backend->connectNodes(pair.first, pair.second);
                 Q_ASSERT(success); //a failure here means it is impossible to reestablish the connection
                 Q_UNUSED(success);
@@ -370,7 +370,7 @@
         sourceNode = 0;
         sinkNode = 0;
     } else {
-        foreach (Effect *e, effects) {
+        Q_FOREACH (Effect *e, effects) {
             if (e->k_ptr == mediaNodePrivate) {
                 removeEffect(e);
             }
Index: phonon/effectwidget.cpp
===================================================================
--- phonon/effectwidget.cpp	(revisión: 797670)
+++ phonon/effectwidget.cpp	(copia de trabajo)
@@ -76,7 +76,7 @@
     Q_Q(EffectWidget);
     QVBoxLayout *mainLayout = new QVBoxLayout(q);
     mainLayout->setMargin(0);
-    foreach (const EffectParameter &para, effect->parameters()) {
+    Q_FOREACH (const EffectParameter &para, effect->parameters()) {
         QVariant value = effect->parameterValue(para);
         QHBoxLayout *pLayout = new QHBoxLayout;
         mainLayout->addLayout(pLayout);
@@ -93,13 +93,13 @@
             QComboBox *cb = new QComboBox(q);
             control = cb;
             if (value.type() == QVariant::Int) {
-                foreach (const QVariant &item, para.possibleValues()) {
+                Q_FOREACH (const QVariant &item, para.possibleValues()) {
                     cb->addItem(item.toString());
                 }
                 cb->setCurrentIndex(value.toInt());
                 QObject::connect(cb, SIGNAL(currentIndexChanged(int)), q, SLOT(_k_setIntParameter(int)));
             } else {
-                foreach (const QVariant &item, para.possibleValues()) {
+                Q_FOREACH (const QVariant &item, para.possibleValues()) {
                     cb->addItem(item.toString());
                     if (item == value) {
                         cb->setCurrentIndex(cb->count() - 1);
Index: phonon/experimental/mediasource.cpp
===================================================================
--- phonon/experimental/mediasource.cpp	(revisión: 797670)
+++ phonon/experimental/mediasource.cpp	(copia de trabajo)
@@ -61,7 +61,7 @@
     : Phonon::MediaSource(*new MediaSourcePrivate(Link))
 {
     d->linkedSources = mediaList;
-    foreach (const Phonon::MediaSource &ms, mediaList) {
+    Q_FOREACH (const Phonon::MediaSource &ms, mediaList) {
         Q_ASSERT(static_cast<MediaSource::Type>(ms.type()) != Link);
     }
 }
Index: phonon/experimental/backendcapabilities.cpp
===================================================================
--- phonon/experimental/backendcapabilities.cpp	(revisión: 797670)
+++ phonon/experimental/backendcapabilities.cpp	(copia de trabajo)
@@ -29,7 +29,7 @@
 {
     QList<VideoCaptureDevice> ret;
     const QList<int> deviceIndexes = GlobalConfig().videoCaptureDeviceListFor(Phonon::NoCategory);
-    foreach (int i, deviceIndexes) {
+    Q_FOREACH (int i, deviceIndexes) {
         ret.append(VideoCaptureDevice::fromIndex(i));
     }
     return ret;
Index: phonon/DESIGN/Phonon-Graph.cpp
===================================================================
--- phonon/DESIGN/Phonon-Graph.cpp	(revisión: 797670)
+++ phonon/DESIGN/Phonon-Graph.cpp	(copia de trabajo)
@@ -153,7 +153,7 @@
     //example
      MediaObject o;
      o.enqueue( QList<QUrl>() <<...
-     foreach(const MediaSource &src, o.queue()) {
+     Q_FOREACH(const MediaSource &src, o.queue()) {
         // 'attach' would be better but what to do in case there is no port specified
         media.selectSubStream( src.substream(Phonon::Audio)[1] ); 
      }
Index: kdoctools/genshortcutents.cpp
===================================================================
--- kdoctools/genshortcutents.cpp	(revisión: 797670)
+++ kdoctools/genshortcutents.cpp	(copia de trabajo)
@@ -233,7 +233,7 @@
 		markup += keyAsMarkup( keys.first() );
 	} else {
 		markup += "<keycombo action=\"Simul\">";
-		foreach( const QString &key, keys ) {
+		Q_FOREACH( const QString &key, keys ) {
 			if ( key.startsWith( "XF86" ) ) {
 				continue;
 			}
Index: kparts/partmanager.cpp
===================================================================
--- kparts/partmanager.cpp	(revisión: 797670)
+++ kparts/partmanager.cpp	(copia de trabajo)
@@ -115,13 +115,13 @@
 
 PartManager::~PartManager()
 {
-    foreach( const QWidget* w, d->m_managedTopLevelWidgets )
+    Q_FOREACH( const QWidget* w, d->m_managedTopLevelWidgets )
     {
         disconnect( w, SIGNAL( destroyed() ),
                     this, SLOT( slotManagedTopLevelWidgetDestroyed() ) );
     }
 
-    foreach( Part* it, d->m_parts )
+    Q_FOREACH( Part* it, d->m_parts )
     {
         it->setManager( 0 );
     }
Index: kparts/browserextension.cpp
===================================================================
--- kparts/browserextension.cpp	(revisión: 797670)
+++ kparts/browserextension.cpp	(copia de trabajo)
@@ -790,7 +790,7 @@
 
     // we try to do it on our own, in hope that we are faster than
     // queryList, which looks kind of big :-)
-    foreach ( QObject * child, obj->children() ) {
+    Q_FOREACH ( QObject * child, obj->children() ) {
         KParts::BrowserHostExtension* ext = qobject_cast<KParts::BrowserHostExtension *>(child);
         if (ext)
             return ext;
@@ -833,7 +833,7 @@
 
     // we try to do it on our own, in hope that we are faster than
     // queryList, which looks kind of big :-)
-    foreach ( QObject * child, obj->children() ) {
+    Q_FOREACH ( QObject * child, obj->children() ) {
         KParts::LiveConnectExtension* ext = qobject_cast<KParts::LiveConnectExtension *>( child );
         if (ext)
             return ext;
Index: kded/kded.cpp
===================================================================
--- kded/kded.cpp	(revisión: 797670)
+++ kded/kded.cpp	(copia de trabajo)
@@ -343,7 +343,7 @@
                                   const QString &)
 {
 #if 0 // see kdedmodule.cpp (KDED_OBJECTS)
-  foreach( KDEDModule* module, m_modules )
+  Q_FOREACH( KDEDModule* module, m_modules )
   {
      module->removeAll(appId);
   }
@@ -357,7 +357,7 @@
   {
       qlonglong windowId = *it;
       m_globalWindowIdList.remove(windowId);
-      foreach( KDEDModule* module, m_modules )
+      Q_FOREACH( KDEDModule* module, m_modules )
       {
           emit module->windowUnregistered(windowId);
       }
@@ -574,7 +574,7 @@
   windowIds.append(windowId);
   m_windowIdList.insert(sender, windowIds);
 
-  foreach( KDEDModule* module, m_modules )
+  Q_FOREACH( KDEDModule* module, m_modules )
   {
      emit module->windowRegistered(windowId);
   }
@@ -593,7 +593,7 @@
         m_windowIdList.insert(sender, windowIds);
   }
 
-  foreach( KDEDModule* module, m_modules )
+  Q_FOREACH( KDEDModule* module, m_modules )
   {
     emit module->windowUnregistered(windowId);
   }
Index: kded/kbuildsycoca.cpp
===================================================================
--- kded/kbuildsycoca.cpp	(revisión: 797670)
+++ kded/kbuildsycoca.cpp	(copia de trabajo)
@@ -337,7 +337,7 @@
 {
   QString caption = caption_;
   QString name = name_;
-  foreach (VFolderMenu::SubMenu *subMenu, menu->subMenus)
+  Q_FOREACH (VFolderMenu::SubMenu *subMenu, menu->subMenus)
   {
      QString subName = name+subMenu->name+'/';
 
@@ -378,7 +378,7 @@
      caption += '/';
   if (name.isEmpty())
      name += '/';
-  foreach (KService::Ptr p, menu->items)
+  Q_FOREACH (KService::Ptr p, menu->items)
   {
      if (bMenuTest)
      {
@@ -563,7 +563,7 @@
    if (list.isEmpty())
       return true;
 
-   foreach ( const QFileInfo& fi, list ) {
+   Q_FOREACH ( const QFileInfo& fi, list ) {
       if( fi.fileName() == "." || fi.fileName() == ".." )
          continue;
       if( fi.lastModified() > stamp )
Index: kded/kbuildmimetypefactory.cpp
===================================================================
--- kded/kbuildmimetypefactory.cpp	(revisión: 797670)
+++ kded/kbuildmimetypefactory.cpp	(copia de trabajo)
@@ -127,7 +127,7 @@
     if (comment.isEmpty()) {
         kWarning() << "Missing <comment> field in " << fullPath;
     }
-    foreach(const QString& lang, KGlobal::locale()->languageList()) {
+    Q_FOREACH(const QString& lang, KGlobal::locale()->languageList()) {
         const QString comm = commentsByLanguage.value(lang);
         if (!comm.isEmpty()) {
             comment = comm;
Index: kded/vfolder_menu.cpp
===================================================================
--- kded/vfolder_menu.cpp	(revisión: 797670)
+++ kded/vfolder_menu.cpp	(copia de trabajo)
@@ -116,7 +116,7 @@
 void
 VFolderMenu::includeItems(QHash<QString,KService::Ptr>& items1, const QHash<QString,KService::Ptr>& items2)
 {
-   foreach (KService::Ptr p, items2) {
+   Q_FOREACH (KService::Ptr p, items2) {
        items1.insert(p->menuId(), p);
    }
 }
@@ -124,7 +124,7 @@
 void
 VFolderMenu::matchItems(QHash<QString,KService::Ptr>& items1, const QHash<QString,KService::Ptr>& items2)
 {
-   foreach (KService::Ptr p, items1)
+   Q_FOREACH (KService::Ptr p, items1)
    {
        QString id = p->menuId();
        if (!items2.contains(id))
@@ -135,7 +135,7 @@
 void
 VFolderMenu::excludeItems(QHash<QString,KService::Ptr>& items1, const QHash<QString,KService::Ptr>& items2)
 {
-   foreach (KService::Ptr p, items2)
+   Q_FOREACH (KService::Ptr p, items2)
        items1.remove(p->menuId());
 }
 
@@ -235,7 +235,7 @@
    const QString s2 = menuName.mid(i+1);
 
    // Look up menu
-   foreach (SubMenu *menu, parentMenu->subMenus)
+   Q_FOREACH (SubMenu *menu, parentMenu->subMenus)
    {
       if (menu->name == s1)
       {
@@ -282,7 +282,7 @@
    QString s2 = name.mid(i+1);
 
    // Look up menu
-   foreach (SubMenu *menu, parentMenu->subMenus)
+   Q_FOREACH (SubMenu *menu, parentMenu->subMenus)
    {
       if (menu->name == s1)
       {
@@ -312,7 +312,7 @@
 }
 
 #define FOR_ALL_APPLICATIONS(it) \
-   foreach (appsInfo *info, m_appsInfoStack) \
+   Q_FOREACH (appsInfo *info, m_appsInfoStack) \
    { \
       QHashIterator<QString,KService::Ptr> it = info->applications; \
       while (it.hasNext()) \
@@ -321,7 +321,7 @@
 #define FOR_ALL_APPLICATIONS_END } }
 
 #define FOR_CATEGORY(category, it) \
-   foreach (appsInfo *info, m_appsInfoStack) \
+   Q_FOREACH (appsInfo *info, m_appsInfoStack) \
    { \
       KService::List *list = info->dictCategories[category]; \
       if (list) for(KService::List::ConstIterator it = list->begin(); \
@@ -332,7 +332,7 @@
 KService::Ptr
 VFolderMenu::findApplication(const QString &relPath)
 {
-   foreach(appsInfo *info, m_appsInfoStack)
+   Q_FOREACH(appsInfo *info, m_appsInfoStack)
    {
       if (info->applications.contains(relPath)) {
          KService::Ptr s = info->applications[relPath];
@@ -353,7 +353,7 @@
 void
 VFolderMenu::buildApplicationIndex(bool unusedOnly)
 {
-   foreach (appsInfo *info, m_appsInfoList)
+   Q_FOREACH (appsInfo *info, m_appsInfoList)
    {
       info->dictCategories.clear();
       QMutableHashIterator<QString,KService::Ptr> it = info->applications;
@@ -1235,7 +1235,7 @@
       // Look up menu
       if (parentMenu)
       {
-         foreach (SubMenu *menu, parentMenu->subMenus)
+         Q_FOREACH (SubMenu *menu, parentMenu->subMenus)
          {
             if (menu->name == name)
             {
@@ -1275,7 +1275,7 @@
       // Look up menu
       if (parentMenu)
       {
-         foreach (SubMenu *menu, parentMenu->subMenus)
+         Q_FOREACH (SubMenu *menu, parentMenu->subMenus)
          {
             if (menu->name == name)
             {
@@ -1619,7 +1619,7 @@
         menu->layoutList = defaultLayout;
    }
 
-   foreach (VFolderMenu::SubMenu *subMenu, menu->subMenus)
+   Q_FOREACH (VFolderMenu::SubMenu *subMenu, menu->subMenus)
    {
       layoutMenu(subMenu, defaultLayout);
    }
@@ -1628,7 +1628,7 @@
 void
 VFolderMenu::markUsedApplications(const QHash<QString,KService::Ptr>& items)
 {
-   foreach(KService::Ptr p, items)
+   Q_FOREACH(KService::Ptr p, items)
       m_usedAppsDict.insert(p->menuId(), p);
 }
 
Index: kded/khostname.cpp
===================================================================
--- kded/khostname.cpp	(revisión: 797670)
+++ kded/khostname.cpp	(copia de trabajo)
@@ -126,7 +126,7 @@
       }
    }
 
-   foreach ( const QByteArray &it, lines )
+   Q_FOREACH ( const QByteArray &it, lines )
    {
       QList<QByteArray> entries = split(it);
       if (entries.count() != 3)
Index: solid/tests/solidhwtest.cpp
===================================================================
--- solid/tests/solidhwtest.cpp	(revisión: 797670)
+++ solid/tests/solidhwtest.cpp	(copia de trabajo)
@@ -59,7 +59,7 @@
 
     expected_udis = QSet<QString>::fromList(fakeManager->allDevices());
 
-    foreach (const Solid::Device &dev , devices)
+    Q_FOREACH (const Solid::Device &dev , devices)
     {
         received_udis << dev.udi();
     }
@@ -214,7 +214,7 @@
 
     // Note the extra space
     QCOMPARE(Solid::Device("/org/kde/solid/fakehw/computer ").isValid(), false);
-    QCOMPARE(Solid::Device("#'({(]").isValid(), false);
+    QCOMPARE(Solid::Device("#'({(�]").isValid(), false);
     QCOMPARE(Solid::Device(QString()).isValid(), false);
 
     // Now try to see if isValid() changes on plug/unplug events
@@ -310,7 +310,7 @@
 {
     QSet<QString> res;
 
-    foreach (const Solid::Device &device, list) {
+    Q_FOREACH (const Solid::Device &device, list) {
         res << device.udi();
     }
 
Index: solid/solid/devicemanager.cpp
===================================================================
--- solid/solid/devicemanager.cpp	(revisión: 797670)
+++ solid/solid/devicemanager.cpp	(copia de trabajo)
@@ -46,7 +46,7 @@
 
 Solid::DeviceManagerPrivate::~DeviceManagerPrivate()
 {
-    foreach (DevicePrivate *dev, m_devicesMap.values()) {
+    Q_FOREACH (DevicePrivate *dev, m_devicesMap.values()) {
         delete dev;
     }
 
@@ -63,7 +63,7 @@
 
     QStringList udis = backend->allDevices();
 
-    foreach (const QString &udi, udis)
+    Q_FOREACH (const QString &udi, udis)
     {
         list.append(Device(udi));
     }
@@ -98,7 +98,7 @@
 
     QStringList udis = backend->devicesFromQuery(parentUdi, type);
 
-    foreach (const QString &udi, udis)
+    Q_FOREACH (const QString &udi, udis)
     {
         list.append(Device(udi));
     }
@@ -120,14 +120,14 @@
     if (predicate.isValid()) {
         QSet<DeviceInterface::Type> types = predicate.usedTypes();
 
-        foreach (DeviceInterface::Type type, types) {
+        Q_FOREACH (DeviceInterface::Type type, types) {
             udis+= QSet<QString>::fromList(backend->devicesFromQuery(parentUdi, type));
         }
     } else {
         udis+= QSet<QString>::fromList(backend->allDevices());
     }
 
-    foreach (const QString &udi, udis)
+    Q_FOREACH (const QString &udi, udis)
     {
         Device dev(udi);
 
Index: solid/solid/device.cpp
===================================================================
--- solid/solid/device.cpp	(revisión: 797670)
+++ solid/solid/device.cpp	(copia de trabajo)
@@ -261,7 +261,7 @@
     }
 
     if (!m_ifaces.isEmpty()) {
-        foreach (DeviceInterface *iface, m_ifaces.values()) {
+        Q_FOREACH (DeviceInterface *iface, m_ifaces.values()) {
             delete iface->d_ptr->backendObject();
             delete iface;
         }
Index: solid/solid/backends/hal/halopticaldisc.cpp
===================================================================
--- solid/solid/backends/hal/halopticaldisc.cpp	(revisión: 797670)
+++ solid/solid/backends/hal/halopticaldisc.cpp	(copia de trabajo)
@@ -44,7 +44,7 @@
     map[Solid::OpticalDisc::SuperVideoCd] = "volume.disc.is_svcd";
     map[Solid::OpticalDisc::VideoDvd] ="volume.disc.is_videodvd";
 
-    foreach (const Solid::OpticalDisc::ContentType type, map.keys())
+    Q_FOREACH (const Solid::OpticalDisc::ContentType type, map.keys())
     {
         if (m_device->property(map[type]).toBool())
         {
Index: solid/solid/backends/hal/haldevice.cpp
===================================================================
--- solid/solid/backends/hal/haldevice.cpp	(revisión: 797670)
+++ solid/solid/backends/hal/haldevice.cpp	(copia de trabajo)
@@ -324,7 +324,7 @@
     QStringList cap_list = DeviceInterface::toStringList(type);
     QStringList result;
 
-    foreach (const QString &cap, cap_list)
+    Q_FOREACH (const QString &cap, cap_list)
     {
         QDBusReply<bool> reply = d->device.call("QueryCapability", cap);
 
@@ -413,7 +413,7 @@
 {
     QMap<QString,int> result;
 
-    foreach (const ChangeDescription &change, changes)
+    Q_FOREACH (const ChangeDescription &change, changes)
     {
         QString key = change.key;
         bool added = change.added;
Index: solid/solid/backends/hal/halcdrom.cpp
===================================================================
--- solid/solid/backends/hal/halcdrom.cpp	(revisión: 797670)
+++ solid/solid/backends/hal/halcdrom.cpp	(copia de trabajo)
@@ -63,7 +63,7 @@
     map[Solid::OpticalDrive::HdDvdr] ="storage.cdrom.hddvdr";
     map[Solid::OpticalDrive::HdDvdrw] ="storage.cdrom.hddvdrw";
 
-    foreach (const Solid::OpticalDrive::MediumType type, map.keys())
+    Q_FOREACH (const Solid::OpticalDrive::MediumType type, map.keys())
     {
         if (m_device->property(map[type]).toBool())
         {
@@ -89,7 +89,7 @@
     QList<int> speeds;
     QStringList speed_strlist = m_device->property("storage.cdrom.write_speeds").toStringList();
 
-    foreach (const QString &speed_str, speed_strlist)
+    Q_FOREACH (const QString &speed_str, speed_strlist)
     {
         speeds << speed_str.toInt();
     }
Index: solid/solid/backends/hal/halmanager.cpp
===================================================================
--- solid/solid/backends/hal/halmanager.cpp	(revisión: 797670)
+++ solid/solid/backends/hal/halmanager.cpp	(copia de trabajo)
@@ -169,7 +169,7 @@
     QStringList cap_list = DeviceInterface::toStringList(type);
     QStringList result;
 
-    foreach (const QString &cap, cap_list)
+    Q_FOREACH (const QString &cap, cap_list)
     {
         QDBusReply<QStringList> reply = d->manager.call("FindDeviceByCapability", cap);
 
@@ -182,7 +182,7 @@
         {
             QStringList foundDevices ( reply );
             QStringList filtered;
-            foreach ( const QString &udi, foundDevices )
+            Q_FOREACH ( const QString &udi, foundDevices )
             {
                 QDBusInterface device( "org.freedesktop.Hal", udi, "org.freedesktop.Hal.Device", QDBusConnection::systemBus() );
                 QDBusReply<QString> reply = device.call( "GetProperty", "video4linux.device" );
Index: solid/solid/backends/fakehw/fakemanager.cpp
===================================================================
--- solid/solid/backends/fakehw/fakemanager.cpp	(revisión: 797670)
+++ solid/solid/backends/fakehw/fakemanager.cpp	(copia de trabajo)
@@ -62,7 +62,7 @@
 {
     QStringList deviceUdiList;
 
-    foreach (FakeDevice *device, d->loadedDevices.values())
+    Q_FOREACH (FakeDevice *device, d->loadedDevices.values())
     {
         deviceUdiList.append(device->udi());
     }
@@ -132,7 +132,7 @@
 {
     QStringList result;
     FakeDevice *device;
-    foreach (device, d->loadedDevices.values())
+    Q_FOREACH (device, d->loadedDevices.values())
     {
         if (device->property(key).toString() == value)
         {
@@ -147,7 +147,7 @@
 {
     QStringList result;
     FakeDevice *device;
-    foreach (device, d->loadedDevices.values())
+    Q_FOREACH (device, d->loadedDevices.values())
     {
         if (device->queryDeviceInterface(type))
         {
Index: solid/solid/backends/fakehw/fakeprocessor.cpp
===================================================================
--- solid/solid/backends/fakehw/fakeprocessor.cpp	(revisión: 797670)
+++ solid/solid/backends/fakehw/fakeprocessor.cpp	(copia de trabajo)
@@ -55,7 +55,7 @@
 
     QStringList extension_list = str.split(",");
 
-    foreach (const QString &extension_str, extension_list) {
+    Q_FOREACH (const QString &extension_str, extension_list) {
         if (extension_str == "mmx") {
             result |= Solid::Processor::IntelMmx;
         }
Index: solid/solid/backends/fakehw/fakeaudiointerface.cpp
===================================================================
--- solid/solid/backends/fakehw/fakeaudiointerface.cpp	(revisión: 797670)
+++ solid/solid/backends/fakehw/fakeaudiointerface.cpp	(copia de trabajo)
@@ -59,7 +59,7 @@
     if (driver() == Solid::AudioInterface::Alsa) {
         const QStringList x = fakeDevice()->property("driverHandle").toString().split(',');
         QList<QVariant> ret;
-        foreach (const QString &num, x) {
+        Q_FOREACH (const QString &num, x) {
             ret << num.toInt();
         }
         return ret;
@@ -78,7 +78,7 @@
 
     QStringList type_list = fakeDevice()->property("type").toString().split(",");
 
-    foreach (const QString &type_str, type_list)
+    Q_FOREACH (const QString &type_str, type_list)
     {
         if (type_str == "control")
         {
Index: solid/solid/backends/fakehw/fakestorageaccess.cpp
===================================================================
--- solid/solid/backends/fakehw/fakestorageaccess.cpp	(revisión: 797670)
+++ solid/solid/backends/fakehw/fakestorageaccess.cpp	(copia de trabajo)
@@ -66,7 +66,7 @@
 
 void Solid::Backends::Fake::FakeStorageAccess::onPropertyChanged(const QMap<QString,int> &changes)
 {
-    foreach (const QString &property, changes.keys()) {
+    Q_FOREACH (const QString &property, changes.keys()) {
         if (property=="isMounted") {
             emit accessibilityChanged(fakeDevice()->property("isMounted").toBool(), fakeDevice()->udi());
         }
Index: solid/solid/backends/fakehw/fakeopticaldisc.cpp
===================================================================
--- solid/solid/backends/fakehw/fakeopticaldisc.cpp	(revisión: 797670)
+++ solid/solid/backends/fakehw/fakeopticaldisc.cpp	(copia de trabajo)
@@ -47,7 +47,7 @@
 
     QStringList content_typelist = fakeDevice()->property("availableContent").toString().split(',');
 
-    foreach (const Solid::OpticalDisc::ContentType type, map.keys())
+    Q_FOREACH (const Solid::OpticalDisc::ContentType type, map.keys())
     {
         if (content_typelist.indexOf(map[type]) != -1)
         {
Index: solid/solid/backends/fakehw/fakedevice.cpp
===================================================================
--- solid/solid/backends/fakehw/fakedevice.cpp	(revisión: 797670)
+++ solid/solid/backends/fakehw/fakedevice.cpp	(copia de trabajo)
@@ -70,7 +70,7 @@
     // this way they'll get exported on the bus
     // that means they'll be created twice, but that won't be
     // a problem for unit testing.
-    foreach (const QString &interface, d->interfaceList)
+    Q_FOREACH (const QString &interface, d->interfaceList)
     {
         Solid::DeviceInterface::Type type = Solid::DeviceInterface::stringToType(interface);
         createDeviceInterface(type);
Index: solid/solid/backends/fakehw/fakecdrom.cpp
===================================================================
--- solid/solid/backends/fakehw/fakecdrom.cpp	(revisión: 797670)
+++ solid/solid/backends/fakehw/fakecdrom.cpp	(copia de trabajo)
@@ -58,7 +58,7 @@
 
     QStringList supported_medialist = fakeDevice()->property("supportedMedia").toString().simplified().split(',');
 
-    foreach (const Solid::OpticalDrive::MediumType type, map.keys())
+    Q_FOREACH (const Solid::OpticalDrive::MediumType type, map.keys())
     {
         if (supported_medialist.indexOf(map[type]) != -1)
         {
@@ -84,7 +84,7 @@
     QList<int> speeds;
     QStringList speed_strlist = fakeDevice()->property("writeSpeeds").toString().simplified().split(',');
 
-    foreach (const QString &speed_str, speed_strlist)
+    Q_FOREACH (const QString &speed_str, speed_strlist)
     {
         speeds << speed_str.toInt();
     }
Index: solid/solid/backends/wmi/wmiopticaldisc.cpp
===================================================================
--- solid/solid/backends/wmi/wmiopticaldisc.cpp	(revisión: 797670)
+++ solid/solid/backends/wmi/wmiopticaldisc.cpp	(copia de trabajo)
@@ -44,7 +44,7 @@
     map[Solid::OpticalDisc::SuperVideoCd] = "volume.disc.is_svcd";
     map[Solid::OpticalDisc::VideoDvd] ="volume.disc.is_videodvd";
 
-    foreach (const Solid::OpticalDisc::ContentType type, map.keys())
+    Q_FOREACH (const Solid::OpticalDisc::ContentType type, map.keys())
     {
         if (m_device->property(map[type]).toBool())
         {
Index: solid/solid/backends/wmi/wmidevice.cpp
===================================================================
--- solid/solid/backends/wmi/wmidevice.cpp	(revisión: 797670)
+++ solid/solid/backends/wmi/wmidevice.cpp	(copia de trabajo)
@@ -292,7 +292,7 @@
     QStringList cap_list = DeviceInterface::toStringList(type);
     QStringList result;
 
-    // foreach (const QString &cap, cap_list)
+    // Q_FOREACH (const QString &cap, cap_list)
     // {
         // QDBusReply<bool> reply = d->device.call("QueryCapability", cap);
 
@@ -381,7 +381,7 @@
 {
     QMap<QString,int> result;
 
-    foreach (const ChangeDescription &change, changes)
+    Q_FOREACH (const ChangeDescription &change, changes)
     {
         QString key = change.key;
         bool added = change.added;
Index: solid/solid/backends/wmi/wmicdrom.cpp
===================================================================
--- solid/solid/backends/wmi/wmicdrom.cpp	(revisión: 797670)
+++ solid/solid/backends/wmi/wmicdrom.cpp	(copia de trabajo)
@@ -60,7 +60,7 @@
     map[Solid::OpticalDrive::HdDvdr] ="storage.cdrom.hddvdr";
     map[Solid::OpticalDrive::HdDvdrw] ="storage.cdrom.hddvdrw";
 
-    foreach (const Solid::OpticalDrive::MediumType type, map.keys())
+    Q_FOREACH (const Solid::OpticalDrive::MediumType type, map.keys())
     {
         if (m_device->property(map[type]).toBool())
         {
@@ -86,7 +86,7 @@
     QList<int> speeds;
     QStringList speed_strlist = m_device->property("storage.cdrom.write_speeds").toStringList();
 
-    foreach (const QString &speed_str, speed_strlist)
+    Q_FOREACH (const QString &speed_str, speed_strlist)
     {
         speeds << speed_str.toInt();
     }
Index: solid/solid/backends/wmi/wmimanager.cpp
===================================================================
--- solid/solid/backends/wmi/wmimanager.cpp	(revisión: 797670)
+++ solid/solid/backends/wmi/wmimanager.cpp	(copia de trabajo)
@@ -156,7 +156,7 @@
     // QStringList cap_list = DeviceInterface::toStringList(type);
     // QStringList result;
 
-    // foreach (const QString &cap, cap_list)
+    // Q_FOREACH (const QString &cap, cap_list)
     // {
         // QDBusReply<QStringList> reply = d->manager.call("FindDeviceByCapability", cap);
 
@@ -169,7 +169,7 @@
         // {
             // QStringList foundDevices ( reply );
             // QStringList filtered;
-            // foreach ( const QString &udi, foundDevices )
+            // Q_FOREACH ( const QString &udi, foundDevices )
             // {
                 // QDBusInterface device( "org.freedesktop.Wmi", udi, "org.freedesktop.Wmi.Device", QDBusConnection::systemBus() );
                 // QDBusReply<QString> reply = device.call( "GetProperty", "video4linux.device" );
Index: solid/examples/tutorial1/tutorial1.cpp
===================================================================
--- solid/examples/tutorial1/tutorial1.cpp	(revisión: 797670)
+++ solid/examples/tutorial1/tutorial1.cpp	(copia de trabajo)
@@ -38,7 +38,7 @@
 {
     KComponentData componentData("tutorial1");
     
-    foreach (const Solid::Device &device, Solid::Device::allDevices())
+    Q_FOREACH (const Solid::Device &device, Solid::Device::allDevices())
     {
         kDebug() << device.udi().toLatin1().constData();
     }
Index: solid/examples/tutorial2/tutorial2.cpp
===================================================================
--- solid/examples/tutorial2/tutorial2.cpp	(revisión: 797670)
+++ solid/examples/tutorial2/tutorial2.cpp	(copia de trabajo)
@@ -40,7 +40,7 @@
     KComponentData componentData("tutorial2");
     
     //get a list of all devices that are AudioInterface
-    foreach (const Solid::Device &device, Solid::Device::listFromType(Solid::DeviceInterface::AudioInterface, QString()))
+    Q_FOREACH (const Solid::Device &device, Solid::Device::listFromType(Solid::DeviceInterface::AudioInterface, QString()))
     {
         kDebug() << device.udi().toLatin1().constData();
     }
Index: solid/examples/tutorial6/webcamwatcher.cpp
===================================================================
--- solid/examples/tutorial6/webcamwatcher.cpp	(revisión: 797670)
+++ solid/examples/tutorial6/webcamwatcher.cpp	(copia de trabajo)
@@ -31,7 +31,7 @@
 {
     // get a list of all the webcams in the system
     int found = 0;
-    foreach (const Solid::Device &device, Solid::Device::listFromType(Solid::DeviceInterface::Video, QString()))
+    Q_FOREACH (const Solid::Device &device, Solid::Device::listFromType(Solid::DeviceInterface::Video, QString()))
     {
         m_videoDevices << device.udi();
         getDetails( device );
Index: kioslave/http/kcookiejar/kcookieserver.cpp
===================================================================
--- kioslave/http/kcookiejar/kcookieserver.cpp	(revisión: 797670)
+++ kioslave/http/kcookiejar/kcookieserver.cpp	(copia de trabajo)
@@ -306,7 +306,7 @@
 void KCookieServer::putCookie( QStringList& out, KHttpCookie *cookie,
                                const QList<int>& fields )
 {
-	foreach ( int i, fields ) {
+	Q_FOREACH ( int i, fields ) {
        switch(i)
         {
          case CF_DOMAIN :
Index: kioslave/http/kcookiejar/kcookiejar.cpp
===================================================================
--- kioslave/http/kcookiejar/kcookiejar.cpp	(revisión: 797670)
+++ kioslave/http/kcookiejar/kcookiejar.cpp	(copia de trabajo)
@@ -253,7 +253,7 @@
     KConfig cfg( "khtml/domain_info", KConfig::NoGlobals, "data" );
     KConfigGroup group( &cfg, QString() );
     QStringList countries = group.readEntry( "twoLevelTLD", QStringList() );
-    foreach ( const QString& country, countries ) {
+    Q_FOREACH ( const QString& country, countries ) {
        m_twoLevelTLD.insert( country, 1 );
     }
 }
@@ -1531,7 +1531,7 @@
     // Reset current domain settings first.
     //  (must make a copy because setDomainAdvice() might delete the domain from m_domainList inside the for loop)
     const QStringList domains = m_domainList;
-    foreach( const QString &domain, domains )
+    Q_FOREACH( const QString &domain, domains )
     {
          setDomainAdvice(domain, KCookieDunno);
     }
Index: kioslave/http/http_cache_cleaner.cpp
===================================================================
--- kioslave/http/http_cache_cleaner.cpp	(revisión: 797670)
+++ kioslave/http/http_cache_cleaner.cpp	(copia de trabajo)
@@ -179,7 +179,7 @@
 
    if (newEntries.count()==0) return; // Directory not accessible ??
 
-   foreach ( const QFileInfo &qFileInfo, newEntries ) {
+   Q_FOREACH ( const QFileInfo &qFileInfo, newEntries ) {
        if (qFileInfo.isFile())
        {
           FileInfo *fileInfo = readEntry( strDir + '/' + qFileInfo.fileName());
Index: nepomuk/core/test/speedtest.cpp
===================================================================
--- nepomuk/core/test/speedtest.cpp	(revisión: 797670)
+++ nepomuk/core/test/speedtest.cpp	(copia de trabajo)
@@ -51,7 +51,7 @@
     qDebug( "Added %d resources in %d ms", TESTCNT, t.elapsed() );
 
     // check that everything has been saved properly
-    foreach( const Resource &r, rl ) {
+    Q_FOREACH( const Resource &r, rl ) {
         QVERIFY( rr->containsAnyStatement( Statement( r.resourceUri(), Node(), Node() ) ) );
     }
 
@@ -64,7 +64,7 @@
     qDebug( "Removed %d resources in %d ms", TESTCNT, t.elapsed() );
 
     // check that there actually is nothing left
-    foreach( const Resource &r, rl ) {
+    Q_FOREACH( const Resource &r, rl ) {
         QVERIFY( !rr->containsAnyStatement( Statement( r.resourceUri(), Node(), Node() ) ) );
     }
 }
Index: nepomuk/core/test/resourcetest.cpp
===================================================================
--- nepomuk/core/test/resourcetest.cpp	(revisión: 797670)
+++ nepomuk/core/test/resourcetest.cpp	(copia de trabajo)
@@ -160,7 +160,7 @@
 
         QList<Statement> sl = rr.listStatements( defaultGraph(), Statement( QUrl( r1.uri() ), Node(), Node() ) );
 
-        foreach( const Statement& s, sl )
+        Q_FOREACH( const Statement& s, sl )
             qDebug() << s << endl;
 
         QCOMPARE( sl.count(), 3 );
Index: nepomuk/core/resourcefiltermodel.cpp
===================================================================
--- nepomuk/core/resourcefiltermodel.cpp	(revisión: 797670)
+++ nepomuk/core/resourcefiltermodel.cpp	(copia de trabajo)
@@ -97,7 +97,7 @@
     QList<Node> existingValues = listStatements( Statement( resource, property, Node() ) ).iterateObjects().allNodes();
 
     Error::ErrorCode c = Error::ErrorNone;
-    foreach( const Node &node, existingValues.toSet() - values.toSet() ) {
+    Q_FOREACH( const Node &node, existingValues.toSet() - values.toSet() ) {
         if ( ( c = removeAllStatements( Statement( resource, property, node ) ) ) != Error::ErrorNone ) {
             return c;
         }
@@ -106,7 +106,7 @@
     QSet<Node> newNodes = values.toSet() - existingValues.toSet();
     if ( !newNodes.isEmpty() ) {
         QUrl newContext = ResourceManager::instance()->generateUniqueUri();
-        foreach( const Node &node, newNodes ) {
+        Q_FOREACH( const Node &node, newNodes ) {
             if ( ( c = addStatement( Statement( resource, property, node, newContext ) ) ) != Error::ErrorNone ) {
                 return c;
             }
Index: nepomuk/core/ontology/class.cpp
===================================================================
--- nepomuk/core/ontology/class.cpp	(revisión: 797670)
+++ nepomuk/core/ontology/class.cpp	(copia de trabajo)
@@ -173,10 +173,10 @@
 
     if ( propertiesAvailable != -1 ) {
         if ( recursive ) {
-            foreach( Property p, domainOf ) {
+            Q_FOREACH( Property p, domainOf ) {
                 p.reset( true );
             }
-            foreach( Property p, rangeOf ) {
+            Q_FOREACH( Property p, rangeOf ) {
                 p.reset( true );
             }
         }
@@ -188,7 +188,7 @@
 
     if ( available != -1 ) {
         if ( recursive ) {
-            foreach( Class c, parents ) {
+            Q_FOREACH( Class c, parents ) {
                 c.reset( true );
             }
         }
@@ -198,7 +198,7 @@
 
     if ( ancestorsAvailable != -1 ) {
         if ( recursive ) {
-            foreach( Class c, children ) {
+            Q_FOREACH( Class c, children ) {
                 c.reset( true );
             }
         }
Index: nepomuk/core/ontology/ontology.cpp
===================================================================
--- nepomuk/core/ontology/ontology.cpp	(revisión: 797670)
+++ nepomuk/core/ontology/ontology.cpp	(copia de trabajo)
@@ -104,10 +104,10 @@
 
     if ( entitiesAvailable != -1 ) {
         if ( recursive ) {
-            foreach( Class c, classes ) {
+            Q_FOREACH( Class c, classes ) {
                 c.reset( true );
             }
-            foreach( Property p, properties ) {
+            Q_FOREACH( Property p, properties ) {
                 p.reset( true );
             }
         }
Index: nepomuk/core/ontology/property.cpp
===================================================================
--- nepomuk/core/ontology/property.cpp	(revisión: 797670)
+++ nepomuk/core/ontology/property.cpp	(copia de trabajo)
@@ -113,7 +113,7 @@
             range.reset( true );
             domain.reset( true );
             inverse.reset( true );
-            foreach( Property p, parents ) {
+            Q_FOREACH( Property p, parents ) {
                 p.reset( true );
             }
         }
@@ -124,7 +124,7 @@
 
     if ( ancestorsAvailable != -1 ) {
         if ( recursive ) {
-            foreach( Property p, children ) {
+            Q_FOREACH( Property p, children ) {
                 p.reset( true );
             }
         }
Index: nepomuk/core/ontology/desktopontologyloader.cpp
===================================================================
--- nepomuk/core/ontology/desktopontologyloader.cpp	(revisión: 797670)
+++ nepomuk/core/ontology/desktopontologyloader.cpp	(copia de trabajo)
@@ -52,7 +52,7 @@
 //        ontoCache.clear();
 
         QStringList allOntologies = KGlobal::dirs()->findAllResources( "data", "nepomuk/ontologies/*.desktop" );
-        foreach( const QString &ontoDesktopFilePath, allOntologies ) {
+        Q_FOREACH( const QString &ontoDesktopFilePath, allOntologies ) {
             KDesktopFile ontoDesktopFile( ontoDesktopFilePath );
 
             if ( ontoDesktopFile.hasLinkType() ) {
Index: nepomuk/core/ui/nepomukmassupdatejob.cpp
===================================================================
--- nepomuk/core/ui/nepomukmassupdatejob.cpp	(revisión: 797670)
+++ nepomuk/core/ui/nepomukmassupdatejob.cpp	(copia de trabajo)
@@ -46,7 +46,7 @@
 void Nepomuk::MassUpdateJob::setFiles( const KUrl::List& urls )
 {
     m_resources.clear();
-    foreach( KUrl url, urls ) {
+    Q_FOREACH( KUrl url, urls ) {
         m_resources.append( Resource( url ) );
     }
     setTotalAmount( KJob::Files, m_resources.count() );
Index: nepomuk/core/ui/kblocklayout.cpp
===================================================================
--- nepomuk/core/ui/kblocklayout.cpp	(revisión: 797670)
+++ nepomuk/core/ui/kblocklayout.cpp	(copia de trabajo)
@@ -127,7 +127,7 @@
 {
     QSize size;
     QLayoutItem *item;
-    foreach (item, d->itemList)
+    Q_FOREACH (item, d->itemList)
         size = size.expandedTo(item->minimumSize());
 
     size += QSize(2*margin(), 2*margin());
@@ -153,7 +153,7 @@
     // 1. calculate lines
     QList<Row> rows;
     QList<QLayoutItem*> rowItems;
-    foreach( QLayoutItem* item, d->itemList ) {
+    Q_FOREACH( QLayoutItem* item, d->itemList ) {
         int nextX = x + item->sizeHint().width() + spacing();
         if (nextX - spacing() > rect.right() && lineHeight > 0) {
             rows.append( Row( rowItems, lineHeight, x - spacing() ) );
@@ -179,14 +179,14 @@
 
     // 2. place the items
     y = rect.y();
-    foreach( const Row &row, rows ) {
+    Q_FOREACH( const Row &row, rows ) {
         x = rect.x();
         if( alignment() & Qt::AlignRight )
             x += (rect.width() - row.width);
         else if( alignment() & Qt::AlignHCenter )
             x += (rect.width() - row.width)/2;
 
-        foreach( QLayoutItem* item, row.items ) {
+        Q_FOREACH( QLayoutItem* item, row.items ) {
             int yy = y;
             if( alignment() & Qt::AlignBottom )
                 yy += (row.height - item->sizeHint().height());
Index: nepomuk/core/ui/ktagdisplaywidget.cpp
===================================================================
--- nepomuk/core/ui/ktagdisplaywidget.cpp	(revisión: 797670)
+++ nepomuk/core/ui/ktagdisplaywidget.cpp	(copia de trabajo)
@@ -36,7 +36,7 @@
 
     void buildDisplay() {
         // delete all the children
-        foreach( QWidget* w, wl )
+        Q_FOREACH( QWidget* w, wl )
             delete w;
         wl.clear();
 
@@ -103,7 +103,7 @@
 
 void KTagDisplayWidget::addTags( const QStringList& tags )
 {
-    foreach( const QString &tag, tags )
+    Q_FOREACH( const QString &tag, tags )
         if ( !d->tags.contains( tag ) )
             d->tags.append( tag );
     d->buildDisplay();
Index: nepomuk/core/ui/ktagcloudwidget.cpp
===================================================================
--- nepomuk/core/ui/ktagcloudwidget.cpp	(revisión: 797670)
+++ nepomuk/core/ui/ktagcloudwidget.cpp	(copia de trabajo)
@@ -165,7 +165,7 @@
     qSort( tags.begin(), tags.end() );
 
     int x = 0;
-    foreach( const QString &tag, tags ) {
+    Q_FOREACH( const QString &tag, tags ) {
         KUrlLabel* label = d->labelMap[tag];
         if( x + label->width() > width() ) {
             // new line
Index: nepomuk/core/ui/kmetadatatagwidget.cpp
===================================================================
--- nepomuk/core/ui/kmetadatatagwidget.cpp	(revisión: 797670)
+++ nepomuk/core/ui/kmetadatatagwidget.cpp	(copia de trabajo)
@@ -186,7 +186,7 @@
 {
     QList<Tag> allTags = Tag::allTags();
     // Prepare allTags list
-    foreach( Tag tag, allTags ) {
+    Q_FOREACH( Tag tag, allTags ) {
         if ( tag.label().isEmpty() ) {
             tag.setLabel( tag.genericLabel() );
         }
@@ -197,7 +197,7 @@
 
     d->tagMenu->clear();
     d->tagFromAction.clear();
-    foreach( Tag tag,  allTags ) {
+    Q_FOREACH( Tag tag,  allTags ) {
         QAction* a = d->tagMenu->addAction( tag.label(), this, SLOT( updateAssignedTagsFromMenu() ) );
         d->tagFromAction.insert( a, tag );
         a->setCheckable( true );
Index: nepomuk/rcgen/rcgen.cpp
===================================================================
--- nepomuk/rcgen/rcgen.cpp	(revisión: 797670)
+++ nepomuk/rcgen/rcgen.cpp	(copia de trabajo)
@@ -111,7 +111,7 @@
             return usage();
     }
 
-    foreach( const QString &ontoFile, ontoFiles ) {
+    Q_FOREACH( const QString &ontoFile, ontoFiles ) {
         if( !QFile::exists( ontoFile ) ) {
             qDebug() << "Ontology file " << ontoFile << " does not exist." << endl;
             return -1;
@@ -126,7 +126,7 @@
     }
 
     OntologyParser prsr;
-    foreach( const QString &ontoFile, ontoFiles ) {
+    Q_FOREACH( const QString &ontoFile, ontoFiles ) {
         if( !prsr.parse( ontoFile ) ) {
             qDebug() << "Parsing ontology file " << ontoFile << " failed." << endl;
             return -1;
Index: nepomuk/rcgen/ontologyparser.cpp
===================================================================
--- nepomuk/rcgen/ontologyparser.cpp	(revisión: 797670)
+++ nepomuk/rcgen/ontologyparser.cpp	(copia de trabajo)
@@ -87,7 +87,7 @@
 bool OntologyParser::assignTemplates( const QStringList& templates )
 {
     // FIXME: do an actual class name mapping by parsing the class
-    foreach( const QString &tf, templates ) {
+    Q_FOREACH( const QString &tf, templates ) {
         QString filename = QFileInfo( tf ).fileName();
         for( QMap<QString, ResourceClass>::iterator it = d->resources.begin();
              it != d->resources.end(); ++it ) {
Index: nepomuk/rcgen/resourceclass.cpp
===================================================================
--- nepomuk/rcgen/resourceclass.cpp	(revisión: 797670)
+++ nepomuk/rcgen/resourceclass.cpp	(copia de trabajo)
@@ -537,7 +537,7 @@
     // So we have to use a workaround instead
     //
     if( allParents.count() > 1 ) {
-        foreach( ResourceClass* rc, allParents ) {
+        Q_FOREACH( ResourceClass* rc, allParents ) {
             // ignore the one we derived from
             if( rc != parent ) {
                 ms << writeComment( QString("Nepomuk does not support multiple inheritance. Thus, to access "
@@ -643,7 +643,7 @@
     // So we have to use a workaround instead
     //
     if( allParents.count() > 1 ) {
-        foreach( ResourceClass* rc, allParents ) {
+        Q_FOREACH( ResourceClass* rc, allParents ) {
             // ignore the one we derived from
             if( rc != parent ) {
                 ms << pseudoInheritanceDefinition( rc ) << endl;
Index: kinit/kwrapper_win.cpp
===================================================================
--- kinit/kwrapper_win.cpp	(revisión: 797670)
+++ kinit/kwrapper_win.cpp	(copia de trabajo)
@@ -91,7 +91,7 @@
         - all to client path environment 
         - pathes not ending with lib to application search path
     */
-    foreach(QString a, path.split(';'))
+    Q_FOREACH(QString a, path.split(';'))
     {
         if (!envPath.contains(a))
             envPath << a;
@@ -139,7 +139,7 @@
         kdedirsCacheList << rootPath + "/kdedirs.cache";
 
         bool found = false;
-        foreach(QString kdedirsCachePath,kdedirsCacheList) 
+        Q_FOREACH(QString kdedirsCachePath,kdedirsCacheList)
         {
             QFile f(kdedirsCachePath);
             if (f.exists()) 
@@ -169,7 +169,7 @@
     if (verbose)
         qDebug() << "found KDEDIRS\n\t" << kdedirs.join("\n\t");
     
-    foreach(QString a, kdedirs)
+    Q_FOREACH(QString a, kdedirs)
     {
         if (!envPath.contains(a+"/bin"))
             envPath << a + "/bin";                
@@ -186,7 +186,7 @@
         qDebug() << "search " << exeToStart << "in";
     
     bool found = false;        
-    foreach(QString a, searchPath)
+    Q_FOREACH(QString a, searchPath)
     {
         if (verbose)
             qDebug() << "\t" << a;
Index: kinit/klauncher.cpp
===================================================================
--- kinit/klauncher.cpp	(revisión: 797670)
+++ kinit/klauncher.cpp	(copia de trabajo)
@@ -367,7 +367,7 @@
 void
 KLauncher::processDied(pid_t pid, long /* exitStatus */)
 {
-   foreach (KLaunchRequest *request, requestList)
+   Q_FOREACH (KLaunchRequest *request, requestList)
    {
       if (request->pid == pid)
       {
@@ -392,7 +392,7 @@
    if (appId.isEmpty() || newOwner.isEmpty())
       return;
 
-   foreach (KLaunchRequest *request, requestList)
+   Q_FOREACH (KLaunchRequest *request, requestList)
    {
       if (request->status != KLaunchRequest::Launching)
          continue;
@@ -554,7 +554,7 @@
 
 // process.setEnvironment(envlist);
    QStringList args;
-   foreach (const QString &arg, request->arg_list)
+   Q_FOREACH (const QString &arg, request->arg_list)
       args << arg;
 
    process->setProgram(request->name,args);
@@ -582,10 +582,10 @@
    appendLong(requestData, request->arg_list.count() + 1);
    requestData.append(request->name.toLocal8Bit());
    requestData.append('\0');
-   foreach (const QString &arg, request->arg_list)
+   Q_FOREACH (const QString &arg, request->arg_list)
        requestData.append(arg.toLocal8Bit()).append('\0');
    appendLong(requestData, request->envs.count());
-   foreach (const QString &env, request->envs)
+   Q_FOREACH (const QString &env, request->envs)
        requestData.append(env.toLocal8Bit()).append('\0');
    appendLong(requestData, 0); // avoid_loops, always false here
 #ifdef Q_WS_X11
@@ -792,7 +792,7 @@
     KStartupInfoId id;
     id.initId( startup_id.toLatin1() );
     QString dpy_str;
-    foreach (const QString &env, envs) {
+    Q_FOREACH (const QString &env, envs) {
         if (env.startsWith(QLatin1String("DISPLAY=")))
             dpy_str = env.mid(8);
     }
@@ -840,7 +840,7 @@
     if( !startup_id.isEmpty() && startup_id != "0" )
     {
         QString dpy_str;
-        foreach (const QString &env, envs) {
+        Q_FOREACH (const QString &env, envs) {
             if (env.startsWith(QLatin1String("DISPLAY=")))
                 dpy_str = env.mid(8);
         }
@@ -953,7 +953,7 @@
 KLauncher::requestHoldSlave(const KUrl &url, const QString &app_socket)
 {
     IdleSlave *slave = 0;
-    foreach (IdleSlave *p, mSlaveList)
+    Q_FOREACH (IdleSlave *p, mSlaveList)
     {
        if (p->onHold(url))
        {
@@ -978,7 +978,7 @@
                         QString &error)
 {
     IdleSlave *slave = 0;
-    foreach (IdleSlave *p, mSlaveList)
+    Q_FOREACH (IdleSlave *p, mSlaveList)
     {
        if (p->match(protocol, host, true))
        {
@@ -988,7 +988,7 @@
     }
     if (!slave)
     {
-       foreach (IdleSlave *p, mSlaveList)
+       Q_FOREACH (IdleSlave *p, mSlaveList)
        {
           if (p->match(protocol, host, false))
           {
@@ -999,7 +999,7 @@
     }
     if (!slave)
     {
-       foreach (IdleSlave *p, mSlaveList)
+       Q_FOREACH (IdleSlave *p, mSlaveList)
        {
           if (p->match(protocol, QString(), false))
           {
@@ -1087,7 +1087,7 @@
 void
 KLauncher::waitForSlave(int pid, const QDBusMessage &msg)
 {
-    foreach (IdleSlave *slave, mSlaveList)
+    Q_FOREACH (IdleSlave *slave, mSlaveList)
     {
         if (slave->pid() == static_cast<pid_t>(pid))
            return; // Already here.
@@ -1146,7 +1146,7 @@
 {
     bool keepOneFileSlave=true;
     time_t now = time(0);
-    foreach (IdleSlave *slave, mSlaveList)
+    Q_FOREACH (IdleSlave *slave, mSlaveList)
     {
         if ((slave->protocol()=="file") && (keepOneFileSlave))
            keepOneFileSlave=false;
@@ -1161,7 +1161,7 @@
 void KLauncher::reparseConfiguration()
 {
    KProtocolManager::reparseConfiguration();
-   foreach (IdleSlave *slave, mSlaveList)
+   Q_FOREACH (IdleSlave *slave, mSlaveList)
       slave->reparseConfiguration();
 }
 
@@ -1180,7 +1180,7 @@
     KProcess *p = static_cast<KProcess *>(sender());
     kDebug(7016) << "process finished exitcode=" << exitCode << "exitStatus=" << exitStatus;
     
-    foreach (KLaunchRequest *request, requestList)
+    Q_FOREACH (KLaunchRequest *request, requestList)
     {
         if (request->process == p) 
         {
Index: kinit/kinit.cpp
===================================================================
--- kinit/kinit.cpp	(revisión: 797670)
+++ kinit/kinit.cpp	(copia de trabajo)
@@ -518,7 +518,7 @@
               environ[tmp_env_count];
               tmp_env_count++)
              unset_envs.append( environ[ tmp_env_count ] );
-         foreach(const QByteArray &tmp, unset_envs)
+         Q_FOREACH(const QByteArray &tmp, unset_envs)
          {
              int pos = tmp.indexOf( '=' );
              if( pos >= 0 )
Index: kinit/kinit_win.cpp
===================================================================
--- kinit/kinit_win.cpp	(revisión: 797670)
+++ kinit/kinit_win.cpp	(copia de trabajo)
@@ -190,7 +190,7 @@
 ProcessList::~ProcessList()
 {
     ProcessListEntry *ple;
-    foreach(ple,processList) {
+    Q_FOREACH(ple,processList) {
         CloseHandle(ple->handle);
         delete ple;
     }
@@ -200,7 +200,7 @@
 void ProcessList::dumpList()
 {
     ProcessListEntry *ple;
-    foreach(ple,processList) {
+    Q_FOREACH(ple,processList) {
         fprintf(stdout,"%s    (PID: %u)\n", ple->name.toLatin1().data(), ple->pid);
     }
 }
@@ -211,7 +211,7 @@
 ProcessListEntry *ProcessList::hasProcessInList(const QString &name)
 {
     ProcessListEntry *ple;
-    foreach(ple,processList) {
+    Q_FOREACH(ple,processList) {
         if (ple->name == name || ple->name == name + ".exe") {
             if (verbose)
                 fprintf(stderr,"found %s with pid=%d\n",qPrintable(ple->name),ple->pid);
@@ -288,7 +288,7 @@
             appList << KDED_EXENAME << KNOTIFY_EXENAME << "nepomukdaemon" 
                       << "kuiserver"  << "kioslave" << "klauncher" << "dbus-daemon";
 
-            foreach(QString app, appList)
+            Q_FOREACH(QString app, appList)
                 processList.terminateProcess(app);
             exit(0);
         }
@@ -351,7 +351,7 @@
         QProcess *proc;
         int can_exit=1;
         do {
-           foreach(proc,startedProcesses) {
+           Q_FOREACH(proc,startedProcesses) {
              if (proc->state() != QProcess::NotRunning)
                 can_exit = 0;
            }
Index: kio/kio/kdesktopfileactions.cpp
===================================================================
--- kio/kio/kdesktopfileactions.cpp	(revisión: 797670)
+++ kio/kio/kdesktopfileactions.cpp	(copia de trabajo)
@@ -229,7 +229,7 @@
 
     // Now, either keys is empty (all actions) or it's set to the actions we want
 
-    foreach(const KServiceAction& action, service.actions()) {
+    Q_FOREACH(const KServiceAction& action, service.actions()) {
         if (keys.isEmpty() || keys.contains(action.name())) {
             const QString exec = action.exec();
             if (bLocalFiles || exec.contains("%U") || exec.contains("%u")) {
Index: kio/kio/tcpslavebase.cpp
===================================================================
--- kio/kio/tcpslavebase.cpp	(revisión: 797670)
+++ kio/kio/tcpslavebase.cpp	(copia de trabajo)
@@ -433,12 +433,12 @@
     //TODO Qt 4.4 actually has non-null certificates in QSslError::certificate() so
     //     we should use that then
     QString errorStr;
-    foreach(const KSslError &se, d->socket.sslErrors())
+    Q_FOREACH(const KSslError &se, d->socket.sslErrors())
         errorStr += QString::number(static_cast<int>(se.error())) + '\n';
     setMetaData("ssl_cert_errors", errorStr);
 
     QString peerCertChain;
-    foreach (const QSslCertificate &cert, d->socket.peerCertificateChain()) {
+    Q_FOREACH (const QSslCertificate &cert, d->socket.peerCertificateChain()) {
         peerCertChain.append(cert.toPem());
         peerCertChain.append('\x01');
     }
@@ -678,7 +678,7 @@
     QString message = i18n("The server failed the authenticity check (%1).\n\n",
                            d->host);
 
-    foreach (const KSslError &err, se) {
+    Q_FOREACH (const KSslError &err, se) {
         //### use our own wording that is "closer to the user"
         message.append(err.errorString());
         message.append('\n');
Index: kio/kio/metainfojob.cpp
===================================================================
--- kio/kio/metainfojob.cpp	(revisión: 797670)
+++ kio/kio/metainfojob.cpp	(copia de trabajo)
@@ -164,7 +164,7 @@
 KIO_EXPORT MetaInfoJob *KIO::fileMetaInfo( const KUrl::List &items)
 {
     KFileItemList fileItems;
-    foreach (const KUrl& url, items) {
+    Q_FOREACH (const KUrl& url, items) {
         fileItems.append(KFileItem(KFileItem::Unknown, KFileItem::Unknown, url,
             true));
     }
Index: kio/kio/delegateanimationhandler.cpp
===================================================================
--- kio/kio/delegateanimationhandler.cpp	(revisión: 797670)
+++ kio/kio/delegateanimationhandler.cpp	(copia de trabajo)
@@ -191,7 +191,7 @@
 
     if (list)
     {
-        foreach (AnimationState *state, *list)
+        Q_FOREACH (AnimationState *state, *list)
             if (state->index == index)
                 return state;
     }
Index: kio/kio/kurifilter.cpp
===================================================================
--- kio/kio/kurifilter.cpp	(revisión: 797670)
+++ kio/kio/kurifilter.cpp	(copia de trabajo)
@@ -400,7 +400,7 @@
 {
     const KService::List offers = KServiceTypeTrader::self()->query( "KUriFilter/Plugin" );
 
-    foreach (const KService::Ptr ptr, offers) {
+    Q_FOREACH (const KService::Ptr ptr, offers) {
         KUriFilterPlugin *plugin = ptr->createInstance<KUriFilterPlugin>();
         if (!plugin)
             continue;
Index: kio/kio/kdirwatch.cpp
===================================================================
--- kio/kio/kdirwatch.cpp	(revisión: 797670)
+++ kio/kio/kdirwatch.cpp	(copia de trabajo)
@@ -350,7 +350,7 @@
  */
 void KDirWatchPrivate::Entry::propagate_dirty()
 {
-  foreach(Entry *sub_entry, m_entries)
+  Q_FOREACH(Entry *sub_entry, m_entries)
   {
      if (!sub_entry->dirty)
      {
@@ -370,7 +370,7 @@
   if (instance == 0)
     return;
 
-  foreach(Client* client, m_clients) {
+  Q_FOREACH(Client* client, m_clients) {
     if (client->instance == instance) {
       client->count++;
       client->m_watchModes = watchModes;
@@ -409,7 +409,7 @@
 int KDirWatchPrivate::Entry::clients()
 {
   int clients = 0;
-  foreach(Client* client, m_clients)
+  Q_FOREACH(Client* client, m_clients)
     clients += client->count;
 
   return clients;
@@ -531,7 +531,7 @@
     mask |= IN_ONLYDIR;
 
   // if dependant is a file watch, we check for MODIFY & ATTRIB too
-  foreach(Entry *dep, e->m_entries) {
+  Q_FOREACH(Entry *dep, e->m_entries) {
     if (!dep->isDir) { mask |= IN_MODIFY|IN_ATTRIB; break; }
   }
 
@@ -859,7 +859,7 @@
   EntryMap::Iterator it = m_mapEntries.begin();
   for( ; it != m_mapEntries.end(); ++it ) {
     Client* c = 0;
-    foreach(Client* client, (*it).m_clients) {
+    Q_FOREACH(Client* client, (*it).m_clients) {
       if (client->instance == instance) {
         c = client;
         break;
@@ -873,7 +873,7 @@
       minfreq = (*it).freq;
   }
 
-  foreach(const QString &path, pathList)
+  Q_FOREACH(const QString &path, pathList)
     removeEntry(instance, path, 0);
 
   if (minfreq > freq) {
@@ -888,7 +888,7 @@
 bool KDirWatchPrivate::stopEntryScan( KDirWatch* instance, Entry* e)
 {
   int stillWatching = 0;
-  foreach(Client* client, e->m_clients) {
+  Q_FOREACH(Client* client, e->m_clients) {
     if (!instance || instance == client->instance)
       client->watchingStopped = true;
     else if (!client->watchingStopped)
@@ -915,7 +915,7 @@
 					 bool notify)
 {
   int wasWatching = 0, newWatching = 0;
-  foreach(Client* client, e->m_clients) {
+  Q_FOREACH(Client* client, e->m_clients) {
     if (!client->watchingStopped)
       wasWatching += client->count;
     else if (!instance || instance == client->instance) {
@@ -990,7 +990,7 @@
   EntryMap::Iterator it = m_mapEntries.begin();
   for( ; it != m_mapEntries.end(); ++it ) {
 
-    foreach(Client* client, (*it).m_clients) {
+    Q_FOREACH(Client* client, (*it).m_clients) {
       if (!client->watchingStopped || skippedToo)
         client->pending = NoChange;
     }
@@ -1102,7 +1102,7 @@
 #endif
   }
 
-  foreach(Client* c, e->m_clients)
+  Q_FOREACH(Client* c, e->m_clients)
   {
     if (c->instance==0 || c->count==0) continue;
 
@@ -1353,7 +1353,7 @@
                                            fe->filename));
 
         Entry* sub_entry = 0;
-        foreach(sub_entry, e->m_entries)
+        Q_FOREACH(sub_entry, e->m_entries)
           if (sub_entry->path == tpath) break;
 
         if (sub_entry && sub_entry->isDir) {
@@ -1429,7 +1429,7 @@
                         (e->m_mode == StatMode) ? "Stat" : "Unknown Method")
                     << ")";
 
-      foreach(Client* c, e->m_clients) {
+      Q_FOREACH(Client* c, e->m_clients) {
         QString pending;
         if (c->watchingStopped) {
           if (c->pending & Deleted) pending += "deleted ";
@@ -1443,7 +1443,7 @@
       }
       if (e->m_entries.count()>0) {
         kDebug(7001) << "    dependent entries:";
-        foreach(Entry *d, e->m_entries) {
+        Q_FOREACH(Entry *d, e->m_entries) {
           kDebug(7001) << "      " << d->path;
         }
       }
@@ -1623,7 +1623,7 @@
   if (!e)
      return false;
 
-  foreach(KDirWatchPrivate::Client* client, e->m_clients) {
+  Q_FOREACH(KDirWatchPrivate::Client* client, e->m_clients) {
     if (client->instance == this)
       return true;
   }
Index: kio/kio/renamedialog.cpp
===================================================================
--- kio/kio/renamedialog.cpp	(revisión: 797670)
+++ kio/kio/renamedialog.cpp	(copia de trabajo)
@@ -162,7 +162,7 @@
         if(!plugin_offers.isEmpty() ){
             RenameDialogPlugin::FileItem src( _src, d->mimeSrc, sizeSrc, ctimeSrc, mtimeSrc );
             RenameDialogPlugin::FileItem dst( _dest,d->mimeDest, sizeDest, ctimeDest, mtimeDest );
-            foreach (const KService::Ptr ptr, plugin_offers) {
+            Q_FOREACH (const KService::Ptr ptr, plugin_offers) {
                 RenameDialogPlugin *plugin = ptr->createInstance<RenameDialogPlugin>(this);
                 if( !plugin )
                     continue;
Index: kio/kio/kfileitemdelegate.cpp
===================================================================
--- kio/kio/kfileitemdelegate.cpp	(revisión: 797670)
+++ kio/kio/kfileitemdelegate.cpp	(copia de trabajo)
@@ -225,7 +225,7 @@
     if (informationList.isEmpty() || item.isNull() || !isListView(option))
         return string;
 
-    foreach (KFileItemDelegate::Information info, informationList)
+    Q_FOREACH (KFileItemDelegate::Information info, informationList)
     {
         if (info == KFileItemDelegate::NoInformation)
             continue;
@@ -278,7 +278,7 @@
             default:
                 break;
         } // switch (info)
-    } // foreach (info, list)
+    } // Q_FOREACH (info, list)
 
     return string;
 }
Index: kio/kio/kdirlister.cpp
===================================================================
--- kio/kio/kdirlister.cpp	(revisión: 797670)
+++ kio/kio/kdirlister.cpp	(copia de trabajo)
@@ -563,10 +563,10 @@
         killJob( job );
         killed = true;
 
-        foreach ( KDirLister *kdl, listers )
+        Q_FOREACH ( KDirLister *kdl, listers )
             kdl->d->jobDone( job );
 
-        foreach ( KDirLister *kdl, holders )
+        Q_FOREACH ( KDirLister *kdl, holders )
             kdl->d->jobDone( job );
     }
     if (killed) {
@@ -588,14 +588,14 @@
 
     kDebug(7004) << "update started in" << _dir;
 
-    foreach ( KDirLister *kdl, listers ) {
+    Q_FOREACH ( KDirLister *kdl, listers ) {
         kdl->d->jobStarted( job );
     }
 
     if ( !holders.isEmpty() ) {
         if ( !killed ) {
             bool first = true;
-            foreach ( KDirLister *kdl, holders ) {
+            Q_FOREACH ( KDirLister *kdl, holders ) {
                 kdl->d->jobStarted( job );
                 if ( first && kdl->d->window ) {
                     first = false;
@@ -606,7 +606,7 @@
         } else {
             job->ui()->setWindow( window );
 
-            foreach ( KDirLister *kdl, holders ) {
+            Q_FOREACH ( KDirLister *kdl, holders ) {
                 kdl->d->jobStarted( job );
             }
         }
@@ -731,7 +731,7 @@
     if ( !fileitem.isNull() ) {
         DirectoryDataHash::iterator dit = directoryData.find(parentDir.url());
         if ( dit != directoryData.end() ) {
-            foreach ( KDirLister *kdl, (*dit).listersCurrentlyHolding )
+            Q_FOREACH ( KDirLister *kdl, (*dit).listersCurrentlyHolding )
                 kdl->d->emitDeleteItem( fileitem );
         }
     }
@@ -845,11 +845,11 @@
     if (dit == directoryData.end())
         return;
 
-    foreach (KDirLister *kdl, (*dit).listersCurrentlyHolding)
+    Q_FOREACH (KDirLister *kdl, (*dit).listersCurrentlyHolding)
         kdl->d->aboutToRefreshItem( fileitem );
 
     // Also look in listersCurrentlyListing, in case the user manages to rename during a listing
-    foreach (KDirLister *kdl, (*dit).listersCurrentlyListing)
+    Q_FOREACH (KDirLister *kdl, (*dit).listersCurrentlyListing)
         kdl->d->aboutToRefreshItem( fileitem );
 }
 
@@ -863,7 +863,7 @@
     if (dit == directoryData.end())
         return;
     // Also look in listersCurrentlyListing, in case the user manages to rename during a listing
-    foreach ( KDirLister *kdl, (*dit).listersCurrentlyHolding + (*dit).listersCurrentlyListing )
+    Q_FOREACH ( KDirLister *kdl, (*dit).listersCurrentlyHolding + (*dit).listersCurrentlyListing )
     {
         kdl->d->addRefreshItem( oldItem, fileitem );
         kdl->d->emitItems();
@@ -937,7 +937,7 @@
 
     // check if anyone wants the mimetypes immediately
     bool delayedMimeTypes = true;
-    foreach ( KDirLister *kdl, dirData.listersCurrentlyListing )
+    Q_FOREACH ( KDirLister *kdl, dirData.listersCurrentlyListing )
         delayedMimeTypes &= kdl->d->delayedMimeTypes;
 
     KIO::UDSEntryList::const_iterator it = entries.begin();
@@ -955,7 +955,7 @@
             Q_ASSERT( dir->rootItem.isNull() );
             dir->rootItem = KFileItem( *it, url, delayedMimeTypes, true  );
 
-            foreach ( KDirLister *kdl, dirData.listersCurrentlyListing )
+            Q_FOREACH ( KDirLister *kdl, dirData.listersCurrentlyListing )
                 if ( kdl->d->rootFileItem.isNull() && kdl->d->url == url )
                     kdl->d->rootFileItem = dir->rootItem;
         }
@@ -966,12 +966,12 @@
             //kDebug(7004)<< "Adding item: " << item.url();
             dir->lstItems.append( item );
 
-            foreach ( KDirLister *kdl, dirData.listersCurrentlyListing )
+            Q_FOREACH ( KDirLister *kdl, dirData.listersCurrentlyListing )
                 kdl->d->addNewItem( item );
         }
     }
 
-    foreach ( KDirLister *kdl, dirData.listersCurrentlyListing )
+    Q_FOREACH ( KDirLister *kdl, dirData.listersCurrentlyListing )
         kdl->d->emitItems();
 }
 
@@ -1005,7 +1005,7 @@
 
   if ( job->error() )
   {
-    foreach ( KDirLister *kdl, listers )
+    Q_FOREACH ( KDirLister *kdl, listers )
     {
       kdl->d->jobDone( job );
       kdl->handleError( job );
@@ -1023,7 +1023,7 @@
     Q_ASSERT( dir );
     dir->complete = true;
 
-    foreach ( KDirLister* kdl, listers )
+    Q_FOREACH ( KDirLister* kdl, listers )
     {
       kdl->d->jobDone( job );
       emit kdl->completed( jobUrl );
@@ -1086,14 +1086,14 @@
     const QList<KDirLister *> listers = oldDirData.listersCurrentlyListing;
     Q_ASSERT( !listers.isEmpty() );
 
-    foreach ( KDirLister *kdl, listers ) {
+    Q_FOREACH ( KDirLister *kdl, listers ) {
         kdl->d->redirect(oldUrlStr, newUrl);
     }
 
     // when a lister was stopped before the job emits the redirection signal, the old url will
     // also be in listersCurrentlyHolding
     const QList<KDirLister *> holders = oldDirData.listersCurrentlyHolding;
-    foreach ( KDirLister *kdl, holders ) {
+    Q_FOREACH ( KDirLister *kdl, holders ) {
         kdl->d->jobStarted( job );
         // do it like when starting a new list-job that will redirect later
         // TODO: maybe don't emit started if there's an update running for newUrl already?
@@ -1123,7 +1123,7 @@
 
             Q_ASSERT( oldJob );  // ?!
 
-            foreach ( KDirLister *kdl, curListers ) { // listers of newUrl
+            Q_FOREACH ( KDirLister *kdl, curListers ) { // listers of newUrl
                 kdl->d->jobDone( oldJob );
 
                 kdl->d->jobStarted( job );
@@ -1131,7 +1131,7 @@
             }
 
             // append listers of oldUrl with newJob to listers of newUrl with oldJob
-            foreach ( KDirLister *kdl, listers )
+            Q_FOREACH ( KDirLister *kdl, listers )
                 curListers.append( kdl );
         } else {
             curListers = listers;
@@ -1145,13 +1145,13 @@
         if ( !curHolders.isEmpty() ) {
             kDebug(7004) << "and it is currently held.";
 
-            foreach ( KDirLister *kdl, curHolders ) {  // holders of newUrl
+            Q_FOREACH ( KDirLister *kdl, curHolders ) {  // holders of newUrl
                 kdl->d->jobStarted( job );
                 emit kdl->started( newUrl );
             }
 
             // append holders of oldUrl to holders of newUrl
-            foreach ( KDirLister *kdl, holders )
+            Q_FOREACH ( KDirLister *kdl, holders )
                 curHolders.append( kdl );
         } else {
             curHolders = holders;
@@ -1160,7 +1160,7 @@
 
         // emit old items: listers, holders. NOT: newUrlListers/newUrlHolders, they already have them listed
         // TODO: make this a separate method?
-        foreach ( KDirLister *kdl, listers + holders ) {
+        Q_FOREACH ( KDirLister *kdl, listers + holders ) {
             if ( kdl->d->rootFileItem.isNull() && kdl->d->url == newUrl )
                 kdl->d->rootFileItem = newDir->rootItem;
 
@@ -1177,7 +1177,7 @@
         newDirData.listersCurrentlyHolding = holders;
 
         // emit old items: listers, holders
-        foreach ( KDirLister *kdl, listers + holders ) {
+        Q_FOREACH ( KDirLister *kdl, listers + holders ) {
             if ( kdl->d->rootFileItem.isNull() && kdl->d->url == newUrl )
                 kdl->d->rootFileItem = newDir->rootItem;
 
@@ -1276,7 +1276,7 @@
     }
 
     // Do the inserts out of the loop to avoid messing up iterators
-    foreach(const ItemToInsert& i, itemsToInsert) {
+    Q_FOREACH(const ItemToInsert& i, itemsToInsert) {
         itemsInUse.insert(i.first, i.second);
     }
 
@@ -1307,7 +1307,7 @@
     DirectoryData& newDirData = directoryData[newUrlStr];
 
     // Tell the world that the job listing the old url is dead.
-    foreach ( KDirLister *kdl, listers ) {
+    Q_FOREACH ( KDirLister *kdl, listers ) {
         if ( job )
             kdl->d->jobDone( job );
 
@@ -1316,7 +1316,7 @@
     newDirData.listersCurrentlyListing += listers;
 
     // Check if we are currently displaying this directory (odds opposite wrt above)
-    foreach ( KDirLister *kdl, holders ) {
+    Q_FOREACH ( KDirLister *kdl, holders ) {
         if ( job )
             kdl->d->jobDone( job );
     }
@@ -1327,12 +1327,12 @@
         updateDirectory( newUrl );
 
         // Tell the world about the new url
-        foreach ( KDirLister *kdl, listers )
+        Q_FOREACH ( KDirLister *kdl, listers )
             emit kdl->started( newUrl );
     }
 
     // And notify the dirlisters of the redirection
-    foreach ( KDirLister *kdl, holders ) {
+    Q_FOREACH ( KDirLister *kdl, holders ) {
         // ### consider replacing this block with kdl->redirect(oldUrl, newUrl)...
         KUrl::List& lstDirs = kdl->d->lstDirs;
         lstDirs[ lstDirs.indexOf( oldUrl ) ] = newUrl;
@@ -1348,7 +1348,7 @@
 {
     kDebug(7004) << dir;
     const QList<QString> cachedDirs = itemsCached.keys(); // seems slow, but there's no qcache iterator...
-    foreach(const QString& cachedDir, cachedDirs) {
+    Q_FOREACH(const QString& cachedDir, cachedDirs) {
         if ( dir.isParentOf( KUrl( cachedDir ) ) )
             itemsCached.remove( cachedDir );
     }
@@ -1378,7 +1378,7 @@
 
     if ( !tmpLst.isEmpty() ) {
         if ( !listers.isEmpty() ) {
-            foreach ( KDirLister* kdl, tmpLst )
+            Q_FOREACH ( KDirLister* kdl, tmpLst )
             {
                 Q_ASSERT( !listers.contains( kdl ) );
                 listers.append( kdl );
@@ -1392,7 +1392,7 @@
     Q_ASSERT( !listers.isEmpty() );
 
     if ( job->error() ) {
-        foreach ( KDirLister* kdl, listers ) {
+        Q_FOREACH ( KDirLister* kdl, listers ) {
             kdl->d->jobDone( job );
 
             //don't bother the user
@@ -1420,7 +1420,7 @@
 
     // check if anyone wants the mimetypes immediately
     bool delayedMimeTypes = true;
-    foreach ( KDirLister *kdl, listers )
+    Q_FOREACH ( KDirLister *kdl, listers )
         delayedMimeTypes &= kdl->d->delayedMimeTypes;
 
     QHash<QString, KFileItem*> fileItems; // fileName -> KFileItem*
@@ -1456,7 +1456,7 @@
             {
                 dir->rootItem = item;
 
-                foreach ( KDirLister *kdl, listers )
+                Q_FOREACH ( KDirLister *kdl, listers )
                     if ( kdl->d->rootFileItem.isNull() && kdl->d->url == jobUrl )
                         kdl->d->rootFileItem = dir->rootItem;
             }
@@ -1470,14 +1470,14 @@
             // check if something changed for this file
             if ( !tmp->cmp( item ) )
             {
-                foreach ( KDirLister *kdl, listers )
+                Q_FOREACH ( KDirLister *kdl, listers )
                     kdl->d->aboutToRefreshItem( *tmp );
 
                 // kDebug(7004) << "slotUpdateResult: file changed: " << tmp->name();
 
                 const KFileItem oldItem = *tmp;
                 *tmp = item;
-                foreach ( KDirLister *kdl, listers )
+                Q_FOREACH ( KDirLister *kdl, listers )
                     kdl->d->addRefreshItem( oldItem, *tmp );
             }
             tmp->mark();
@@ -1490,7 +1490,7 @@
             pitem.mark();
             dir->lstItems.append( pitem );
 
-            foreach ( KDirLister *kdl, listers )
+            Q_FOREACH ( KDirLister *kdl, listers )
                 kdl->d->addNewItem( pitem );
         }
     }
@@ -1499,7 +1499,7 @@
 
     deleteUnmarkedItems( listers, dir->lstItems );
 
-    foreach ( KDirLister *kdl, listers ) {
+    Q_FOREACH ( KDirLister *kdl, listers ) {
         kdl->d->emitItems();
 
         kdl->d->jobDone( job );
@@ -1558,7 +1558,7 @@
     if ( !item.isMarked() )
     {
       //kDebug() << item->name();
-      foreach ( KDirLister *kdl, listers )
+      Q_FOREACH ( KDirLister *kdl, listers )
         kdl->d->emitDeleteItem( item );
 
       if ( item.isDir() )
@@ -1588,21 +1588,21 @@
         }
     }
 
-    foreach(const KUrl& deletedUrl, affectedItems) {
+    Q_FOREACH(const KUrl& deletedUrl, affectedItems) {
         const QString deletedUrlStr = deletedUrl.url();
         // stop all jobs for deletedUrlStr
         DirectoryDataHash::iterator dit = directoryData.find(deletedUrlStr);
         if (dit != directoryData.end()) {
             // we need a copy because stop modifies the list
             QList<KDirLister *> listers = (*dit).listersCurrentlyListing;
-            foreach ( KDirLister *kdl, listers )
+            Q_FOREACH ( KDirLister *kdl, listers )
                 stop( kdl, deletedUrl );
             // tell listers holding deletedUrl to forget about it
             // this will stop running updates for deletedUrl as well
 
             // we need a copy because forgetDirs modifies the list
             QList<KDirLister *> holders = (*dit).listersCurrentlyHolding;
-            foreach ( KDirLister *kdl, holders ) {
+            Q_FOREACH ( KDirLister *kdl, holders ) {
                 // lister's root is the deleted item
                 if ( kdl->d->url == deletedUrl )
                 {
@@ -1642,7 +1642,7 @@
 // delayed updating of files, FAM is flooding us with events
 void KDirListerCache::processPendingUpdates()
 {
-    foreach(const QString& file, pendingUpdates) {
+    Q_FOREACH(const QString& file, pendingUpdates) {
         kDebug(7004) << file;
         KUrl u(file);
         KFileItem *item = findByUrl( 0, u ); // search all items
@@ -1676,12 +1676,12 @@
     for ( ; dit != directoryData.end(); ++dit )
     {
         QString list;
-        foreach ( KDirLister* listit, (*dit).listersCurrentlyListing )
+        Q_FOREACH ( KDirLister* listit, (*dit).listersCurrentlyListing )
             list += " 0x" + QString::number( (long)listit, 16 );
         kDebug(7004) << "   " << dit.key()  << "  " << (*dit).listersCurrentlyListing.count() << " listers: " << list;
 
         list.clear();
-        foreach ( KDirLister* listit, (*dit).listersCurrentlyHolding )
+        Q_FOREACH ( KDirLister* listit, (*dit).listersCurrentlyHolding )
             list += " 0x" + QString::number( (long)listit, 16 );
         kDebug(7004) << "   " << dit.key() << "  " << (*dit).listersCurrentlyHolding.count() << " holders: " << list;
     }
@@ -1693,7 +1693,7 @@
 
     kDebug(7004) << "Items in cache: ";
     const QList<QString> cachedDirs = itemsCached.keys();
-    foreach(const QString& cachedDir, cachedDirs) {
+    Q_FOREACH(const QString& cachedDir, cachedDirs) {
         DirItem* dirItem = itemsCached.object(cachedDir);
         kDebug(7004) << "   " << cachedDir << "rootItem:"
                      << (!dirItem->rootItem.isNull() ? dirItem->rootItem.url().prettyUrl() : QString("NULL") )
Index: kio/kio/kimageio.cpp
===================================================================
--- kio/kio/kimageio.cpp	(revisión: 797670)
+++ kio/kio/kimageio.cpp	(copia de trabajo)
@@ -21,7 +21,7 @@
 
     const KService::List services = KServiceTypeTrader::self()->query("QImageIOPlugins");
     KService::Ptr service;
-    foreach(service, services)
+    Q_FOREACH(service, services)
     {
         if ( (service->property("X-KDE-Read").toBool() && mode == Reading) ||
              (service->property("X-KDE-Write").toBool() && mode == Writing ) ) {
@@ -56,7 +56,7 @@
 
     KService::List services = KServiceTypeTrader::self()->query("QImageIOPlugins");
     KService::Ptr service;
-    foreach(service, services) {
+    Q_FOREACH(service, services) {
         if ( mimeType == service->property("X-KDE-MimeType").toString() )
             return ( service->property("X-KDE-ImageFormat").toStringList() );
     }
@@ -69,7 +69,7 @@
 
     KService::List services = KServiceTypeTrader::self()->query("QImageIOPlugins");
     KService::Ptr service;
-    foreach(service, services) {
+    Q_FOREACH(service, services) {
         if ( (service->property("X-KDE-Read").toBool() && mode == Reading) ||
              (service->property("X-KDE-Write").toBool() && mode == Writing ) ) {
 
@@ -87,7 +87,7 @@
     QStringList imagetypes;
     KService::List services = KServiceTypeTrader::self()->query("QImageIOPlugins");
     KService::Ptr service;
-    foreach(service, services) {
+    Q_FOREACH(service, services) {
         if ( (service->property("X-KDE-Read").toBool() && mode == Reading) ||
              (service->property("X-KDE-Write").toBool() && mode == Writing ) ) {
 
@@ -104,7 +104,7 @@
 
     KService::List services = KServiceTypeTrader::self()->query("QImageIOPlugins");
     KService::Ptr service;
-    foreach(service, services) {
+    Q_FOREACH(service, services) {
         if ( mimeType == service->property("X-KDE-MimeType").toString() ) {
 
             if ( (service->property("X-KDE-Read").toBool() && mode == Reading) ||
Index: kio/kio/kprotocolmanager.cpp
===================================================================
--- kio/kio/kprotocolmanager.cpp	(revisión: 797670)
+++ kio/kio/kprotocolmanager.cpp	(copia de trabajo)
@@ -545,7 +545,7 @@
   KConfig acclangConf("accept-languages.codes", KConfig::NoGlobals);
   KConfigGroup replacementCodes(&acclangConf, "ReplacementCodes");
   QStringList languageListFinal;
-  foreach (const QString &lang, languageList)
+  Q_FOREACH (const QString &lang, languageList)
   {
     QStringList langs = replacementCodes.readEntry(lang, QStringList());
     if (langs.isEmpty())
Index: kio/kio/kmimetypechooser.cpp
===================================================================
--- kio/kio/kmimetypechooser.cpp	(revisión: 797670)
+++ kio/kio/kmimetypechooser.cpp	(copia de trabajo)
@@ -140,7 +140,7 @@
   QTreeWidgetItem *idefault = 0; //open this, if all other fails
   QTreeWidgetItem *firstChecked = 0; // make this one visible after the loop
 
-  foreach (const KMimeType::Ptr& mt, mimetypes)
+  Q_FOREACH (const KMimeType::Ptr& mt, mimetypes)
   {
     const QString mimetype = mt->name();
     const int index = mimetype.indexOf('/');
@@ -253,7 +253,7 @@
     QStringList mimeList;
     QList<QTreeWidgetItem *> checkedItems;
     getCheckedItems(checkedItems, d->mimeTypeTree);
-    foreach(QTreeWidgetItem* item, checkedItems) {
+    Q_FOREACH(QTreeWidgetItem* item, checkedItems) {
         mimeList.append( item->parent()->text(0) + '/' + item->text(0) );
     }
     return mimeList;
@@ -264,7 +264,7 @@
     QStringList patternList;
     QList<QTreeWidgetItem *> checkedItems;
     getCheckedItems(checkedItems, d->mimeTypeTree);
-    foreach(QTreeWidgetItem* item, checkedItems) {
+    Q_FOREACH(QTreeWidgetItem* item, checkedItems) {
         KMimeType::Ptr p = KMimeType::mimeType( item->parent()->text(0) + '/' + item->text(0) );
         Q_ASSERT(p);
         patternList += p->patterns();
Index: kio/kio/slaveinterface.cpp
===================================================================
--- kio/kio/slaveinterface.cpp	(revisión: 797670)
+++ kio/kio/slaveinterface.cpp	(copia de trabajo)
@@ -445,7 +445,7 @@
         QStringList sl = meta["ssl_peer_chain"].split('\x01', QString::SkipEmptyParts);
         QList<QSslCertificate> certChain;
         bool decodedOk = true;
-        foreach (const QString &s, sl) {
+        Q_FOREACH (const QString &s, sl) {
             certChain.append(QSslCertificate(s.toAscii())); //or is it toLocal8Bit or whatever?
             if (certChain.last().isNull()) {
                 decodedOk = false;
@@ -455,7 +455,7 @@
 
         sl = meta["ssl_cert_errors"].split('\n', QString::SkipEmptyParts);
         QList<QSslError::SslError> errors;
-        foreach (const QString &s, sl) {
+        Q_FOREACH (const QString &s, sl) {
             bool didConvert;
             QSslError::SslError error = static_cast<QSslError::SslError>(s.toInt(&didConvert));
             if (!didConvert) {
Index: kio/kio/kdirmodel.cpp
===================================================================
--- kio/kio/kdirmodel.cpp	(revisión: 797670)
+++ kio/kio/kdirmodel.cpp	(copia de trabajo)
@@ -334,7 +334,7 @@
 
         if (isDir && !urlsBeingFetched.isEmpty()) {
             const KUrl dirUrl = it->url();
-            foreach(const KUrl& urlFetched, urlsBeingFetched) {
+            Q_FOREACH(const KUrl& urlFetched, urlsBeingFetched) {
                 if (dirUrl.isParentOf(urlFetched)) {
                     //kDebug(7008) << "Listing found" << dirUrl << "which is a parent of fetched url" << urlFetched;
                     const QModelIndex parentIndex = indexForNode(node, dirNode->m_childNodes.count()-1);
@@ -602,7 +602,7 @@
 QMimeData * KDirModel::mimeData( const QModelIndexList & indexes ) const
 {
     KUrl::List urls;
-    foreach ( const QModelIndex &index, indexes ) {
+    Q_FOREACH ( const QModelIndex &index, indexes ) {
         urls << d->nodeForIndex( index )->item().url();
     }
     QMimeData *data = new QMimeData();
Index: kio/kio/scheduler.cpp
===================================================================
--- kio/kio/scheduler.cpp	(revisión: 797670)
+++ kio/kio/scheduler.cpp	(copia de trabajo)
@@ -352,7 +352,7 @@
     sessionData->reset();
     NetRC::self()->reload();
 
-    foreach( Slave *slave, slaveList )
+    Q_FOREACH( Slave *slave, slaveList )
     {
         if ( slave->slaveProtocol() == proto || proto.isEmpty() )
         {
@@ -404,7 +404,7 @@
         protInfo->joblist.removeAll(job);
 
         // Search all slaves to see if job is in the queue of a coSlave
-        foreach( Slave* coSlave, slaveList )
+        Q_FOREACH( Slave* coSlave, slaveList )
         {
            JobList *list = coSlaves.value(slave);
            if (list && list->removeAll(job)) {
@@ -611,7 +611,7 @@
     QString user = url.user();
     exact = true;
 
-    foreach( Slave *slave, idleSlaves )
+    Q_FOREACH( Slave *slave, idleSlaves )
     {
        if ((protocol == slave->slaveProtocol()) &&
            (host == slave->host()) &&
@@ -623,7 +623,7 @@
     exact = false;
 
     // Look for slightly matching slave
-    foreach( Slave *slave, idleSlaves )
+    Q_FOREACH( Slave *slave, idleSlaves )
     {
        if (protocol == slave->slaveProtocol())
           return slave;
Index: kio/bookmarks/kbookmarkimporter_ie.cc
===================================================================
--- kio/bookmarks/kbookmarkimporter_ie.cc	(revisión: 797670)
+++ kio/bookmarks/kbookmarkimporter_ie.cc	(copia de trabajo)
@@ -102,7 +102,7 @@
    if (dirname != m_fileName)
       emit newFolder( foldername, false, "" );
 
-   foreach (const QFileInfo &fi, list) {
+   Q_FOREACH (const QFileInfo &fi, list) {
       if (fi.fileName() == "." || fi.fileName() == "..") continue;
 
       if (fi.isDir()) {
Index: kio/bookmarks/kbookmarkimporter_crash.cc
===================================================================
--- kio/bookmarks/kbookmarkimporter_crash.cc	(revisión: 797670)
+++ kio/bookmarks/kbookmarkimporter_crash.cc	(copia de trabajo)
@@ -88,7 +88,7 @@
     QSet<QString> activeLogs;
 
     QStringList apps = QDBusConnection::sessionBus().interface()->registeredServiceNames();
-    foreach ( const QString &clientId, apps )
+    Q_FOREACH ( const QString &clientId, apps )
     {
         if ( !clientId.startsWith( QLatin1String("org.kde.konqueror") ) )
             continue;
Index: kio/kfile/kmetaprops.cpp
===================================================================
--- kio/kfile/kmetaprops.cpp	(revisión: 797670)
+++ kio/kfile/kmetaprops.cpp	(copia de trabajo)
@@ -107,7 +107,7 @@
     QVBoxLayout *toplayout = new QVBoxLayout(d->m_frame);
     toplayout->setSpacing(KDialog::spacingHint());
 
-    foreach (const KFileMetaInfoGroup& group, groupList) {
+    Q_FOREACH (const KFileMetaInfoGroup& group, groupList) {
         //kDebug(7033) << *git;
 
         KFileMetaInfoItemList itemList = group.items();
@@ -124,7 +124,7 @@
         KFileMetaInfoItemList readItems;
         KFileMetaInfoItemList editItems;
 
-        foreach (const KFileMetaInfoItem& item, itemList) {
+        Q_FOREACH (const KFileMetaInfoItem& item, itemList) {
             if ( !item.isValid() ) continue;
 
             bool editable = file_info.isWritable() && item.isEditable();
@@ -138,7 +138,7 @@
         KFileMetaInfoWidget* w = 0L;
         int row = 0;
         // then first add the editable items to the layout
-        foreach (const KFileMetaInfoItem& item, editItems) {
+        Q_FOREACH (const KFileMetaInfoItem& item, editItems) {
             QLabel* l = new QLabel(item.name() + ':', groupBox);
             grouplayout->addWidget(l, row, 0);
             l->setAlignment( Qt::AlignLeft | Qt::AlignTop );
@@ -153,7 +153,7 @@
         }
 
         // and then the read only items
-        foreach (const KFileMetaInfoItem& item, readItems) {
+        Q_FOREACH (const KFileMetaInfoItem& item, readItems) {
             QLabel* l = new QLabel(item.name() + ':', groupBox);
             grouplayout->addWidget(l, row, 0);
             l->setAlignment( Qt::AlignLeft | Qt::AlignTop );
@@ -231,7 +231,7 @@
     kDebug(250) << "applying changes";
     // insert the fields that changed into the info object
 
-    foreach(KFileMetaInfoWidget* w, d->m_editWidgets)
+    Q_FOREACH(KFileMetaInfoWidget* w, d->m_editWidgets)
         w->apply();
     d->m_info.applyChanges();
 }
Index: kio/kfile/kpreviewprops.cpp
===================================================================
--- kio/kfile/kpreviewprops.cpp	(revisión: 797670)
+++ kio/kfile/kpreviewprops.cpp	(copia de trabajo)
@@ -74,7 +74,7 @@
         return false;
     const KMimeType::Ptr mime = _items.first().mimeTypePtr();
     const QStringList supportedMimeTypes = KIO::PreviewJob::supportedMimeTypes();
-    foreach(const QString& supportedMime, supportedMimeTypes) {
+    Q_FOREACH(const QString& supportedMime, supportedMimeTypes) {
         if (mime->is(supportedMime))
     return true;
     }
Index: kio/kfile/kicondialog.cpp
===================================================================
--- kio/kfile/kicondialog.cpp	(revisión: 797670)
+++ kio/kfile/kicondialog.cpp	(copia de trabajo)
@@ -429,14 +429,14 @@
 
     QList<IconPath> iconlist;
     QStringList::Iterator it;
-    foreach (const QString &it, filelist) {
+    Q_FOREACH (const QString &it, filelist) {
        iconlist.append(IconPath(it));
     }
 
     qSort(iconlist);
     filelist.clear();
 
-    foreach (const IconPath &ip, iconlist) {
+    Q_FOREACH (const IconPath &ip, iconlist) {
        filelist.append(ip);
     }
 
Index: kio/kfile/kpropertiesdialog.cpp
===================================================================
--- kio/kfile/kpropertiesdialog.cpp	(revisión: 797670)
+++ kio/kfile/kpropertiesdialog.cpp	(copia de trabajo)
@@ -364,7 +364,7 @@
 
 void KPropertiesDialog::setFileNameReadOnly( bool ro )
 {
-    foreach(KPropertiesDialogPlugin *it, d->m_pageList) {
+    Q_FOREACH(KPropertiesDialogPlugin *it, d->m_pageList) {
         KFilePropsPlugin* plugin = dynamic_cast<KFilePropsPlugin*>(it);
         if ( plugin ) {
             plugin->setFileNameReadOnly( ro );
@@ -558,7 +558,7 @@
 
   kDebug( 250 ) << "trader query: " << query;
   KService::List offers = KMimeTypeTrader::self()->query( mimetype, "KPropertiesDialog/Plugin", query );
-  foreach (const KService::Ptr ptr, offers) {
+  Q_FOREACH (const KService::Ptr ptr, offers) {
     KPropertiesDialogPlugin *plugin = ptr->createInstance<KPropertiesDialogPlugin>(q);
     if (!plugin)
         continue;
@@ -581,7 +581,7 @@
     assert(!d->m_singleUrl.isEmpty());
   // If we have an Desktop page, set it dirty, so that a full file is saved locally
   // Same for a URL page (because of the Name= hack)
-    foreach (KPropertiesDialogPlugin *it, d->m_pageList) {
+    Q_FOREACH (KPropertiesDialogPlugin *it, d->m_pageList) {
    if ( qobject_cast<KUrlPropsPlugin*>(it) ||
         qobject_cast<KDesktopPropsPlugin*>(it) )
    {
@@ -3086,7 +3086,7 @@
 
     if (dlg.exec() == KDialog::Accepted)
     {
-        foreach(const QString &mimetype, dlg.chooser()->mimeTypes())
+        Q_FOREACH(const QString &mimetype, dlg.chooser()->mimeTypes())
         {
             KMimeType::Ptr p = KMimeType::mimeType(mimetype);
             if (!p)
Index: kio/kfile/kdevicelistmodel.cpp
===================================================================
--- kio/kfile/kdevicelistmodel.cpp	(revisión: 797670)
+++ kio/kfile/kdevicelistmodel.cpp	(copia de trabajo)
@@ -193,7 +193,7 @@
                                              Solid::Device::listFromQuery(predicate)
                                            : Solid::Device::allDevices();
 
-    foreach(const Solid::Device &device, deviceList)
+    Q_FOREACH(const Solid::Device &device, deviceList)
     {
         addDevice(device);
     }
@@ -251,7 +251,7 @@
 
     QList<KDeviceListItem*> children = item->children();
 
-    foreach(KDeviceListItem *child, children) {
+    Q_FOREACH(KDeviceListItem *child, children) {
         removeBranch(child->device().udi());
     }
 
Index: kio/misc/kssld/kssld.cpp
===================================================================
--- kio/misc/kssld/kssld.cpp	(revisión: 797670)
+++ kio/misc/kssld/kssld.cpp	(copia de trabajo)
@@ -127,7 +127,7 @@
     if (rule.isRejected()) {
         sl.append("Reject");
     } else {
-        foreach (KSslError::Error e, rule.ignoredErrors())
+        Q_FOREACH (KSslError::Error e, rule.ignoredErrors())
             sl.append(d->sslErrorToString.value(e));
     }
 
@@ -218,7 +218,7 @@
 
     QList<KSslError::Error> ignoredErrors;
     bool isRejected = false;
-    foreach (const QString &s, sl) {
+    Q_FOREACH (const QString &s, sl) {
         if (s == "Reject") {
             isRejected = true;
             ignoredErrors.clear();
Index: kio/misc/kwalletd/kwalletd.cpp
===================================================================
--- kio/misc/kwalletd/kwalletd.cpp	(revisión: 797670)
+++ kio/misc/kwalletd/kwalletd.cpp	(copia de trabajo)
@@ -740,7 +740,7 @@
 
 	dir.setFilter(QDir::Files | QDir::NoSymLinks);
 
-	foreach (const QFileInfo &fi, dir.entryInfoList()) {
+	Q_FOREACH (const QFileInfo &fi, dir.entryInfoList()) {
 		QString fn = fi.fileName();
 		if (fn.endsWith(".kwl")) {
 			fn.truncate(fn.length()-4);
@@ -833,7 +833,7 @@
 	if ((b = getWallet(appid, handle))) {
 		b->setFolder(folder);
 		QVariantMap rc;
-		foreach (KWallet::Entry *entry, b->readEntryList(key)) {
+		Q_FOREACH (KWallet::Entry *entry, b->readEntryList(key)) {
 			if (entry->type() == KWallet::Wallet::Map) {
 				rc.insert(entry->key(), entry->map());
 			}
@@ -866,7 +866,7 @@
 	if ((b = getWallet(appid, handle))) {
 		b->setFolder(folder);
 		QVariantMap rc;
-		foreach (KWallet::Entry *entry, b->readEntryList(key)) {
+		Q_FOREACH (KWallet::Entry *entry, b->readEntryList(key)) {
 			rc.insert(entry->key(), entry->value());
 		}
 		return rc;
@@ -909,7 +909,7 @@
 	if ((b = getWallet(appid, handle))) {
 		b->setFolder(folder);
 		QVariantMap rc;
-		foreach (KWallet::Entry *entry, b->readEntryList(key)) {
+		Q_FOREACH (KWallet::Entry *entry, b->readEntryList(key)) {
 			if (entry->type() == KWallet::Wallet::Password) {
 				rc.insert(entry->key(), entry->password());
 			}
Index: kio/tests/kdirmodeltest.cpp
===================================================================
--- kio/tests/kdirmodeltest.cpp	(revisión: 797670)
+++ kio/tests/kdirmodeltest.cpp	(copia de trabajo)
@@ -65,7 +65,7 @@
      * PATH/subdir/subsubdir/testfile
      */
     const QString path = m_tempDir->name();
-    foreach(const QString &f, m_topLevelFileNames) {
+    Q_FOREACH(const QString &f, m_topLevelFileNames) {
         createTestFile(path+f);
     }
     createTestDirectory(path+"subdir");
Index: kio/tests/kmountpointtest.cpp
===================================================================
--- kio/tests/kmountpointtest.cpp	(revisión: 797670)
+++ kio/tests/kmountpointtest.cpp	(copia de trabajo)
@@ -37,7 +37,7 @@
     const KMountPoint::List mountPoints = KMountPoint::currentMountPoints(KMountPoint::NeedRealDeviceName);
     QVERIFY(!mountPoints.isEmpty());
     KMountPoint::Ptr mountWithDevice;
-    foreach(KMountPoint::Ptr mountPoint, mountPoints) {
+    Q_FOREACH(KMountPoint::Ptr mountPoint, mountPoints) {
         /*kDebug() << "Mount: " << mountPoint->mountedFrom()
           << " (" << mountPoint->realDeviceName() << ") "
           << mountPoint->mountPoint() << " " << mountPoint->mountType() << endl;*/
@@ -92,7 +92,7 @@
     const KMountPoint::List mountPoints = KMountPoint::possibleMountPoints(KMountPoint::NeedRealDeviceName|KMountPoint::NeedMountOptions);
     QVERIFY(!mountPoints.isEmpty());
     KMountPoint::Ptr mountWithDevice;
-    foreach(KMountPoint::Ptr mountPoint, mountPoints) {
+    Q_FOREACH(KMountPoint::Ptr mountPoint, mountPoints) {
         kDebug() << "Possible mount: " << mountPoint->mountedFrom()
           << " (" << mountPoint->realDeviceName() << ") "
           << mountPoint->mountPoint() << " " << mountPoint->mountType()
Index: kio/kssl/ksslcertificatemanager.cpp
===================================================================
--- kio/kssl/ksslcertificatemanager.cpp	(revisión: 797670)
+++ kio/kssl/ksslcertificatemanager.cpp	(copia de trabajo)
@@ -127,7 +127,7 @@
 
 bool KSslCertificateRule::isErrorIgnored(KSslError::Error error) const
 {
-    foreach (KSslError::Error ignoredError, d->ignoredErrors)
+    Q_FOREACH (KSslError::Error ignoredError, d->ignoredErrors)
         if (error == ignoredError)
             return true;
 
@@ -139,7 +139,7 @@
 {
     d->ignoredErrors.clear();
     //### Quadratic runtime, woohoo! Use a QSet if that should ever be an issue.
-    foreach(KSslError::Error e, errors)
+    Q_FOREACH(KSslError::Error e, errors)
         if (!isErrorIgnored(e))
             d->ignoredErrors.append(e);
 }
@@ -148,7 +148,7 @@
 void KSslCertificateRule::setIgnoredErrors(const QList<KSslError> &errors)
 {
     QList<KSslError::Error> el;
-    foreach(const KSslError &e, errors)
+    Q_FOREACH(const KSslError &e, errors)
         el.append(e.error());
     setIgnoredErrors(el);
 }
@@ -163,7 +163,7 @@
 QList<KSslError::Error> KSslCertificateRule::filterErrors(const QList<KSslError::Error> &errors) const
 {
     QList<KSslError::Error> ret;
-    foreach (KSslError::Error error, errors) {
+    Q_FOREACH (KSslError::Error error, errors) {
         if (!isErrorIgnored(error))
             ret.append(error);
     }
@@ -174,7 +174,7 @@
 QList<KSslError> KSslCertificateRule::filterErrors(const QList<KSslError> &errors) const
 {
     QList<KSslError> ret;
-    foreach (const KSslError &error, errors) {
+    Q_FOREACH (const KSslError &error, errors) {
         if (!isErrorIgnored(error.error()))
             ret.append(error);
     }
Index: kio/kssl/ksslcertificate.cpp
===================================================================
--- kio/kssl/ksslcertificate.cpp	(revisión: 797670)
+++ kio/kssl/ksslcertificate.cpp	(copia de trabajo)
@@ -1308,7 +1308,7 @@
     QStringList qsl;
     QList<KSSLCertificate *> cl = const_cast<KSSLCertificate&>(r).chain().getChain();
 
-    foreach(KSSLCertificate *c, cl) {
+    Q_FOREACH(KSSLCertificate *c, cl) {
         qsl << c->toString();
     }
 
Index: kio/kssl/ksmimecrypto.cpp
===================================================================
--- kio/kssl/ksmimecrypto.cpp	(revisión: 797670)
+++ kio/kssl/ksmimecrypto.cpp	(copia de trabajo)
@@ -87,7 +87,7 @@
 
 STACK_OF(X509) *KSMIMECryptoPrivate::certsToX509(const QList<KSSLCertificate *> &certs) {
     STACK_OF(X509) *x509 = sk_new(NULL);
-    foreach(KSSLCertificate *cert, certs) {
+    Q_FOREACH(KSSLCertificate *cert, certs) {
 	sk_X509_push(x509, cert->getCert());
     }
     return x509;
Index: kio/kssl/ksslcertchain.cpp
===================================================================
--- kio/kssl/ksslcertchain.cpp	(revisión: 797670)
+++ kio/kssl/ksslcertchain.cpp	(copia de trabajo)
@@ -152,7 +152,7 @@
 
     if (chain.isEmpty()) return;
     _chain = (void *)sk_new(NULL);
-    foreach (KSSLCertificate *x, chain) {
+    Q_FOREACH (KSSLCertificate *x, chain) {
         sk_X509_push((STACK_OF(X509)*)_chain, d->kossl->X509_dup(x->getCert()));
     }
 
Index: kpty/kptydevice.cpp
===================================================================
--- kpty/kptydevice.cpp	(revisión: 797670)
+++ kpty/kptydevice.cpp	(copia de trabajo)
@@ -96,7 +96,7 @@
         totalSize -= bytes;
         Q_ASSERT(totalSize >= 0);
 
-        forever {
+        Q_FOREVER {
             int nbs = readSize();
 
             if (bytes < nbs) {
@@ -159,7 +159,7 @@
         int index = 0;
         int start = head;
         QLinkedList<QByteArray>::ConstIterator it = buffers.begin();
-        forever {
+        Q_FOREVER {
             if (!maxLength)
                 return index;
             if (index == size())
Index: kdewidgets/makekdewidgets.cpp
===================================================================
--- kdewidgets/makekdewidgets.cpp	(revisión: 797670)
+++ kdewidgets/makekdewidgets.cpp	(copia de trabajo)
@@ -139,16 +139,16 @@
     QStringList classes = input.groupList();
     classes.removeAll( "Global" );
 
-    foreach ( const QString &myInclude, classes )
+    Q_FOREACH ( const QString &myInclude, classes )
       includes += buildWidgetInclude( myInclude, input );
 
-    foreach ( const QString &myInclude, includes)
+    Q_FOREACH ( const QString &myInclude, includes)
         ts << "#include <" << myInclude << ">" << endl;
 
     ts << QLatin1String("\n\n");
 
     // Autogenerate widget defs here
-    foreach ( const QString &myClass, classes )
+    Q_FOREACH ( const QString &myClass, classes )
         ts << buildWidgetClass( myClass, input, group ) << endl;
 
     ts << buildCollClass( input, classes );
@@ -167,7 +167,7 @@
     defMap.insert( "CollName", input.readEntry( "PluginName" ) );
     QString genCode;
 
-    foreach ( const QString &myClass, classes )
+    Q_FOREACH ( const QString &myClass, classes )
     {
       genCode += QString("\t\tm_plugins.append( new %1(this) );\n").arg(denamespace( myClass ) +"Plugin");
     }
Index: kdeui/kernel/kuniqueapplication.cpp
===================================================================
--- kdeui/kernel/kuniqueapplication.cpp	(revisión: 797670)
+++ kdeui/kernel/kuniqueapplication.cpp	(copia de trabajo)
@@ -131,7 +131,7 @@
   if (parts.isEmpty())
      appName.prepend(QLatin1String("local."));
   else
-     foreach (const QString& s, parts)
+     Q_FOREACH (const QString& s, parts)
      {
         appName.prepend(QLatin1Char('.'));
         appName.prepend(s);
Index: kdeui/kernel/kapplication.cpp
===================================================================
--- kdeui/kernel/kapplication.cpp	(revisión: 797670)
+++ kdeui/kernel/kapplication.cpp	(copia de trabajo)
@@ -544,7 +544,7 @@
       if (parts.isEmpty())
           reversedDomain = QLatin1String("local.");
       else
-          foreach (const QString& s, parts)
+          Q_FOREACH (const QString& s, parts)
           {
               reversedDomain.prepend(QLatin1Char('.'));
               reversedDomain.prepend(s);
@@ -685,7 +685,7 @@
     d->session_save = true;
     bool canceled = false;
 
-    foreach (KSessionManager *it, KSessionManager::sessionClients()) {
+    Q_FOREACH (KSessionManager *it, KSessionManager::sessionClients()) {
         if ( ( canceled = !it->commitData( sm ) ) )
             break;
     }
@@ -819,7 +819,7 @@
     // finally: do session management
     emit saveYourself(); // for compatibility
     bool canceled = false;
-    foreach(KSessionManager* it, KSessionManager::sessionClients()) {
+    Q_FOREACH(KSessionManager* it, KSessionManager::sessionClients()) {
       if(canceled) break;
       canceled = !it->saveState( sm );
     }
@@ -999,7 +999,7 @@
     }
 
     if (x11Filter) {
-        foreach (const QWidget *w, *x11Filter) {
+        Q_FOREACH (const QWidget *w, *x11Filter) {
             if (((KAppX11HackWidget*) w)->publicx11Event(_event))
                 return true;
         }
Index: kdeui/dialogs/kdeprintdialog.cpp
===================================================================
--- kdeui/dialogs/kdeprintdialog.cpp	(revisión: 797670)
+++ kdeui/dialogs/kdeprintdialog.cpp	(copia de trabajo)
@@ -52,7 +52,7 @@
             dialog->layout()->addWidget(tabs);
             dialog->layout()->addWidget(buttons);
 
-            foreach(QWidget* tab, customTabs)
+            Q_FOREACH(QWidget* tab, customTabs)
                 tabs->addTab(tab, tab->windowTitle());
         }
     }
Index: kdeui/dialogs/kdialog.cpp
===================================================================
--- kdeui/dialogs/kdialog.cpp	(revisión: 797670)
+++ kdeui/dialogs/kdialog.cpp	(copia de trabajo)
@@ -508,7 +508,7 @@
 
   if ( widget->children().count() > 0 ) {
     QList<QObject*> list = widget->children();
-    foreach ( QObject *object, list ) {
+    Q_FOREACH ( QObject *object, list ) {
       if ( object->isWidgetType() )
         resizeLayout( (QWidget*)object, margin, spacing );
     }
Index: kdeui/dialogs/kedittoolbar.cpp
===================================================================
--- kdeui/dialogs/kedittoolbar.cpp	(revisión: 797670)
+++ kdeui/dialogs/kedittoolbar.cpp	(copia de trabajo)
@@ -98,7 +98,7 @@
     void dump() const
     {
         kDebug(240) << "XmlData" << this << "type" << s_XmlTypeToString[m_type] << "xmlFile:" << m_xmlFile;
-        foreach (const QDomElement& element, m_barList) {
+        Q_FOREACH (const QDomElement& element, m_barList) {
             kDebug(240) << "    ToolBar:" << toolBarText( element );
         }
         if ( m_actionCollection )
@@ -534,7 +534,7 @@
     if ( m_factory )
     {
         const QString localPrefix = KStandardDirs::locateLocal("data", "");
-        foreach (KXMLGUIClient* client, m_factory->clients())
+        Q_FOREACH (KXMLGUIClient* client, m_factory->clients())
         {
             QString file = client->xmlFile();
 
@@ -706,7 +706,7 @@
 
   // add all of the client data
   bool first = true;
-  foreach (KXMLGUIClient* client, factory->clients())
+  Q_FOREACH (KXMLGUIClient* client, factory->clients())
   {
     if (client->xmlFile().isEmpty())
       continue;
@@ -736,7 +736,7 @@
   m_widget->setMinimumSize( m_widget->sizeHint() );
 
   m_widget->actionCollection()->addAssociatedWidget( m_widget );
-  foreach (QAction* action, m_widget->actionCollection()->actions())
+  Q_FOREACH (QAction* action, m_widget->actionCollection()->actions())
     action->setShortcutContext(Qt::WidgetWithChildrenShortcut);
 }
 
@@ -793,7 +793,7 @@
 
   // now, rebuild the gui from the first to the last
   //kDebug(240) << "rebuilding the gui";
-  foreach (KXMLGUIClient* client, clients)
+  Q_FOREACH (KXMLGUIClient* client, clients)
   {
     //kDebug(240) << "updating client " << client << " " << client->componentData().componentName() << "  xmlFile=" << client->xmlFile();
     QString file( client->xmlFile() ); // before setting ui_standards!
@@ -814,7 +814,7 @@
   // Now we can add the clients to the factory
   // We don't do it in the loop above because adding a part automatically
   // adds its plugins, so we must make sure the plugins were updated first.
-  foreach (KXMLGUIClient* client, clients)
+  Q_FOREACH (KXMLGUIClient* client, clients)
     factory()->addClient( client );
 }
 
@@ -1071,7 +1071,7 @@
     // iterate through this client's actions
     // This used to iterate through _all_ actions, but we don't support
     // putting any action into any client...
-    foreach (QAction* action, actionCollection->actions())
+    Q_FOREACH (QAction* action, actionCollection->actions())
     {
       // do we have a match?
       if (it.attribute( attrName ) == action->objectName())
@@ -1088,7 +1088,7 @@
   }
 
   // go through the rest of the collection
-  foreach (QAction* action, actionCollection->actions())
+  Q_FOREACH (QAction* action, actionCollection->actions())
   {
     // skip our active ones
     if (active_list.contains(action->objectName()))
Index: kdeui/dialogs/kconfigdialogmanager.cpp
===================================================================
--- kdeui/dialogs/kconfigdialogmanager.cpp	(revisión: 797670)
+++ kdeui/dialogs/kconfigdialogmanager.cpp	(copia de trabajo)
@@ -208,7 +208,7 @@
   if(listOfChildren.count()==0) //?? XXX
     return valueChanged;
 
-  foreach ( QObject *object, listOfChildren )
+  Q_FOREACH ( QObject *object, listOfChildren )
   {
     if(!object->isWidgetType())
       continue; // Skip non-widgets
Index: kdeui/dialogs/kshortcutseditor.cpp
===================================================================
--- kdeui/dialogs/kshortcutseditor.cpp	(revisión: 797670)
+++ kdeui/dialogs/kshortcutseditor.cpp	(copia de trabajo)
@@ -104,7 +104,7 @@
     hier[Program] = d->findOrMakeItem(hier[Root], title.isEmpty() ? i18n("Shortcuts") : title);
     hier[Group] = d->findOrMakeItem(hier[Program], "if you see this, something went wrong");
 
-    foreach (QAction *action, collection->actions()) {
+    Q_FOREACH (QAction *action, collection->actions()) {
         QString name = action->text().remove('&');
 
         if (name.startsWith(QLatin1String("Program:")))
@@ -143,14 +143,14 @@
     if (d->actionTypes & KShortcutsEditor::GlobalAction) {
         QString groupName = "Global Shortcuts";
         KConfigGroup group( config, groupName );
-        foreach (KActionCollection* collection, d->actionCollections) {
+        Q_FOREACH (KActionCollection* collection, d->actionCollections) {
             collection->importGlobalShortcuts( &group );
         }
     }
     if (d->actionTypes & ~KShortcutsEditor::GlobalAction) {
         QString groupName = "Shortcuts";
         KConfigGroup group( config, groupName );
-        foreach (KActionCollection* collection, d->actionCollections) {
+        Q_FOREACH (KActionCollection* collection, d->actionCollections) {
             collection->readSettings( &group );
         }
     }
@@ -161,14 +161,14 @@
     if (d->actionTypes & KShortcutsEditor::GlobalAction) {
         QString groupName = "Global Shortcuts";
         KConfigGroup group( config, groupName );
-        foreach (KActionCollection* collection, d->actionCollections) {
+        Q_FOREACH (KActionCollection* collection, d->actionCollections) {
             collection->exportGlobalShortcuts( &group, true );
         }
     }
     if (d->actionTypes & ~KShortcutsEditor::GlobalAction) {
         QString groupName = "Shortcuts";
         KConfigGroup group( config, groupName );
-        foreach (KActionCollection* collection, d->actionCollections) {
+        Q_FOREACH (KActionCollection* collection, d->actionCollections) {
             collection->writeSettings( &group, true );
         }
     }
@@ -177,7 +177,7 @@
 
 void KShortcutsEditor::writeConfiguration( KConfigGroup *config) const
 {
-    foreach (KActionCollection* collection, d->actionCollections) {
+    Q_FOREACH (KActionCollection* collection, d->actionCollections) {
         collection->writeSettings(config);
     }
 }
Index: kdeui/fonts/kfontrequester.cpp
===================================================================
--- kdeui/fonts/kfontrequester.cpp	(revisión: 797670)
+++ kdeui/fonts/kfontrequester.cpp	(copia de trabajo)
@@ -59,7 +59,7 @@
             // Find nearest available size.
             int mindiff = 1000;
             int refsize = size;
-            foreach (int lsize, sizes) {
+            Q_FOREACH (int lsize, sizes) {
                 int diff = qAbs(refsize - lsize);
                 if (mindiff > diff) {
                     mindiff = diff;
Index: kdeui/fonts/kfontchooser.cpp
===================================================================
--- kdeui/fonts/kfontchooser.cpp	(revisión: 797670)
+++ kdeui/fonts/kfontchooser.cpp	(copia de trabajo)
@@ -619,7 +619,7 @@
     splitFontString(family, &pureFamily);
     QStringList filteredStyles;
     qtStyles.clear();
-    foreach (const QString &style, styles) {
+    Q_FOREACH (const QString &style, styles) {
         // Sometimes the font database will report an invalid style,
         // that falls back back to another when set.
         // Remove such styles, by checking set/get round-trip.
@@ -858,7 +858,7 @@
     // Insert sizes into the listbox.
     sizeListBox->clear();
     qSort(sizes);
-    foreach (int size, sizes) {
+    Q_FOREACH (int size, sizes) {
         sizeListBox->addItem(QString::number(size));
     }
 
@@ -1034,7 +1034,7 @@
 
     QStringList trfonts;
     qtFamilies.clear();
-    foreach (const QString &font, fonts) {
+    Q_FOREACH (const QString &font, fonts) {
         // Try to split into name and foundry.
         QString family, foundry;
         splitFontString(font, &family, &foundry);
Index: kdeui/fonts/sampleedit_p.h
===================================================================
--- kdeui/fonts/sampleedit_p.h	(revisión: 797670)
+++ kdeui/fonts/sampleedit_p.h	(copia de trabajo)
@@ -129,7 +129,7 @@
     // Add text line by line, to keep centering each.
     clear();
     QStringList lines = text.split("\n");
-    foreach (const QString &line, lines) {
+    Q_FOREACH (const QString &line, lines) {
         append(line);
         setAlignment(Qt::AlignCenter);
     }
Index: kdeui/shortcuts/kgesture.cpp
===================================================================
--- kdeui/shortcuts/kgesture.cpp	(revisión: 797670)
+++ kdeui/shortcuts/kgesture.cpp	(copia de trabajo)
@@ -385,7 +385,7 @@
 {
     uint hash = 0;
 
-    foreach (QPoint point, d->m_shape)
+    Q_FOREACH (QPoint point, d->m_shape)
         hash += qHash(point.x()) + qHash(point.y());
 
     return hash;
Index: kdeui/shortcuts/kacceleratormanager.cpp
===================================================================
--- kdeui/shortcuts/kacceleratormanager.cpp	(revisión: 797670)
+++ kdeui/shortcuts/kacceleratormanager.cpp	(copia de trabajo)
@@ -196,7 +196,7 @@
 
     // collect the contents
     KAccelStringList contents;
-    foreach(Item *it, *item->m_children)
+    Q_FOREACH(Item *it, *item->m_children)
     {
         contents << it->m_content;
     }
@@ -206,7 +206,7 @@
 
     // write them back into the widgets
     int cnt = -1;
-    foreach(Item *it, *item->m_children)
+    Q_FOREACH(Item *it, *item->m_children)
     {
         cnt++;
 
@@ -254,7 +254,7 @@
     }
 
     // calculate the accelerators for the children
-    foreach(Item *it, *item->m_children)
+    Q_FOREACH(Item *it, *item->m_children)
     {
         if (it->m_widget && it->m_widget->isVisibleTo( item->m_widget ) )
             calculateAccelerators(it, used);
@@ -265,7 +265,7 @@
 void KAcceleratorManagerPrivate::traverseChildren(QWidget *widget, Item *item)
 {
   QList<QWidget*> childList = widget->findChildren<QWidget*>();
-  foreach ( QWidget *w , childList ) {
+  Q_FOREACH ( QWidget *w , childList ) {
     // Ignore unless we have the direct parent
     if(qobject_cast<QWidget *>(w->parent()) != widget) continue;
 
Index: kdeui/shortcuts/kglobalaccel.cpp
===================================================================
--- kdeui/shortcuts/kglobalaccel.cpp	(revisión: 797670)
+++ kdeui/shortcuts/kglobalaccel.cpp	(copia de trabajo)
@@ -134,11 +134,11 @@
 //TODO: implement this in KdedGlobalAccel... or not at all
 #if 0
     if (enabled) {
-        foreach (KAction* action, d->actionsWithGlobalShortcuts)
+        Q_FOREACH (KAction* action, d->actionsWithGlobalShortcuts)
             checkAction(action);
 
     } else {
-        foreach (int key, d->grabbedKeys.keys())
+        Q_FOREACH (int key, d->grabbedKeys.keys())
             d->impl->grabKey(key, false);
         d->grabbedActions.clear();
         d->grabbedKeys.clear();
@@ -333,7 +333,7 @@
     QList<KAction *> allActions = actionToName.keys();
     nameToAction.clear();
     actionToName.clear();
-    foreach(KAction *const action, allActions) {
+    Q_FOREACH(KAction *const action, allActions) {
         doRegister(action);
         updateGlobalShortcut(action, KAction::Autoloading | KAction::ActiveShortcut);
     }
Index: kdeui/shortcuts/kdedglobalaccel.cpp
===================================================================
--- kdeui/shortcuts/kdedglobalaccel.cpp	(revisión: 797670)
+++ kdeui/shortcuts/kdedglobalaccel.cpp	(copia de trabajo)
@@ -233,7 +233,7 @@
         emptyList.append(QString());
     }
 
-    foreach (const componentData *const cd, d->mainComponents.values()) {
+    Q_FOREACH (const componentData *const cd, d->mainComponents.values()) {
         QStringList actionId(emptyList);
         actionId[ComponentUnique] = cd->uniqueName;
         actionId[ComponentFriendly] = cd->friendlyName;
@@ -258,7 +258,7 @@
     partialId.append(cd->friendlyName);                 //ComponentFriendly
     partialId.append(QString());                        //ActionFriendly
 
-    foreach (const actionData *const ad, cd->actions.values()) {
+    Q_FOREACH (const actionData *const ad, cd->actions.values()) {
         QStringList actionId(partialId);
         actionId[ActionUnique] = ad->uniqueName;
         actionId[ActionFriendly] = ad->friendlyName;
@@ -277,7 +277,7 @@
 QStringList KdedGlobalAccel::allKeysAsString()
 {
     QStringList ret;
-    foreach(int keyQt, d->keyToAction.keys())
+    Q_FOREACH(int keyQt, d->keyToAction.keys())
         ret << QKeySequence(keyQt).toString();
     return ret;
 }
@@ -377,7 +377,7 @@
     if (isAutoloading && !ad->isFresh) {
         if (!ad->isPresent && setPresent) {
             ad->isPresent = true;
-            foreach (int key, ad->keys) {
+            Q_FOREACH (int key, ad->keys) {
                 if (key != 0) {
                     Q_ASSERT(d->keyToAction.value(key) == ad);
                     d->impl->grabKey(key, true);
@@ -392,7 +392,7 @@
     QList<int> added = d->nonemptyOnly(keys);
 
     //take care of stale keys and remove from added these that remain.
-    foreach(int oldKey, ad->keys) {
+    Q_FOREACH(int oldKey, ad->keys) {
         if (oldKey != 0) {
             bool remains = false;
             for (int i = 0; i < added.count(); i++) {
@@ -446,7 +446,7 @@
     }
 
     if (ad->isPresent) {
-        foreach (int key, added) {
+        Q_FOREACH (int key, added) {
             Q_ASSERT(d->keyToAction.value(key) == ad);
             d->impl->grabKey(key, true);
         }
@@ -498,13 +498,13 @@
 //slot
 void KdedGlobalAccel::writeSettings()
 {
-    foreach (const componentData *const cd, d->mainComponents) {
+    Q_FOREACH (const componentData *const cd, d->mainComponents) {
         KConfigGroup configGroup(&d->config, cd->uniqueName);
 
         KConfigGroup friendlyGroup(&configGroup, "Friendly Name");  // :)
         friendlyGroup.writeEntry("Friendly Name", cd->friendlyName);
 
-        foreach (const actionData *const ad, cd->actions) {
+        Q_FOREACH (const actionData *const ad, cd->actions) {
             if (ad->isFresh) {
                 //no shortcut assignement took place, the action was only registered
                 //(we could still write it out to document its existence, but the "fresh"
@@ -530,14 +530,14 @@
         lActionId.append(QString());
     }
 
-    foreach (const QString &groupName, d->config.groupList()) {
+    Q_FOREACH (const QString &groupName, d->config.groupList()) {
         KConfigGroup configGroup(&d->config, groupName);
         lActionId[ComponentUnique] = groupName;
 
         KConfigGroup friendlyGroup(&configGroup, "Friendly Name");
         lActionId[ComponentFriendly] = friendlyGroup.readEntry("Friendly Name");
 
-        foreach (const QString &confKey, configGroup.keyList()) {
+        Q_FOREACH (const QString &confKey, configGroup.keyList()) {
             QStringList entry = configGroup.readEntry(confKey, QStringList());
             if (entry.size() != 3) {
                 continue;
@@ -551,7 +551,7 @@
             ad->isPresent = false;
             ad->isFresh = false;
     
-            foreach (int key, ad->keys) {
+            Q_FOREACH (int key, ad->keys) {
                 if (key != 0) {
                     d->keyToAction.insert(key, ad);
                 }
@@ -567,7 +567,7 @@
         return ret;
     }
     QStringList strList = str.split(' ');
-    foreach (const QString &s, strList) {
+    Q_FOREACH (const QString &s, strList) {
         ret.append(QKeySequence(s)[0]);
     }
     return ret;
@@ -580,7 +580,7 @@
         return "none";
     }
     QString ret;
-    foreach (int key, keys) {
+    Q_FOREACH (int key, keys) {
         ret.append(QKeySequence(key).toString());
         ret.append(' ');
     }
Index: kdeui/shortcuts/kglobalaccel_mac.cpp
===================================================================
--- kdeui/shortcuts/kglobalaccel_mac.cpp	(revisión: 797670)
+++ kdeui/shortcuts/kglobalaccel_mac.cpp	(copia de trabajo)
@@ -96,7 +96,7 @@
         KKeyServer::keyQtToModMac( keyQt, mod );
         
         kDebug(125) << "keyQt: " << keyQt << " mod: " << mod;
-        foreach (uint keyCode, keyCodes) {
+        Q_FOREACH (uint keyCode, keyCodes) {
             kDebug(125) << "  keyCode: " << keyCode;
         }
         
@@ -104,7 +104,7 @@
         ehkid.signature = 'Kgai';
         ehkid.id = keyQt;
         QList<EventHotKeyRef> hotkeys;
-        foreach (uint keyCode, keyCodes) {
+        Q_FOREACH (uint keyCode, keyCodes) {
             EventHotKeyRef ref;
             if (RegisterEventHotKey(keyCode, mod, ehkid, m_eventTarget, 0, &ref) != noErr) {
                 kWarning(125) << "RegisterEventHotKey failed!";
@@ -115,7 +115,7 @@
     } else {
         kDebug(125) << "Ungrabbing key " << keyQt;
         if (refs->count(keyQt) == 0) kWarning(125) << "Trying to ungrab a key thas is not grabbed";
-        foreach (EventHotKeyRef ref, refs->value(keyQt)) {
+        Q_FOREACH (EventHotKeyRef ref, refs->value(keyQt)) {
             if (UnregisterEventHotKey(ref) != noErr) {
                 kWarning(125) << "UnregisterEventHotKey should not fail!";
             }
@@ -151,7 +151,7 @@
         grabKey(key, false);
     }
     // Now re-grab all the keys
-    foreach (int key, keys) {
+    Q_FOREACH (int key, keys) {
         grabKey(key, true);
     }
 }
Index: kdeui/shortcuts/kshortcut.cpp
===================================================================
--- kdeui/shortcuts/kshortcut.cpp	(revisión: 797670)
+++ kdeui/shortcuts/kshortcut.cpp	(copia de trabajo)
@@ -210,7 +210,7 @@
 QString KShortcut::toString() const
 {
     QString ret;
-    foreach(const QKeySequence &seq, toList()) {
+    Q_FOREACH(const QKeySequence &seq, toList()) {
         ret.append(seq.toString());
         ret.append("; ");
     }
Index: kdeui/plotting/kplotobject.cpp
===================================================================
--- kdeui/plotting/kplotobject.cpp	(revisión: 797670)
+++ kdeui/plotting/kplotobject.cpp	(copia de trabajo)
@@ -267,7 +267,7 @@
 
         QPointF Previous = QPointF();  //Initialize to null
 
-        foreach ( KPlotPoint *pp, d->pList ) {
+        Q_FOREACH ( KPlotPoint *pp, d->pList ) {
             //q is the position of the point in screen pixel coordinates
             QPointF q = pw->mapToWidget( pp->position() );
 
@@ -283,7 +283,7 @@
     //Draw points:
     if ( d->type & Points ) {
 
-        foreach( KPlotPoint *pp, d->pList ) {
+        Q_FOREACH( KPlotPoint *pp, d->pList ) {
             //q is the position of the point in screen pixel coordinates
             QPointF q = pw->mapToWidget( pp->position() );
             if ( pw->pixRect().contains( q.toPoint(), false ) ) {
@@ -381,7 +381,7 @@
     //Draw labels
     painter->setPen( labelPen() );
 
-    foreach ( KPlotPoint *pp, d->pList ) {
+    Q_FOREACH ( KPlotPoint *pp, d->pList ) {
         QPoint q = pw->mapToWidget( pp->position() ).toPoint();
         if ( pw->pixRect().contains(q, false) && ! pp->label().isEmpty() ) {
             pw->placeLabel( painter, pp );
Index: kdeui/plotting/kplotwidget.cpp
===================================================================
--- kdeui/plotting/kplotwidget.cpp	(revisión: 797670)
+++ kdeui/plotting/kplotwidget.cpp	(copia de trabajo)
@@ -220,7 +220,7 @@
 void KPlotWidget::addPlotObjects( const QList< KPlotObject* >& objects )
 {
     bool addedsome = false;
-    foreach ( KPlotObject *o, objects )
+    Q_FOREACH ( KPlotObject *o, objects )
     {
         if ( !o )
             continue;
@@ -361,8 +361,8 @@
 
 QList<KPlotPoint*> KPlotWidget::pointsUnderPoint( const QPoint& p ) const {
     QList<KPlotPoint*> pts;
-    foreach ( KPlotObject *po, d->objectList ) {
-        foreach ( KPlotPoint *pp, po->points() ) {
+    Q_FOREACH ( KPlotObject *po, d->objectList ) {
+        Q_FOREACH ( KPlotPoint *pp, po->points() ) {
             if ( ( p - mapToWidget( pp->position() ).toPoint() ).manhattanLength() <= 4 )
                 pts << pp;
         }
@@ -556,7 +556,7 @@
 
     resetPlotMask();
 
-    foreach( KPlotObject *po, d->objectList )
+    Q_FOREACH( KPlotObject *po, d->objectList )
         po->draw( &p, this );
 
     //DEBUG_MASK
@@ -587,12 +587,12 @@
 
         //Grid lines are placed at locations of primary axes' major tickmarks
         //vertical grid lines
-        foreach ( double xx, axis(BottomAxis)->majorTickMarks() ) {
+        Q_FOREACH ( double xx, axis(BottomAxis)->majorTickMarks() ) {
             double px = d->pixRect.width() * (xx - d->dataRect.x()) / d->dataRect.width();
             p->drawLine( QPointF( px, 0.0 ), QPointF( px, double(d->pixRect.height()) ) );
         }
         //horizontal grid lines
-        foreach( double yy, axis(LeftAxis)->majorTickMarks() ) {
+        Q_FOREACH( double yy, axis(LeftAxis)->majorTickMarks() ) {
             double py = d->pixRect.height() * (yy - d->dataRect.y()) / d->dataRect.height();
             p->drawLine( QPointF( 0.0, py ), QPointF( double(d->pixRect.width()), py ) );
         }
@@ -614,7 +614,7 @@
         p->drawLine( 0, d->pixRect.height(), d->pixRect.width(), d->pixRect.height() );
 
         // Draw major tickmarks
-        foreach( double xx, a->majorTickMarks() ) {
+        Q_FOREACH( double xx, a->majorTickMarks() ) {
             double px = d->pixRect.width() * (xx - d->dataRect.x()) / d->dataRect.width();
             if ( px > 0 && px < d->pixRect.width() ) {
                 p->drawLine( QPointF( px, double(d->pixRect.height() - TICKOFFSET)), 
@@ -629,7 +629,7 @@
         }
 
         // Draw minor tickmarks
-        foreach ( double xx, a->minorTickMarks() ) {
+        Q_FOREACH ( double xx, a->minorTickMarks() ) {
             double px = d->pixRect.width() * (xx - d->dataRect.x()) / d->dataRect.width();
             if ( px > 0 && px < d->pixRect.width() ) {
                 p->drawLine( QPointF( px, double(d->pixRect.height() - TICKOFFSET)), 
@@ -651,7 +651,7 @@
         p->drawLine( 0, 0, 0, d->pixRect.height() );
 
         // Draw major tickmarks
-        foreach( double yy, a->majorTickMarks() ) {
+        Q_FOREACH( double yy, a->majorTickMarks() ) {
             double py = d->pixRect.height() * ( 1.0 - (yy - d->dataRect.y()) / d->dataRect.height() );
             if ( py > 0 && py < d->pixRect.height() ) {
                 p->drawLine( QPointF( TICKOFFSET, py ), QPointF( double(TICKOFFSET + BIGTICKSIZE), py ) );
@@ -665,7 +665,7 @@
         }
 
         // Draw minor tickmarks
-        foreach ( double yy, a->minorTickMarks() ) {
+        Q_FOREACH ( double yy, a->minorTickMarks() ) {
             double py = d->pixRect.height() * ( 1.0 - (yy - d->dataRect.y()) / d->dataRect.height() );
             if ( py > 0 && py < d->pixRect.height() ) {
                 p->drawLine( QPointF( TICKOFFSET, py ), QPointF( double(TICKOFFSET + SMALLTICKSIZE), py ) );
@@ -707,7 +707,7 @@
         p->drawLine( 0, 0, d->pixRect.width(), 0 );
 
         // Draw major tickmarks
-        foreach( double xx, a->majorTickMarks() ) {
+        Q_FOREACH( double xx, a->majorTickMarks() ) {
             double px = d->pixRect.width() * (xx - x0) / dw;
             if ( px > 0 && px < d->pixRect.width() ) {
                 p->drawLine( QPointF( px, TICKOFFSET ), QPointF( px, double(BIGTICKSIZE + TICKOFFSET)) );
@@ -721,7 +721,7 @@
         }
 
         // Draw minor tickmarks
-        foreach ( double xx, a->minorTickMarks() ) {
+        Q_FOREACH ( double xx, a->minorTickMarks() ) {
             double px = d->pixRect.width() * (xx - x0) / dw;
             if ( px > 0 && px < d->pixRect.width() ) {
                 p->drawLine( QPointF( px, TICKOFFSET ), QPointF( px, double(SMALLTICKSIZE + TICKOFFSET)) );
@@ -742,7 +742,7 @@
         p->drawLine( d->pixRect.width(), 0, d->pixRect.width(), d->pixRect.height() );
 
         // Draw major tickmarks
-        foreach( double yy, a->majorTickMarks() ) {
+        Q_FOREACH( double yy, a->majorTickMarks() ) {
             double py = d->pixRect.height() * ( 1.0 - (yy - y0) / dh );
             if ( py > 0 && py < d->pixRect.height() ) {
                 p->drawLine( QPointF( double(d->pixRect.width() - TICKOFFSET), py ), 
@@ -757,7 +757,7 @@
         }
 
         // Draw minor tickmarks
-        foreach ( double yy, a->minorTickMarks() ) {
+        Q_FOREACH ( double yy, a->minorTickMarks() ) {
             double py = d->pixRect.height() * ( 1.0 - (yy - y0) / dh );
             if ( py > 0 && py < d->pixRect.height() ) {
                 p->drawLine( QPointF( double(d->pixRect.width() - 0.0), py ), 
Index: kdeui/actions/ktoolbarspaceraction.cpp
===================================================================
--- kdeui/actions/ktoolbarspaceraction.cpp	(revisión: 797670)
+++ kdeui/actions/ktoolbarspaceraction.cpp	(copia de trabajo)
@@ -62,7 +62,7 @@
 
   d->width = width;
 
-  foreach ( QWidget* spacer, d->spacers )
+  Q_FOREACH ( QWidget* spacer, d->spacers )
     spacer->resize( width, spacer->height() );
 }
 
@@ -78,7 +78,7 @@
 
   d->minimumWidth = width;
 
-  foreach ( QWidget* spacer, d->spacers )
+  Q_FOREACH ( QWidget* spacer, d->spacers )
     spacer->setMinimumWidth( width );
 }
 
@@ -94,7 +94,7 @@
 
   d->maximumWidth = width;
 
-  foreach ( QWidget* spacer, d->spacers )
+  Q_FOREACH ( QWidget* spacer, d->spacers )
     spacer->setMaximumWidth( width );
 }
 
Index: kdeui/actions/krecentfilesaction.cpp
===================================================================
--- kdeui/actions/krecentfilesaction.cpp	(revisión: 797670)
+++ kdeui/actions/krecentfilesaction.cpp	(copia de trabajo)
@@ -130,7 +130,7 @@
 #endif
 
     // remove file if already in list
-    foreach (QAction* action, selectableActionGroup()->actions())
+    Q_FOREACH (QAction* action, selectableActionGroup()->actions())
     {
       if ( d->m_urls[action].pathOrUrl().endsWith(file) )
       {
@@ -160,10 +160,10 @@
   action->setActionGroup(selectableActionGroup());
 
   // Keep in sync with createToolBarWidget()
-  foreach (QToolButton* button, d->m_buttons)
+  Q_FOREACH (QToolButton* button, d->m_buttons)
     button->insertAction(button->actions().value(0), action);
 
-  foreach (KComboBox* comboBox, d->m_comboBoxes)
+  Q_FOREACH (KComboBox* comboBox, d->m_comboBoxes)
     comboBox->insertAction(comboBox->actions().value(0), action);
 
   menu()->insertAction(menu()->actions().value(0), action);
Index: kdeui/actions/kfontaction.cpp
===================================================================
--- kdeui/actions/kfontaction.cpp	(revisión: 797670)
+++ kdeui/actions/kfontaction.cpp	(copia de trabajo)
@@ -146,7 +146,7 @@
     // Suppress triggered(QString) signal and prevent recursive call to ourself.
     d->settingFont++;
 
-    foreach(QWidget *w, createdWidgets())
+    Q_FOREACH(QWidget *w, createdWidgets())
     {
         QFontComboBox *cb = qobject_cast<QFontComboBox *>(w);
         kDebug(129) << "\tw=" << w << "cb=" << cb;
Index: kdeui/actions/kselectaction.cpp
===================================================================
--- kdeui/actions/kselectaction.cpp	(revisión: 797670)
+++ kdeui/actions/kselectaction.cpp	(copia de trabajo)
@@ -182,7 +182,7 @@
   else
     compare = text.toLower();
 
-  foreach (QAction* action, selectableActionGroup()->actions()) {
+  Q_FOREACH (QAction* action, selectableActionGroup()->actions()) {
     const QString text = ::DropAmpersands(action->text());
     if (cs == Qt::CaseSensitive) {
       if (text == compare) {
@@ -213,7 +213,7 @@
 
   d->m_comboWidth = width;
 
-  foreach (KComboBox* box, d->m_comboBoxes)
+  Q_FOREACH (KComboBox* box, d->m_comboBoxes)
     box->setMaximumWidth(d->m_comboWidth);
 
   emit changed();
@@ -224,7 +224,7 @@
   Q_D(KSelectAction);
   d->m_maxComboViewCount = n;
 
-  foreach (KComboBox* box, d->m_comboBoxes)
+  Q_FOREACH (KComboBox* box, d->m_comboBoxes)
     if ( d->m_maxComboViewCount != -1 )
       box->setMaxVisibleItems(d->m_maxComboViewCount);
     else
@@ -242,10 +242,10 @@
   action->setActionGroup(selectableActionGroup());
 
   // Keep in sync with createToolBarWidget()
-  foreach (QToolButton* button, d->m_buttons)
+  Q_FOREACH (QToolButton* button, d->m_buttons)
     button->addAction(action);
 
-  foreach (KComboBox* comboBox, d->m_comboBoxes)
+  Q_FOREACH (KComboBox* comboBox, d->m_comboBoxes)
     comboBox->addAction(action);
 
   menu()->addAction(action);
@@ -285,10 +285,10 @@
   // Removes the action from the group and sets its parent to null.
   d->m_actionGroup->removeAction(action);
 
-  foreach (QToolButton* button, d->m_buttons)
+  Q_FOREACH (QToolButton* button, d->m_buttons)
     button->removeAction(action);
 
-  foreach (KComboBox* comboBox, d->m_comboBoxes)
+  Q_FOREACH (KComboBox* comboBox, d->m_comboBoxes)
     comboBox->removeAction(action);
 
   menu()->removeAction(action);
@@ -318,7 +318,7 @@
   Q_D(const KSelectAction);
   QStringList ret;
 
-  foreach (QAction* action, d->m_actionGroup->actions())
+  Q_FOREACH (QAction* action, d->m_actionGroup->actions())
     ret << ::DropAmpersands(action->text());
 
   return ret;
@@ -343,7 +343,7 @@
 
   clear();
 
-  foreach (const QString& string, lst) {
+  Q_FOREACH (const QString& string, lst) {
     if ( !string.isEmpty() ) {
       addAction(string);
     } else {
@@ -396,7 +396,7 @@
   Q_D(KSelectAction);
   d->m_edit = edit;
 
-  foreach (KComboBox* comboBox, d->m_comboBoxes)
+  Q_FOREACH (KComboBox* comboBox, d->m_comboBoxes)
     comboBox->setEditable(edit);
 
   emit changed();
@@ -441,7 +441,7 @@
 
 void KSelectActionPrivate::_k_comboBoxDeleted(QObject* object)
 {
-  foreach (KComboBox* comboBox, m_comboBoxes)
+  Q_FOREACH (KComboBox* comboBox, m_comboBoxes)
     if (object == comboBox) {
       m_comboBoxes.removeAll(static_cast<KComboBox*>(object));
       break;
@@ -537,7 +537,7 @@
 
       comboBox->setEditable(isEditable());
 
-      foreach (QAction* action, selectableActionGroup()->actions())
+      Q_FOREACH (QAction* action, selectableActionGroup()->actions())
         comboBox->addAction(action);
 
       connect(comboBox, SIGNAL(destroyed(QObject*)), SLOT(_k_comboBoxDeleted(QObject*)));
@@ -578,7 +578,7 @@
   QAction *curAction = sa->currentAction ();
   //kDebug (129) << "\tTrueCurrentItem(" << sa << ") curAction=" << curAction;
 
-  foreach (QAction *action, sa->actions ())
+  Q_FOREACH (QAction *action, sa->actions ())
   {
     if (action->isChecked ())
     {
Index: kdeui/actions/kactioncollection.cpp
===================================================================
--- kdeui/actions/kactioncollection.cpp	(revisión: 797670)
+++ kdeui/actions/kactioncollection.cpp	(copia de trabajo)
@@ -186,7 +186,7 @@
 const QList< QAction* > KActionCollection::actionsWithoutGroup( ) const
 {
   QList<QAction*> ret;
-  foreach (QAction* action, d->actionByName)
+  Q_FOREACH (QAction* action, d->actionByName)
     if (!action->actionGroup())
       ret.append(action);
   return ret;
@@ -195,7 +195,7 @@
 const QList< QActionGroup * > KActionCollection::actionGroups( ) const
 {
   QSet<QActionGroup*> set;
-  foreach (QAction* action, d->actionByName)
+  Q_FOREACH (QAction* action, d->actionByName)
     if (action->actionGroup())
       set.insert(action->actionGroup());
   return set.toList();
@@ -245,7 +245,7 @@
     d->actionByName.insert(index_name, action);
     d->nameByAction.insert(action, index_name);
 
-    foreach (QWidget* widget, d->associatedWidgets)
+    Q_FOREACH (QWidget* widget, d->associatedWidgets)
       widget->addAction(action);
 
     connect(action, SIGNAL(destroyed(QObject*)), SLOT(_k_actionDestroyed(QObject*)));
@@ -274,7 +274,7 @@
   d->nameByAction.erase(it);
   d->actionByName.remove(name);
 
-  foreach (QWidget* widget, d->associatedWidgets)
+  Q_FOREACH (QWidget* widget, d->associatedWidgets)
     widget->removeAction(action);
 
   action->disconnect(this);
@@ -596,14 +596,14 @@
       QMetaObject::normalizedSignature(SIGNAL(actionHovered(QAction*))) == signal) {
     if (!d->connectHovered) {
       d->connectHovered = true;
-      foreach (QAction* action, actions())
+      Q_FOREACH (QAction* action, actions())
         connect(action, SIGNAL(hovered()), SLOT(slotActionHovered()));
     }
 
   } else if (QMetaObject::normalizedSignature(SIGNAL(actionTriggered(QAction*))) == signal) {
     if (!d->connectTriggered) {
       d->connectTriggered = true;
-      foreach (QAction* action, actions())
+      Q_FOREACH (QAction* action, actions())
         connect(action, SIGNAL(triggered(bool)), SLOT(slotActionTriggered()));
     }
   }
@@ -618,7 +618,7 @@
 
 void KActionCollection::associateWidget(QWidget* widget) const
 {
-    foreach (QAction* action, actions()) {
+    Q_FOREACH (QAction* action, actions()) {
         if (!widget->actions().contains(action))
             widget->addAction(action);
     }
@@ -636,7 +636,7 @@
 
 void KActionCollection::removeAssociatedWidget(QWidget * widget)
 {
-  foreach (QAction* action, actions())
+  Q_FOREACH (QAction* action, actions())
     widget->removeAction(action);
 
   d->associatedWidgets.removeAll(widget);
@@ -650,8 +650,8 @@
 
 void KActionCollection::clearAssociatedWidgets()
 {
-  foreach (QWidget* widget, d->associatedWidgets)
-    foreach (QAction* action, actions())
+  Q_FOREACH (QWidget* widget, d->associatedWidgets)
+    Q_FOREACH (QAction* action, actions())
       widget->removeAction(action);
 
   d->associatedWidgets.clear();
Index: kdeui/actions/ktoolbarlabelaction.cpp
===================================================================
--- kdeui/actions/ktoolbarlabelaction.cpp	(revisión: 797670)
+++ kdeui/actions/ktoolbarlabelaction.cpp	(copia de trabajo)
@@ -57,15 +57,15 @@
   d->buddy = buddy;
 
   QList<QLabel*> labels;
-  foreach ( QWidget* widget, associatedWidgets() )
+  Q_FOREACH ( QWidget* widget, associatedWidgets() )
     if ( QToolBar* toolBar = qobject_cast<QToolBar*>( widget ) )
       if ( QLabel* label = qobject_cast<QLabel*>( toolBar->widgetForAction( this ) ) )
         labels.append( label );
 
-  foreach ( QWidget* widget, buddy->associatedWidgets() )
+  Q_FOREACH ( QWidget* widget, buddy->associatedWidgets() )
     if ( QToolBar* toolBar = qobject_cast<QToolBar*>( widget ) ) {
       QWidget* newBuddy = toolBar->widgetForAction( buddy );
-      foreach ( QLabel* label, labels )
+      Q_FOREACH ( QLabel* label, labels )
         label->setBuddy( newBuddy );
       return;
     }
@@ -105,7 +105,7 @@
   newLabel->adjustSize();
 
   if ( d->buddy )
-    foreach ( QWidget* widget, d->buddy->associatedWidgets() )
+    Q_FOREACH ( QWidget* widget, d->buddy->associatedWidgets() )
       if ( QToolBar* toolBar = qobject_cast<QToolBar*>( widget ) ) {
         QWidget* newBuddy = toolBar->widgetForAction( d->buddy );
         newLabel->setBuddy( newBuddy );
Index: kdeui/actions/kcodecaction.cpp
===================================================================
--- kdeui/actions/kcodecaction.cpp	(revisión: 797670)
+++ kdeui/actions/kcodecaction.cpp	(copia de trabajo)
@@ -91,7 +91,7 @@
     defaultAction = q->addAction(i18n("Default"));
 
     int i;
-    foreach(const QStringList &encodingsForScript, KGlobal::charsets()->encodingsByScript())
+    Q_FOREACH(const QStringList &encodingsForScript, KGlobal::charsets()->encodingsByScript())
     {
         KSelectAction* tmp = new KSelectAction(encodingsForScript.at(0),q);
         if (showAutoOptions)
Index: kdeui/actions/kpastetextaction.cpp
===================================================================
--- kdeui/actions/kpastetextaction.cpp	(revisión: 797670)
+++ kdeui/actions/kpastetextaction.cpp	(copia de trabajo)
@@ -112,7 +112,7 @@
         list << clipboardText;
     bool found = false;
     const QFontMetrics fm = m_popup->fontMetrics();
-    foreach (const QString& string, list)
+    Q_FOREACH (const QString& string, list)
     {
       QString text = fm.elidedText(string.simplified(), Qt::ElideMiddle, fm.maxWidth() * 20);
       text.replace("&", "&&");
Index: kdeui/colors/kcolorcollection.cpp
===================================================================
--- kdeui/colors/kcolorcollection.cpp	(revisión: 797670)
+++ kdeui/colors/kcolorcollection.cpp	(copia de trabajo)
@@ -151,7 +151,7 @@
 
    str << "KDE RGB Palette\n";
    str << description << "\n";
-   foreach (const KColorCollectionPrivate::ColorNode &node, d->colorList)
+   Q_FOREACH (const KColorCollectionPrivate::ColorNode &node, d->colorList)
    {
        int r,g,b;
        node.color.getRgb(&r, &g, &b);
Index: kdeui/tests/kconfigguitest.cpp
===================================================================
--- kdeui/tests/kconfigguitest.cpp	(revisión: 797670)
+++ kdeui/tests/kconfigguitest.cpp	(copia de trabajo)
@@ -57,7 +57,7 @@
 {
   QDir local = QDir::homePath() + "/.kde-unit-test/share/config";
 
-  foreach(const QString &file, local.entryList(QDir::Files))
+  Q_FOREACH(const QString &file, local.entryList(QDir::Files))
     if(!local.remove(file))
       qWarning("%s: removing failed", qPrintable( file ));
 
Index: kdeui/windowmanagement/kwindowsystem_mac.cpp
===================================================================
--- kdeui/windowmanagement/kwindowsystem_mac.cpp	(revisión: 797670)
+++ kdeui/windowmanagement/kwindowsystem_mac.cpp	(copia de trabajo)
@@ -250,7 +250,7 @@
     WId id = processes[psn];
     if (windows.contains(id)) {
         KWindowInfo winfo = windows[id];
-        foreach (KWindowInfo::Private* wi, winfo.d->children) {
+        Q_FOREACH (KWindowInfo::Private* wi, winfo.d->children) {
             winids.removeAll(wi->win);
             emit KWindowSystem::self()->windowRemoved(wi->win);
         }
Index: kdeui/xmlgui/kxmlguifactory.cpp
===================================================================
--- kdeui/xmlgui/kxmlguifactory.cpp	(revisión: 797670)
+++ kdeui/xmlgui/kxmlguifactory.cpp	(copia de trabajo)
@@ -278,13 +278,13 @@
     emit clientAdded( client );
 
     // build child clients
-    foreach (KXMLGUIClient *child, client->childClients())
+    Q_FOREACH (KXMLGUIClient *child, client->childClients())
         addClient( child );
 
 /*
     QString unaddedActions;
-    foreach (KActionCollection* ac, KActionCollection::allCollections())
-      foreach (QAction* action, ac->actions())
+    Q_FOREACH (KActionCollection* ac, KActionCollection::allCollections())
+      Q_FOREACH (QAction* action, ac->actions())
         if (action->associatedWidgets().isEmpty())
           unaddedActions += action->objectName() + ' ';
 
@@ -309,7 +309,7 @@
     // remove child clients first (create a copy of the list just in case the
     // original list is modified directly or indirectly in removeClient())
     const QList<KXMLGUIClient*> childClients(client->childClients());
-    foreach (KXMLGUIClient *child, childClients)
+    Q_FOREACH (KXMLGUIClient *child, childClients)
         removeClient(child);
 
     //kDebug(260) << "calling removeRecursive";
@@ -407,7 +407,7 @@
          ( !guiClient || node->client == guiClient ) )
         return node->container;
 
-    foreach (ContainerNode* child, node->children)
+    Q_FOREACH (ContainerNode* child, node->children)
     {
         QWidget *cont = findRecursive( child, tag );
         if ( cont )
@@ -436,7 +436,7 @@
     if ( equals(node->tagName, tagName) )
         res.append( node->container );
 
-    foreach (KXMLGUI::ContainerNode* child, node->children)
+    Q_FOREACH (KXMLGUI::ContainerNode* child, node->children)
         res << findRecursive( child, tagName );
 
     return res;
@@ -550,7 +550,7 @@
 	KShortcutsDialog dlg(KShortcutsEditor::AllActions,
          letterCutsOk ? KShortcutsEditor::LetterShortcutsAllowed : KShortcutsEditor::LetterShortcutsDisallowed,
          qobject_cast<QWidget*>(parent()));
-	foreach (KXMLGUIClient *client, d->m_clients)
+	Q_FOREACH (KXMLGUIClient *client, d->m_clients)
 	{
 		if(client && !client->xmlFile().isEmpty())
 			dlg.addCollection( client->actionCollection() );
Index: kdeui/xmlgui/kxmlguiwindow.cpp
===================================================================
--- kdeui/xmlgui/kxmlguiwindow.cpp	(revisión: 797670)
+++ kdeui/xmlgui/kxmlguiwindow.cpp	(copia de trabajo)
@@ -331,7 +331,7 @@
     // the toolbariterator should give them in the proper order.
     // Both the XMLGUI and applySettings call this, hence "force" for the latter.
     /* FIXME KAction port - not needed?
-    foreach (KToolBar* toolbar, toolBars()) {
+    Q_FOREACH (KToolBar* toolbar, toolBars()) {
         toolbar->positionYourself( force );
     }*/
 
Index: kdeui/xmlgui/ktoolbarhandler.cpp
===================================================================
--- kdeui/xmlgui/ktoolbarhandler.cpp	(revisión: 797670)
+++ kdeui/xmlgui/ktoolbarhandler.cpp	(copia de trabajo)
@@ -55,7 +55,7 @@
       {
         QList<KToolBar*> toolBars = qFindChildren<KToolBar*>( m_mainWindow );
 
-        foreach( KToolBar * toolBar, toolBars) {
+        Q_FOREACH( KToolBar * toolBar, toolBars) {
           if ( toolBar->mainWindow() != m_mainWindow )
             continue;
 
@@ -81,7 +81,7 @@
         if ( !m_needsRebuild )
           return actions;
 
-        foreach ( KToolBar* bar, m_toolBars )
+        Q_FOREACH ( KToolBar* bar, m_toolBars )
           handleToolBar( bar );
 
         if ( m_toolBarActions.count() == 0 )
@@ -97,7 +97,7 @@
         KActionMenu *menuAction = new KActionMenu(i18n( "Toolbars" ), m_actionCollection);
         m_actionCollection->addAction("toolbars_submenu_action", menuAction);
 
-        foreach ( QAction* action, m_toolBarActions )
+        Q_FOREACH ( QAction* action, m_toolBarActions )
           menuAction->menu()->addAction( action );
 
         actions.append( menuAction );
@@ -178,7 +178,7 @@
 
 void ToolBarHandler::Private::connectToActionContainers()
 {
-  foreach ( QAction* action, actions )
+  Q_FOREACH ( QAction* action, actions )
     connectToActionContainer( action );
 }
 
Index: kdeui/xmlgui/kmainwindowiface.cpp
===================================================================
--- kdeui/xmlgui/kmainwindowiface.cpp	(revisión: 797670)
+++ kdeui/xmlgui/kmainwindowiface.cpp	(copia de trabajo)
@@ -43,7 +43,7 @@
 {
 	QStringList tmp_actions;
 	QList<QAction *> lst = m_MainWindow->actionCollection()->actions();
-	foreach( QAction* it, lst ) {
+	Q_FOREACH( QAction* it, lst ) {
 		if (it->associatedWidgets().count()>0)
 			tmp_actions.append( it->objectName() );
 	}
Index: kdeui/xmlgui/kxmlguiclient.cpp
===================================================================
--- kdeui/xmlgui/kxmlguiclient.cpp	(revisión: 797670)
+++ kdeui/xmlgui/kxmlguiclient.cpp	(copia de trabajo)
@@ -93,7 +93,7 @@
   if ( d->m_parent )
     d->m_parent->removeChildClient( this );
 
-  foreach (KXMLGUIClient* client, d->m_children) {
+  Q_FOREACH (KXMLGUIClient* client, d->m_children) {
       assert( client->d->m_parent == this );
       client->d->m_parent = 0;
   }
@@ -106,7 +106,7 @@
 {
   QAction* act = actionCollection()->action( name );
   if ( !act ) {
-    foreach (KXMLGUIClient* client, d->m_children) {
+    Q_FOREACH (KXMLGUIClient* client, d->m_children) {
       act = client->actionCollection()->action( name );
       if ( act )
         break;
@@ -690,7 +690,7 @@
 void KXMLGUIClient::beginXMLPlug( QWidget* w )
 {
   actionCollection()->addAssociatedWidget( w );
-  foreach (KXMLGUIClient* client, d->m_children)
+  Q_FOREACH (KXMLGUIClient* client, d->m_children)
     client->beginXMLPlug( w );
 }
 
@@ -701,7 +701,7 @@
 void KXMLGUIClient::prepareXMLUnplug( QWidget * w )
 {
   actionCollection()->removeAssociatedWidget( w );
-  foreach (KXMLGUIClient* client, d->m_children)
+  Q_FOREACH (KXMLGUIClient* client, d->m_children)
     client->prepareXMLUnplug( w );
 }
 
Index: kdeui/xmlgui/kmenumenuhandler_p.cpp
===================================================================
--- kdeui/xmlgui/kmenumenuhandler_p.cpp	(revisión: 797670)
+++ kdeui/xmlgui/kmenumenuhandler_p.cpp	(copia de trabajo)
@@ -71,7 +71,7 @@
   if(!window)
     return;
   QStringList toolbarlist;
-  foreach(KToolBar *b , window->toolBars())
+  Q_FOREACH(KToolBar *b , window->toolBars())
   {
     toolbarlist << (b->windowTitle().isEmpty() ? b->objectName() : b->windowTitle());
   }
@@ -80,7 +80,7 @@
 
 static KActionCollection* findParentCollection(KXMLGUIFactory* factory, QAction* action)
 {
-    foreach(KXMLGUIClient *client, factory->clients()) {
+    Q_FOREACH(KXMLGUIClient *client, factory->clients()) {
         KActionCollection* collection = client->actionCollection();
         // if the call to actions() is too slow, add KActionCollection::contains(QAction*).
         if (collection->actions().contains(action)) {
@@ -109,7 +109,7 @@
         QList<KActionCollection*> checkCollections;
         KXMLGUIFactory *factory=dynamic_cast<KXMLGUIClient*>(m_builder)->factory();
         parentCollection = findParentCollection(factory, action);
-        foreach(KXMLGUIClient *client, factory->clients()) {
+        Q_FOREACH(KXMLGUIClient *client, factory->clients()) {
             checkCollections += client->actionCollection();
         }
         swidget.setCheckActionCollections(checkCollections);
Index: kdeui/xmlgui/kxmlguiversionhandler.cpp
===================================================================
--- kdeui/xmlgui/kxmlguiversionhandler.cpp	(revisión: 797670)
+++ kdeui/xmlgui/kxmlguiversionhandler.cpp	(copia de trabajo)
@@ -49,7 +49,7 @@
 {
     QDomElement parent = doc.documentElement();
     const QList<QDomElement> toolBars = extractToolBars(doc);
-    foreach(const QDomElement& e, toolBars) {
+    Q_FOREACH(const QDomElement& e, toolBars) {
         parent.removeChild(e);
     }
 }
@@ -61,7 +61,7 @@
     QDomElement insertAfter = menuBar;
     if (menuBar.isNull())
         insertAfter = parent.firstChildElement(); // if null, insertAfter will do an append
-    foreach(const QDomElement& e, toolBars) {
+    Q_FOREACH(const QDomElement& e, toolBars) {
         QDomNode result = parent.insertAfter(e, insertAfter);
         Q_ASSERT(!result.isNull());
     }
@@ -220,7 +220,7 @@
 {
     QList<DocStruct> allDocuments;
 
-    foreach (const QString &file, files) {
+    Q_FOREACH (const QString &file, files) {
         DocStruct d;
         d.file = file;
         d.data = KXMLGUIFactory::readConfigFile( file );
Index: kdeui/xmlgui/kxmlguifactory_p.cpp
===================================================================
--- kdeui/xmlgui/kxmlguifactory_p.cpp	(revisión: 797670)
+++ kdeui/xmlgui/kxmlguifactory_p.cpp	(copia de trabajo)
@@ -40,7 +40,7 @@
     else if (index != container->actions().count())
         before = container->actions().at(index); // Insert before indexed action.
 
-    foreach (QAction* action, *this) {
+    Q_FOREACH (QAction* action, *this) {
         container->insertAction(before, action);
         // before = action; // BUG FIX: do not insert actions in reverse order.
     }
@@ -48,7 +48,7 @@
 
 void ActionList::unplug( QWidget *container ) const
 {
-    foreach (QAction* action, *this)
+    Q_FOREACH (QAction* action, *this)
         container->removeAction( action );
 }
 
@@ -109,7 +109,7 @@
  */
 ContainerNode *ContainerNode::findContainerNode( QWidget *container )
 {
-    foreach (ContainerNode* child, children )
+    Q_FOREACH (ContainerNode* child, children )
         if ( child->container == container )
             return child;
 
@@ -127,7 +127,7 @@
          ( !tag && name == _name ) )
         return this;
 
-    foreach (ContainerNode* child, children )
+    Q_FOREACH (ContainerNode* child, children )
     {
         ContainerNode *res = child->findContainer( _name, tag );
         if ( res )
@@ -198,7 +198,7 @@
 {
     if ( !clients.isEmpty() )
     {
-        foreach (ContainerClient* client, clients)
+        Q_FOREACH (ContainerClient* client, clients)
             if ( client->client == currentGUIClient )
             {
                 if ( groupName.isEmpty() )
@@ -228,7 +228,7 @@
     for (; mIt != mEnd; ++mIt )
         plugActionList( state, mIt );
 
-    foreach (ContainerNode* child, children)
+    Q_FOREACH (ContainerNode* child, children)
         child->plugActionList( state );
 }
 
@@ -269,7 +269,7 @@
     for (; mIt != mEnd; ++mIt )
         unplugActionList( state, mIt );
 
-    foreach (ContainerNode* child, children)
+    Q_FOREACH (ContainerNode* child, children)
         child->unplugActionList( state );
 }
 
@@ -472,7 +472,7 @@
 
 void ContainerNode::reset()
 {
-    foreach (ContainerNode* child, children)
+    Q_FOREACH (ContainerNode* child, children)
         child->reset();
 
     if ( client )
Index: kdeui/widgets/kactionselector.cpp
===================================================================
--- kdeui/widgets/kactionselector.cpp	(revisión: 797670)
+++ kdeui/widgets/kactionselector.cpp	(copia de trabajo)
@@ -438,7 +438,7 @@
 {
   // move all selected items from available to selected listbox
   QList<QListWidgetItem *> list = availableListWidget->selectedItems();
-  foreach (QListWidgetItem* item, list) {
+  Q_FOREACH (QListWidgetItem* item, list) {
     availableListWidget->takeItem( availableListWidget->row( item ) );
     selectedListWidget->insertItem( insertionIndex( selectedListWidget, selectedInsertionPolicy ), item );
     selectedListWidget->setCurrentItem( item );
@@ -453,7 +453,7 @@
 {
   // move all selected items from selected to available listbox
   QList<QListWidgetItem *> list = selectedListWidget->selectedItems();
-  foreach (QListWidgetItem* item, list) {
+  Q_FOREACH (QListWidgetItem* item, list) {
     selectedListWidget->takeItem( selectedListWidget->row( item ) );
     availableListWidget->insertItem( insertionIndex( availableListWidget, availableInsertionPolicy ), item );
     availableListWidget->setCurrentItem( item );
Index: kdeui/widgets/klanguagebutton.cpp
===================================================================
--- kdeui/widgets/klanguagebutton.cpp	(revisión: 797670)
+++ kdeui/widgets/klanguagebutton.cpp	(copia de trabajo)
@@ -231,7 +231,7 @@
 
 QAction *KLanguageButtonPrivate::findAction(const QString& data) const
 {
-  foreach(QAction *a, popup->actions()) {
+  Q_FOREACH(QAction *a, popup->actions()) {
     if (!a->data().toString().compare(data))
       return a;
   }
Index: kdeui/widgets/ktimezonewidget.cpp
===================================================================
--- kdeui/widgets/ktimezonewidget.cpp	(revisión: 797670)
+++ kdeui/widgets/ktimezonewidget.cpp	(copia de trabajo)
@@ -75,7 +75,7 @@
   }
   qSort( cities.begin(), cities.end(), localeLessThan );
 
-  foreach ( const QString &city, cities ) {
+  Q_FOREACH ( const QString &city, cities ) {
     KTimeZone zone = zonesByCity[city];
     QString tzName = zone.name();
     QString comment = zone.comment();
@@ -119,7 +119,7 @@
     QStringList selection;
 
     // Loop through all entries.
-    foreach ( QTreeWidgetItem* listItem, selectedItems() )
+    Q_FOREACH ( QTreeWidgetItem* listItem, selectedItems() )
         selection.append( listItem->data( Private::CityColumn, Private::ZoneRole ).toString() );
 
     return selection;
Index: kdeui/widgets/kdatetable.cpp
===================================================================
--- kdeui/widgets/kdatetable.cpp	(revisión: 797670)
+++ kdeui/widgets/kdatetable.cpp	(copia de trabajo)
@@ -259,7 +259,7 @@
 
     localCollection->readSettings();
     localCollection->addAssociatedWidget( this );
-    foreach (QAction* action, localCollection->actions())
+    Q_FOREACH (QAction* action, localCollection->actions())
         action->setShortcutContext(Qt::WidgetWithChildrenShortcut);
 }
 
Index: kdeui/widgets/kkeysequencewidget.cpp
===================================================================
--- kdeui/widgets/kkeysequencewidget.cpp	(revisión: 797670)
+++ kdeui/widgets/kkeysequencewidget.cpp	(copia de trabajo)
@@ -213,7 +213,7 @@
 {
     d->checkActionCollections = actionCollections;
     // For now, fill in d->checkList so that the main logic can still work with only checkList.
-    foreach(KActionCollection* collection, actionCollections) {
+    Q_FOREACH(KActionCollection* collection, actionCollections) {
         d->checkList += collection->actions();
     }
 }
@@ -261,7 +261,7 @@
 		d->stealAction->setShortcut(cut, KAction::ActiveShortcut);
                 // Find the collection where stealAction belongs
                 KActionCollection* parentCollection = 0;
-                foreach(KActionCollection* collection, d->checkActionCollections) {
+                Q_FOREACH(KActionCollection* collection, d->checkActionCollections) {
                     if (collection->actions().contains(d->stealAction)) {
                         parentCollection = collection;
                         break;
@@ -303,7 +303,7 @@
     //We don't check for global shortcut when the checklist is empty because we are not certain that apply will be called.
 	if (keySequence != oldKeySequence && validate && !checkList.isEmpty()) {
 		//find conflicting shortcuts with existing actions
-		foreach(QAction * qaction , checkList )
+		Q_FOREACH(QAction * qaction , checkList )
 		{
 			KAction *kaction=qobject_cast<KAction*>(qaction);
 			if(kaction) {
Index: kdeui/widgets/kcharselectdata.cpp
===================================================================
--- kdeui/widgets/kcharselectdata.cpp	(revisión: 797670)
+++ kdeui/widgets/kcharselectdata.cpp	(copia de trabajo)
@@ -541,7 +541,7 @@
     }
 
     QRegExp regExp("^(|u\\+|U\\+|0x|0X)([A-Fa-f0-9]{4})$");
-    foreach(const QString &s, searchStrings) {
+    Q_FOREACH(const QString &s, searchStrings) {
         if(regExp.exactMatch(s)) {
             res.append(regExp.cap(2).toInt(0, 16));
         }
@@ -560,7 +560,7 @@
         QString name = data + offset;
         if (name.contains(firstString, Qt::CaseInsensitive)) {
             bool valid = true;
-            foreach(const QString &s, searchStrings) {
+            Q_FOREACH(const QString &s, searchStrings) {
                 if (!name.contains(s, Qt::CaseInsensitive)) {
                     valid = false;
                     break;
Index: kdeui/widgets/kmainwindow.cpp
===================================================================
--- kdeui/widgets/kmainwindow.cpp	(revisión: 797670)
+++ kdeui/widgets/kmainwindow.cpp	(copia de trabajo)
@@ -144,7 +144,7 @@
         }
 
         int n = 0;
-        foreach (KMainWindow* mw, KMainWindow::memberList()) {
+        Q_FOREACH (KMainWindow* mw, KMainWindow::memberList()) {
             n++;
             mw->savePropertiesInternal(config, n);
         }
@@ -161,7 +161,7 @@
             bool canceled = false;
             ::no_query_exit = true;
 
-            foreach (KMainWindow *window, KMainWindow::memberList()) {
+            Q_FOREACH (KMainWindow *window, KMainWindow::memberList()) {
                 if ( !window->testAttribute( Qt::WA_WState_Hidden ) ) {
                     QCloseEvent e;
                     QApplication::sendEvent( window, &e );
@@ -189,7 +189,7 @@
                return false;
 
             KMainWindow* last = 0;
-            foreach (KMainWindow *window, KMainWindow::memberList()) {
+            Q_FOREACH (KMainWindow *window, KMainWindow::memberList()) {
                 if ( !window->testAttribute( Qt::WA_WState_Hidden ) ) {
                     last = window;
                 }
@@ -322,7 +322,7 @@
     for(;;) {
         QList<QWidget*> list = qApp->topLevelWidgets();
         bool found = false;
-        foreach ( QWidget* w, list ) {
+        Q_FOREACH ( QWidget* w, list ) {
             if( w != q && w->objectName() == s )
             {
                 found = true;
@@ -524,7 +524,7 @@
         e->accept();
 
         int not_withdrawn = 0;
-        foreach (KMainWindow* mw, KMainWindow::memberList()) {
+        Q_FOREACH (KMainWindow* mw, KMainWindow::memberList()) {
             if ( !mw->isHidden() && mw->isTopLevel() && mw != this )
                 not_withdrawn++;
         }
@@ -633,7 +633,7 @@
     }
 
     int n = 1; // Toolbar counter. toolbars are counted from 1,
-    foreach (KToolBar* toolbar, toolBars()) {
+    Q_FOREACH (KToolBar* toolbar, toolBars()) {
         QString group;
         // Give a number to the toolbar, but prefer a name if there is one,
         // because there's no real guarantee on the ordering of toolbars
@@ -725,7 +725,7 @@
     }
 
     int n = 1; // Toolbar counter. toolbars are counted from 1,
-    foreach (KToolBar* toolbar, toolBars()) {
+    Q_FOREACH (KToolBar* toolbar, toolBars()) {
         QString group;
         if (!configGroup.isEmpty())
         {
@@ -1111,7 +1111,7 @@
 {
     QList<KToolBar*> ret;
 
-    foreach (QObject* child, children())
+    Q_FOREACH (QObject* child, children())
         if (KToolBar* toolBar = qobject_cast<KToolBar*>(child))
             ret.append(toolBar);
 
Index: kdeui/widgets/ktoolbar.cpp
===================================================================
--- kdeui/widgets/ktoolbar.cpp	(revisión: 797670)
+++ kdeui/widgets/ktoolbar.cpp	(copia de trabajo)
@@ -252,7 +252,7 @@
     contextBottom = contextOrient->addAction( i18nc( "toolbar position string", "Bottom" ), parent, SLOT( slotContextBottom() ) );
 
     QActionGroup* positionGroup = new QActionGroup( contextOrient );
-    foreach ( QAction* action, contextOrient->actions() ) {
+    Q_FOREACH ( QAction* action, contextOrient->actions() ) {
       action->setActionGroup( positionGroup );
       action->setCheckable( true );
     }
@@ -267,7 +267,7 @@
     contextTextUnder = contextMode->addAction( i18n( "Text Under Icons" ), parent, SLOT( slotContextTextUnder() ) );
 
     QActionGroup* textGroup = new QActionGroup( contextMode );
-    foreach ( QAction* action, contextMode->actions() ) {
+    Q_FOREACH ( QAction* action, contextMode->actions() ) {
       action->setActionGroup( textGroup );
       action->setCheckable( true );
     }
@@ -292,7 +292,7 @@
 
     if ( avSizes.count() < 10 ) {
       // Fixed or threshold type icons
-      foreach ( int it, avSizes ) {
+      Q_FOREACH ( int it, avSizes ) {
         QString text;
         if ( it < 19 )
           text = i18n( "Small (%1x%2)", it, it );
@@ -311,7 +311,7 @@
       const int progression[] = { 16, 22, 32, 48, 64, 96, 128, 192, 256 };
 
       for ( uint i = 0; i < 9; i++ ) {
-        foreach ( int it, avSizes ) {
+        Q_FOREACH ( int it, avSizes ) {
           if ( it >= progression[ i ] ) {
             QString text;
             if ( it < 19 )
@@ -332,7 +332,7 @@
     }
 
     QActionGroup* sizeGroup = new QActionGroup( contextSize );
-    foreach ( QAction* action, contextSize->actions() ) {
+    Q_FOREACH ( QAction* action, contextSize->actions() ) {
       action->setActionGroup( sizeGroup );
       action->setCheckable( true );
     }
@@ -1063,8 +1063,8 @@
 
     stream >> actionNames;
 
-    foreach ( const QString& actionName, actionNames ) {
-      foreach ( KActionCollection* ac, KActionCollection::allCollections() ) {
+    Q_FOREACH ( const QString& actionName, actionNames ) {
+      Q_FOREACH ( KActionCollection* ac, KActionCollection::allCollections() ) {
         QAction* newAction = ac->action( actionName.toAscii().constData() );
         if ( newAction ) {
           d->actionsBeingDragged.append( newAction );
@@ -1096,10 +1096,10 @@
 void KToolBar::dragMoveEvent( QDragMoveEvent *event )
 {
   if ( toolBarsEditable() )
-    forever {
+    Q_FOREVER {
       if ( d->dropIndicatorAction ) {
         QAction* overAction = 0L;
-        foreach ( QAction* action, actions() ) {
+        Q_FOREACH ( QAction* action, actions() ) {
           // want to make it feel that half way across an action you're dropping on the other side of it
           QWidget* widget = widgetForAction( action );
           if ( event->pos().x() < widget->pos().x() + (widget->width() / 2) ) {
@@ -1148,7 +1148,7 @@
 void KToolBar::dropEvent( QDropEvent *event )
 {
   if ( toolBarsEditable() ) {
-    foreach ( QAction* action, d->actionsBeingDragged ) {
+    Q_FOREACH ( QAction* action, d->actionsBeingDragged ) {
       if ( actions().contains( action ) )
         removeAction( action );
       insertAction( d->dropIndicatorAction, action );
@@ -1253,7 +1253,7 @@
       }
       // New parent is not a subwidget - remove event filter
       ww->removeEventFilter( this );
-      foreach ( QWidget* child, ww->findChildren<QWidget*>() )
+      Q_FOREACH ( QWidget* child, ww->findChildren<QWidget*>() )
         child->removeEventFilter( this );
     }
   }
@@ -1334,7 +1334,7 @@
     if (widget) {
         widget->removeEventFilter( this );
 
-        foreach ( QWidget* child, widget->findChildren<QWidget*>() )
+        Q_FOREACH ( QWidget* child, widget->findChildren<QWidget*>() )
             child->removeEventFilter( this );
     }
   }
@@ -1346,7 +1346,7 @@
     if (widget) {
         widget->installEventFilter( this );
 
-        foreach ( QWidget* child, widget->findChildren<QWidget*>() )
+        Q_FOREACH ( QWidget* child, widget->findChildren<QWidget*>() )
             child->installEventFilter( this );
     }
   }
@@ -1370,8 +1370,8 @@
   if ( KToolBar::Private::s_locked != locked ) {
     KToolBar::Private::s_locked = locked;
 
-    foreach ( KMainWindow* mw, KMainWindow::memberList() )
-      foreach ( KToolBar* toolbar, mw->findChildren<KToolBar*>() ) {
+    Q_FOREACH ( KMainWindow* mw, KMainWindow::memberList() )
+      Q_FOREACH ( KToolBar* toolbar, mw->findChildren<KToolBar*>() ) {
         toolbar->d->setLocked( locked );
         if (toolbar->d->contextLockAction)
             toolbar->d->contextLockAction->setText(locked ? i18n( "Unlock Toolbars" ) : i18n( "Lock Toolbars" ));
Index: kdeui/widgets/kmenu.cpp
===================================================================
--- kdeui/widgets/kmenu.cpp	(revisión: 797670)
+++ kdeui/widgets/kmenu.cpp	(copia de trabajo)
@@ -249,7 +249,7 @@
     d->keySeq += keyString;
     int seqLen = d->keySeq.length();
 
-    foreach (a, actions()) {
+    Q_FOREACH (a, actions()) {
         // don't search disabled entries
         if (!a->isEnabled())
             continue;
Index: kdeui/widgets/kcharselect.cpp
===================================================================
--- kdeui/widgets/kcharselect.cpp	(revisión: 797670)
+++ kdeui/widgets/kcharselect.cpp	(copia de trabajo)
@@ -449,7 +449,7 @@
 
     if (!aliases.isEmpty()) {
         html += "<p style=\"margin-bottom: 0px;\">" + i18n("Alias names:") + "</p><ul style=\"margin-top: 0px;\">";
-        foreach(const QString &alias, aliases) {
+        Q_FOREACH(const QString &alias, aliases) {
             html += "<li>" + Qt::escape(alias) + "</li>";
         }
         html += "</ul>";
@@ -457,7 +457,7 @@
 
     if (!notes.isEmpty()) {
         html += "<p style=\"margin-bottom: 0px;\">" + i18n("Notes:") + "</p><ul style=\"margin-top: 0px;\">";
-        foreach(const QString &note, notes) {
+        Q_FOREACH(const QString &note, notes) {
             html += "<li>" + createLinks(Qt::escape(note)) + "</li>";
         }
         html += "</ul>";
@@ -465,7 +465,7 @@
 
     if (!seeAlso.isEmpty()) {
         html += "<p style=\"margin-bottom: 0px;\">" + i18n("See also:") + "</p><ul style=\"margin-top: 0px;\">";
-        foreach(const QChar &c2, seeAlso) {
+        Q_FOREACH(const QChar &c2, seeAlso) {
             html += "<li><a href=\"" + QString::number(c2.unicode(), 16) + "\">";
             if (c2.isPrint()) {
                 html += "&#" + QString::number(c2.unicode()) + "; ";
@@ -477,7 +477,7 @@
 
     if (!equivalents.isEmpty()) {
         html += "<p style=\"margin-bottom: 0px;\">" + i18n("Equivalents:") + "</p><ul style=\"margin-top: 0px;\">";
-        foreach(const QString &equivalent, equivalents) {
+        Q_FOREACH(const QString &equivalent, equivalents) {
             html += "<li>" + createLinks(Qt::escape(equivalent)) + "</li>";
         }
         html += "</ul>";
@@ -485,7 +485,7 @@
 
     if (!approxEquivalents.isEmpty()) {
         html += "<p style=\"margin-bottom: 0px;\">" + i18n("Approximate equivalents:") + "</p><ul style=\"margin-top: 0px;\">";
-        foreach(const QString &approxEquivalent, approxEquivalents) {
+        Q_FOREACH(const QString &approxEquivalent, approxEquivalents) {
             html += "<li>" + createLinks(Qt::escape(approxEquivalent)) + "</li>";
         }
         html += "</ul>";
@@ -540,11 +540,11 @@
 
     html += "<p><b>" + i18n("Various Useful Representations") + "</b><br>";
     html += i18n("UTF-8:");
-    foreach(unsigned char c, utf8)
+    Q_FOREACH(unsigned char c, utf8)
     html += ' ' + KCharSelectData::formatCode(c, 2, "0x");
     html += "<br>" + i18n("UTF-16: ") + KCharSelectData::formatCode(c.unicode(), 4, "0x") + "<br>";
     html += i18n("C octal escaped UTF-8: ");
-    foreach(unsigned char c, utf8)
+    Q_FOREACH(unsigned char c, utf8)
     html += KCharSelectData::formatCode(c, 3, "\\", 8);
     html += "<br>" + i18n("XML decimal entity:") + " &amp;#" + QString::number(c.unicode()) + ";</p>";
 
@@ -564,7 +564,7 @@
     }
 
     QSet<QString> chars2 = QSet<QString>::fromList(chars);
-    foreach(const QString &c, chars2) {
+    Q_FOREACH(const QString &c, chars2) {
         int unicode = c.toInt(0, 16);
         QString link = "<a href=\"" + c + "\">";
         if (QChar(unicode).isPrint()) {
@@ -581,7 +581,7 @@
 {
     blockCombo->clear();
     QList<int> blocks = KCharSelectData::sectionContents(index);
-    foreach(int block, blocks) {
+    Q_FOREACH(int block, blocks) {
         blockCombo->addItem(KCharSelectData::blockName(block), QVariant(block));
     }
     blockCombo->setCurrentIndex(0);
Index: kdeui/icons/kicontheme.cpp
===================================================================
--- kdeui/icons/kicontheme.cpp	(revisión: 797670)
+++ kdeui/icons/kicontheme.cpp	(copia de trabajo)
@@ -223,7 +223,7 @@
     // Expand available sizes for scalable icons to their full range
     int i;
     QMap<int,QList<int> > scIcons;
-    foreach(KIconThemeDir *dir, d->mDirs)
+    Q_FOREACH(KIconThemeDir *dir, d->mDirs)
     {
         if(!dir) break;
         if ((dir->type() == KIconLoader::Scalable) && !scIcons.contains(dir->size()))
@@ -418,7 +418,7 @@
 
 bool KIconTheme::hasContext(KIconLoader::Context context) const
 {
-    foreach(KIconThemeDir *dir, d->mDirs)
+    Q_FOREACH(KIconThemeDir *dir, d->mDirs)
         if ((context == KIconLoader::Any) || (context == dir->context()))
             return true;
     return false;
Index: kdeui/icons/kiconcache.cpp
===================================================================
--- kdeui/icons/kiconcache.cpp	(revisión: 797670)
+++ kdeui/icons/kiconcache.cpp	(copia de trabajo)
@@ -214,7 +214,7 @@
 unsigned int KIconCache::mostRecentMTime(const QSet<QString>& dirNames) const
 {
     unsigned int timestamp = 0;
-    foreach (const QString &dir, dirNames) {
+    Q_FOREACH (const QString &dir, dirNames) {
         unsigned int mtime = QFileInfo(dir).lastModified().toTime_t();
         if (timestamp < mtime) {
             timestamp = mtime;
@@ -250,7 +250,7 @@
 
     // Save internal names and dirs of all themes
     d->mThemeNames.clear();
-    foreach (KIconTheme* theme, themes) {
+    Q_FOREACH (KIconTheme* theme, themes) {
         d->mThemeNames.append(theme->internalName());
     }
     d->mThemeDirs = existingIconThemeDirs(d->mThemeNames);
Index: kdeui/icons/kiconloader.cpp
===================================================================
--- kdeui/icons/kiconloader.cpp	(revisión: 797670)
+++ kdeui/icons/kiconloader.cpp	(copia de trabajo)
@@ -259,7 +259,7 @@
     QPainter painter(&pix);
 
     int count = 0;
-    foreach (const QString& overlay, overlays) {
+    Q_FOREACH (const QString& overlay, overlays) {
         // Ensure empty strings fill up a emblem spot
         // Needed when you have several emblems to ensure they're always painted
         // at the same place, even if one is not here
@@ -399,7 +399,7 @@
     if (!mIconCache->isValid()) {
         initIconThemes();
         QList<KIconTheme*> allThemes;
-        foreach (KIconThemeNode* node, links) {
+        Q_FOREACH (KIconThemeNode* node, links) {
             allThemes.append(node->theme);
         }
         mIconCache->setThemeInfo(allThemes);
@@ -735,7 +735,7 @@
     const char * const ext[4] = { ".png", ".svgz", ".svg", ".xpm" };
 #endif
 
-    foreach(KIconThemeNode *themeNode, links)
+    Q_FOREACH(KIconThemeNode *themeNode, links)
     {
         QStringList nameParts = name.split("-");
         QString currentName = name;
@@ -1269,7 +1269,7 @@
 
         K3Icon icon;
 
-        foreach(KIconThemeNode *themeNode, d->links)
+        Q_FOREACH(KIconThemeNode *themeNode, d->links)
         {
             icon = themeNode->theme->iconPath(file, size, KIconLoader::MatchExact);
             if (icon.isValid())
@@ -1278,7 +1278,7 @@
 
         if ( !icon.isValid() )
         {
-            foreach(KIconThemeNode *themeNode, d->links)
+            Q_FOREACH(KIconThemeNode *themeNode, d->links)
             {
                 icon = themeNode->theme->iconPath(file, size, KIconLoader::MatchBest);
                 if (icon.isValid())
@@ -1394,7 +1394,7 @@
     else
         size = -group_or_size;
 
-    foreach(KIconThemeNode *themeNode, d->links)
+    Q_FOREACH(KIconThemeNode *themeNode, d->links)
        themeNode->queryIconsByContext(&result, size, context);
 
     // Eliminate duplicate entries (same icon in different directories)
@@ -1435,7 +1435,7 @@
     else
         size = -group_or_size;
 
-    foreach(KIconThemeNode *themeNode, d->links)
+    Q_FOREACH(KIconThemeNode *themeNode, d->links)
        themeNode->queryIcons(&result, size, context);
 
     // Eliminate duplicate entries (same icon in different directories)
@@ -1462,7 +1462,7 @@
 // used by KIconDialog to find out which contexts to offer in a combobox
 bool KIconLoader::hasContext(KIconLoader::Context context) const
 {
-    foreach(KIconThemeNode *themeNode, d->links)
+    Q_FOREACH(KIconThemeNode *themeNode, d->links)
        if( themeNode->theme->hasContext( context ))
            return true;
     return false;
Index: kdeui/itemviews/kextendableitemdelegate.cpp
===================================================================
--- kdeui/itemviews/kextendableitemdelegate.cpp	(revisión: 797670)
+++ kdeui/itemviews/kextendableitemdelegate.cpp	(copia de trabajo)
@@ -348,7 +348,7 @@
 
 void KExtendableItemDelegate::Private::deleteExtenders()
 {
-	foreach (QWidget *ext, extenders.values()) {
+	Q_FOREACH (QWidget *ext, extenders.values()) {
 		// Don't call _k_extenderDestructionHandler because (???)
 		// disconnect(ext, SIGNAL(destroyed(QObject *)), q, SLOT(_k_extenderDestructionHandler(QObject *)));
 		ext->hide();
Index: kdeui/itemviews/kcategorizedview.cpp
===================================================================
--- kdeui/itemviews/kcategorizedview.cpp	(revisión: 797670)
+++ kdeui/itemviews/kcategorizedview.cpp	(copia de trabajo)
@@ -207,7 +207,7 @@
         row = elementsInfo[index.row()].relativeOffsetToCategory / elementsPerRow;
     }
 
-    foreach (const QString &category, categories)
+    Q_FOREACH (const QString &category, categories)
     {
         if (category == curCategory)
             break;
@@ -300,7 +300,7 @@
         elementsPerRow = 1;
     }
 
-    foreach (const QString &itCategory, categories)
+    Q_FOREACH (const QString &itCategory, categories)
     {
         if (itCategory == category)
             break;
@@ -459,7 +459,7 @@
 {
     QStyleOptionViewItemV3 option = listView->viewOptions();
     option.state &= ~QStyle::State_MouseOver;
-    foreach (const QModelIndex &index, listView->selectionModel()->selectedIndexes())
+    Q_FOREACH (const QModelIndex &index, listView->selectionModel()->selectedIndexes())
     {
         const int dx = mousePosition.x() - initialPressPosition.x() + listView->horizontalOffset();
         const int dy = mousePosition.y() - initialPressPosition.y() + listView->verticalOffset();
@@ -506,7 +506,7 @@
 {
     QRect rectToUpdate;
     QRect currentRect;
-    foreach (const QModelIndex &index, listView->selectionModel()->selectedIndexes())
+    Q_FOREACH (const QModelIndex &index, listView->selectionModel()->selectedIndexes())
     {
         int dx = mousePosition.x() - initialPressPosition.x() + listView->horizontalOffset();
         int dy = mousePosition.y() - initialPressPosition.y() + listView->verticalOffset();
@@ -741,7 +741,7 @@
     painter.save();
 
     QModelIndexList dirtyIndexes = d->intersectionSet(area);
-    foreach (const QModelIndex &index, dirtyIndexes)
+    Q_FOREACH (const QModelIndex &index, dirtyIndexes)
     {
         option.state = state;
         option.rect = visualRect(index);
@@ -787,7 +787,7 @@
     // Redraw categories
     QStyleOptionViewItem otherOption;
     bool intersectedInThePast = false;
-    foreach (const QString &category, d->categories)
+    Q_FOREACH (const QString &category, d->categories)
     {
         otherOption = option;
         otherOption.rect = d->categoryVisualRect(category);
@@ -906,7 +906,7 @@
 
         QModelIndex prev = dirtyIndexes[0];
         QModelIndex first = prev;
-        foreach (const QModelIndex &index, dirtyIndexes)
+        Q_FOREACH (const QModelIndex &index, dirtyIndexes)
         {
             // we have a different interval. non-contiguous items
             if ((index.row() - prev.row()) > 1) {
@@ -979,7 +979,7 @@
         int first = model()->rowCount();
         int last = 0;
 
-        foreach (const QModelIndex &index, theoricDirty)
+        Q_FOREACH (const QModelIndex &index, theoricDirty)
         {
             if ((index.row() < first) &&
                 ((((topLeftIndex.row() / elementsPerRow) == (index.row() / elementsPerRow)) &&
@@ -1037,7 +1037,7 @@
     d->hoveredCategory = QString();
 
     // Redraw categories
-    foreach (const QString &category, d->categories)
+    Q_FOREACH (const QString &category, d->categories)
     {
         if (d->categoryVisualRect(category).intersects(QRect(event->pos(), event->pos())))
         {
@@ -1125,14 +1125,14 @@
     if ((selectionMode() != SingleSelection) && (selectionMode() != NoSelection) &&
         (initialPressPosition == d->initialPressPosition))
     {
-        foreach(const QString &category, d->categories)
+        Q_FOREACH(const QString &category, d->categories)
         {
             if (d->categoryVisualRect(category).contains(event->pos()))
             {
                 QItemSelection selection = selectionModel()->selection();
                 QModelIndexList indexList = d->categoriesIndexes[category];
 
-                foreach (const QModelIndex &index, indexList)
+                Q_FOREACH (const QModelIndex &index, indexList)
                 {
                     QModelIndex selectIndex = index.model()->index(index.row(), 0);
 
@@ -1313,7 +1313,7 @@
     QString afterCategory = d->categories.first();
 
     bool hasToBreak = false;
-    foreach (const QString &category, d->categories)
+    Q_FOREACH (const QString &category, d->categories)
     {
         if (hasToBreak)
         {
Index: kdeui/itemviews/ktreewidgetsearchline.cpp
===================================================================
--- kdeui/itemviews/ktreewidgetsearchline.cpp	(revisión: 797670)
+++ kdeui/itemviews/ktreewidgetsearchline.cpp	(copia de trabajo)
@@ -90,7 +90,7 @@
     return;
 
   QTreeWidget* widget = 0L;
-  foreach ( QTreeWidget* tree, treeWidgets )
+  Q_FOREACH ( QTreeWidget* tree, treeWidgets )
     if ( tree->model() == model ) {
       widget = tree;
       break;
@@ -317,7 +317,7 @@
 {
   d->search = pattern.isNull() ? text() : pattern;
 
-  foreach ( QTreeWidget* treeWidget, d->treeWidgets )
+  Q_FOREACH ( QTreeWidget* treeWidget, d->treeWidgets )
     updateSearch( treeWidget );
 }
 
@@ -372,12 +372,12 @@
 
 void KTreeWidgetSearchLine::setTreeWidgets( const QList<QTreeWidget *> &treeWidgets )
 {
-  foreach ( QTreeWidget* treeWidget, d->treeWidgets )
+  Q_FOREACH ( QTreeWidget* treeWidget, d->treeWidgets )
     disconnectTreeWidget( treeWidget );
 
   d->treeWidgets = treeWidgets;
 
-  foreach ( QTreeWidget* treeWidget, d->treeWidgets )
+  Q_FOREACH ( QTreeWidget* treeWidget, d->treeWidgets )
     connectTreeWidget( treeWidget );
 
   d->checkColumns();
Index: kdeui/util/knotificationmanager.cpp
===================================================================
--- kdeui/util/knotificationmanager.cpp	(revisión: 797670)
+++ kdeui/util/knotificationmanager.cpp	(copia de trabajo)
@@ -125,7 +125,7 @@
 
     QVariantList contextList;
     typedef QPair<QString,QString> Context;
-    foreach (const Context& ctx, contexts)
+    Q_FOREACH (const Context& ctx, contexts)
     {
         QVariantList vl;
         vl << ctx.first << ctx.second;
@@ -160,7 +160,7 @@
 {
 	QVariantList contextList;
 	typedef QPair<QString,QString> Context;
-	foreach (const Context& ctx, n->contexts())
+	Q_FOREACH (const Context& ctx, n->contexts())
 	{
 //		kDebug(299) << "add context " << ctx.first << "-" << ctx.second;
 		QVariantList vl;
Index: security/kcert/kcertpart.cc
===================================================================
--- security/kcert/kcertpart.cc	(revisión: 797670)
+++ security/kcert/kcertpart.cc	(copia de trabajo)
@@ -628,7 +628,7 @@
 		_p12_chain->setEnabled(true);
 		_p12_chain->clear();
 		_p12_chain->addItem(i18n("0 - Site Certificate"));
-		foreach (KSSLCertificate *c, cl) {
+		Q_FOREACH (KSSLCertificate *c, cl) {
 			KSSLX509Map map(c->getSubject());
 			_p12_chain->addItem(QString::number(++cnt)+" - "+map.getValue("CN"));
 		}
Index: kutils/kpluginselector.cpp
===================================================================
--- kutils/kpluginselector.cpp	(revisión: 797670)
+++ kutils/kpluginselector.cpp	(copia de trabajo)
@@ -107,7 +107,7 @@
 
 void KPluginSelector::Private::checkIfShowIcons(const QList<KPluginInfo> &pluginInfoList)
 {
-    foreach (const KPluginInfo &pluginInfo, pluginInfoList)
+    Q_FOREACH (const KPluginInfo &pluginInfo, pluginInfoList)
     {
         if (!KIconLoader::global()->iconPath(pluginInfo.icon(), KIconLoader::NoGroup, true).isNull())
         {
@@ -222,7 +222,7 @@
 void KPluginSelector::Private::DependenciesWidget::showDependencyDetails()
 {
     QString message = i18n("Automatic changes have been performed in order to satisfy plugin dependencies:\n");
-    foreach(const QString &dependency, dependencyMap.keys())
+    Q_FOREACH(const QString &dependency, dependencyMap.keys())
     {
         if (dependencyMap[dependency].added)
             message += i18n("\n    %1 plugin has been automatically checked because of the dependency of %2 plugin", dependency, dependencyMap[dependency].pluginCausant);
@@ -318,7 +318,7 @@
     KConfigGroup providedConfigGroup;
     int addedPlugins = 0;
     bool alternateColor = pluginCount.contains(categoryName) ? ((pluginCount[categoryName] % 2) != 0) : false;
-    foreach (KPluginInfo pluginInfo, pluginInfoList)
+    Q_FOREACH (KPluginInfo pluginInfo, pluginInfoList)
     {
         if (!pluginInfo.isHidden() &&
              ((myCategoryKey.isEmpty()) ||
@@ -436,7 +436,7 @@
 
             case Qt::DisplayRole:
                 int currentPosition = 0;
-                foreach (const QString &category, pluginInfoByCategory.keys())
+                Q_FOREACH (const QString &category, pluginInfoByCategory.keys())
                 {
                     if (currentPosition == index.row())
                         return category;
@@ -468,12 +468,12 @@
     if ((row < 0) || (row >= rowCount()))
         return QModelIndex();
 
-    foreach (const QString &category, pluginInfoByCategory.keys())
+    Q_FOREACH (const QString &category, pluginInfoByCategory.keys())
     {
         if (currentPosition == row)
             return createIndex(row, column, 0); // Is a category
 
-        foreach (const KPluginInfo &pluginInfo, pluginInfoByCategory[category])
+        Q_FOREACH (const KPluginInfo &pluginInfo, pluginInfoByCategory[category])
         {
             currentPosition++;
 
@@ -493,7 +493,7 @@
 
     int retValue = pluginInfoByCategory.count(); // We have pluginInfoCategory.count() categories
 
-    foreach (const QString &category, pluginInfoByCategory.keys())
+    Q_FOREACH (const QString &category, pluginInfoByCategory.keys())
     {
         if (pluginCount.contains(category))
             retValue += pluginCount[category];
@@ -550,7 +550,7 @@
                     dependenciesPushed.append(pluginInfo.name());
                 }
 
-                foreach(const QString &indirectDependency, pluginInfo.dependencies())
+                Q_FOREACH(const QString &indirectDependency, pluginInfo.dependencies())
                 {
                     updateDependencies(indirectDependency, pluginInfo.name(), whatDependencies, dependenciesPushed);
                 }
@@ -1549,7 +1549,7 @@
             // The first proxy is owned by the dialog itself
             QWidget * moduleProxyParentWidget = configDialog;
 
-            foreach(KService::Ptr servicePtr, services)
+            Q_FOREACH(KService::Ptr servicePtr, services)
             {
                 if(!servicePtr->noDisplay())
                 {
@@ -1605,10 +1605,10 @@
 
         if (configDialog->exec() == QDialog::Accepted)
         {
-            foreach (KCModuleProxy *moduleProxy, modulesDialogs[index.row()])
+            Q_FOREACH (KCModuleProxy *moduleProxy, modulesDialogs[index.row()])
             {
                 moduleProxy->save();
-                foreach (const QString &parentComponent, model->parentComponents(index))
+                Q_FOREACH (const QString &parentComponent, model->parentComponents(index))
                 {
                     emit configCommitted(parentComponent.toLatin1());
                 }
@@ -1616,7 +1616,7 @@
         }
         else
         {
-            foreach (KCModuleProxy *moduleProxy, modulesDialogs[index.row()])
+            Q_FOREACH (KCModuleProxy *moduleProxy, modulesDialogs[index.row()])
             {
                 moduleProxy->load();
             }
@@ -1748,7 +1748,7 @@
 
     if (whatDependencies == DependenciesINeed)
     {
-        foreach(const QString &dependency, info.dependencies())
+        Q_FOREACH(const QString &dependency, info.dependencies())
         {
             model->updateDependencies(dependency, info.name(), whatDependencies, dependenciesPushed);
         }
Index: kutils/kcmultidialog.cpp
===================================================================
--- kutils/kcmultidialog.cpp	(revisión: 797670)
+++ kutils/kcmultidialog.cpp	(copia de trabajo)
@@ -185,7 +185,7 @@
     Q_Q(KCMultiDialog);
     QStringList updatedComponents;
 
-    foreach (const CreatedModule &module, modules) {
+    Q_FOREACH (const CreatedModule &module, modules) {
         KCModuleProxy *proxy = module.kcm;
 
         if (proxy->changed()) {
@@ -196,7 +196,7 @@
              * of updated components.
              */
             const QStringList componentNames = module.componentNames;
-            foreach (const QString &componentName, module.componentNames) {
+            Q_FOREACH (const QString &componentName, module.componentNames) {
                 if (!updatedComponents.contains(componentName)) {
                     updatedComponents.append(componentName);
                 }
@@ -205,7 +205,7 @@
     }
 
     // Send the configCommitted signal for every updated component.
-    foreach (const QString &name, updatedComponents) {
+    Q_FOREACH (const QString &name, updatedComponents) {
         emit q->configCommitted(name.toLatin1());
     }
 
Index: kutils/ksettings/dialog.cpp
===================================================================
--- kutils/ksettings/dialog.cpp	(revisión: 797670)
+++ kutils/ksettings/dialog.cpp	(copia de trabajo)
@@ -88,7 +88,7 @@
     for (KPluginInfo::List::ConstIterator it = plugininfos.begin();
             it != plugininfos.end(); ++it ) {
         d->registeredComponents.append(it->pluginName());
-        foreach (const KService::Ptr &service, it->kcmServices()) {
+        Q_FOREACH (const KService::Ptr &service, it->kcmServices()) {
             d->kcmInfos << KCModuleInfo(service);
         }
     }
@@ -171,7 +171,7 @@
     //kDebug(700) << "constraint = " << constraint;
     const QList<KService::Ptr> services = KServiceTypeTrader::self()->query("KCModule", constraint);
     QSet<KCModuleInfo> ret;
-    foreach (const KService::Ptr &service, services) {
+    Q_FOREACH (const KService::Ptr &service, services) {
         ret << KCModuleInfo(service);
     }
     return ret;
@@ -216,7 +216,7 @@
     Q_Q(Dialog);
 	KConfig file( filename, KConfig::SimpleConfig );
     const QStringList groups = file.groupList();
-    foreach (const QString &group, groups) {
+    Q_FOREACH (const QString &group, groups) {
         if (group.isEmpty()) {
             continue;
         }
@@ -295,10 +295,10 @@
     }
 
     //kDebug(700) << kcmInfos.count();
-    foreach (const KCModuleInfo &info, kcmInfos) {
+    Q_FOREACH (const KCModuleInfo &info, kcmInfos) {
         const QStringList parentComponents = info.service()->property("X-KDE-ParentComponents").toStringList();
         bool blacklisted = false;
-        foreach (const QString &parentComponent, parentComponents) {
+        Q_FOREACH (const QString &parentComponent, parentComponents) {
             if (componentBlacklist.contains(parentComponent)) {
                 blacklisted = true;
                 break;
@@ -311,7 +311,7 @@
         KPageWidgetItem *parent = pageItemForGroupId.value(parentId);
         KPageWidgetItem *item = q->addModule(info, parent, arguments);
         kDebug(700) << "added KCM '" << info.moduleName() << "'";
-        foreach (KPluginInfo pinfo, plugininfos) {
+        Q_FOREACH (KPluginInfo pinfo, plugininfos) {
             kDebug(700) << pinfo.pluginName();
             if (pinfo.kcmServices().contains(info.service())) {
                 const bool isEnabled = isPluginForKCMEnabled(&info, pinfo);
Index: kutils/ksettings/dispatcher.cpp
===================================================================
--- kutils/ksettings/dispatcher.cpp	(revisión: 797670)
+++ kutils/ksettings/dispatcher.cpp	(copia de trabajo)
@@ -89,7 +89,7 @@
     // will be up to date
     KSharedConfig::Ptr config = d->m_componentInfo[componentName].componentData.config();
     config->reparseConfiguration();
-    foreach(const ComponentInfo::Slot& slot, d->m_componentInfo[componentName].slotList ) {
+    Q_FOREACH(const ComponentInfo::Slot& slot, d->m_componentInfo[componentName].slotList ) {
         QMetaObject::invokeMethod(slot.first, slot.second);
     }
 }
Index: kutils/kcmoduleloader.cpp
===================================================================
--- kutils/kcmoduleloader.cpp	(revisión: 797670)
+++ kutils/kcmoduleloader.cpp	(copia de trabajo)
@@ -84,7 +84,7 @@
   {
         QString error;
         QVariantList args2;
-        foreach (const QString &arg, args) {
+        Q_FOREACH (const QString &arg, args) {
             args2 << arg;
         }
         KCModule *module = KService::createInstance<KCModule>(mod.service(), parent, args2, &error);
Index: kdecore/kernel/ktoolinvocation_win.cpp
===================================================================
--- kdecore/kernel/ktoolinvocation_win.cpp	(revisión: 797670)
+++ kdecore/kernel/ktoolinvocation_win.cpp	(copia de trabajo)
@@ -50,7 +50,7 @@
   url.addQueryItem("cc", _cc);
   url.addQueryItem("bcc", _bcc);
   url.addQueryItem("body", body);
-  foreach (const QString& attachURL, attachURLs)
+  Q_FOREACH (const QString& attachURL, attachURLs)
     url.addQueryItem("attach", QLatin1String( KUrl::toPercentEncoding(attachURL) ));
 
    QString sOpen( "open" );
Index: kdecore/kernel/kauthorized.cpp
===================================================================
--- kdecore/kernel/kauthorized.cpp	(revisión: 797670)
+++ kdecore/kernel/kauthorized.cpp	(copia de trabajo)
@@ -370,7 +370,7 @@
   destURL.setPath(QDir::cleanPath(destURL.path()));
   QString destClass = KProtocolInfo::protocolClass(destURL.protocol());
 
-  foreach(const URLActionRule &rule, d->urlActionRestrictions) {
+  Q_FOREACH(const URLActionRule &rule, d->urlActionRestrictions) {
      if ((result != rule.permission) && // No need to check if it doesn't make a difference
          (action == rule.action) &&
          rule.baseMatch(baseURL, baseClass) &&
Index: kdecore/kernel/kstandarddirs.cpp
===================================================================
--- kdecore/kernel/kstandarddirs.cpp	(revisión: 797670)
+++ kdecore/kernel/kstandarddirs.cpp	(copia de trabajo)
@@ -470,7 +470,7 @@
     QStringList candidates = resourceDirs(type);
     QString fullPath;
 
-    foreach ( const QString& candidate, candidates )
+    Q_FOREACH ( const QString& candidate, candidates )
     {
         hash = updateHash(candidate + filename, hash);
         if (  !( options & Recursive ) && hash ) {
@@ -794,7 +794,7 @@
 
     QRegExp regExp(filterFile, Qt::CaseSensitive, QRegExp::Wildcard);
 
-    foreach ( const QString& candidate, candidates )
+    Q_FOREACH ( const QString& candidate, candidates )
     {
         lookupPrefix(candidate, filterPath, "", regExp, list,
                      relList, options & Recursive, options & NoDuplicates);
@@ -1014,7 +1014,7 @@
         QString installdir = installPath( type );
         if (!installdir.isEmpty()) {
             bool ok = true;
-            foreach (const QString &s, candidates) {
+            Q_FOREACH (const QString &s, candidates) {
                 if (installdir.startsWith(s)) {
                     ok = false;
                     break;
@@ -1431,7 +1431,7 @@
     QSettings iniFile(localFile, QSettings::IniFormat);
     iniFile.beginGroup("KStandardDirs");
     const QStringList resources = iniFile.allKeys();
-    foreach(const QString &key, resources)
+    Q_FOREACH(const QString &key, resources)
     {
         QDir path(iniFile.value(key).toString());
         if (!path.exists())
Index: kdecore/services/kmimetype.cpp
===================================================================
--- kdecore/services/kmimetype.cpp	(revisión: 797670)
+++ kdecore/services/kmimetype.cpp	(copia de trabajo)
@@ -322,7 +322,7 @@
                 // "for glob_match in glob_matches:"
                 // "if glob_match is subclass or equal to sniffed_type, use glob_match"
                 const QString sniffedMime = mime->name();
-                foreach(KMimeType::Ptr mimeFromPattern, mimeList) {
+                Q_FOREACH(KMimeType::Ptr mimeFromPattern, mimeList) {
                     //kDebug(7009) << "sniffedMime=" << sniffedMime << "mimeFromPattern=" << mimeFromPattern->name();
                     if (mimeFromPattern->is(sniffedMime)) {
                         // We have magic + pattern pointing to this, so it's a pretty good match
@@ -602,7 +602,7 @@
     if (mime && m_strName == mime->d_func()->m_strName) {
         return true;
     }
-    foreach( const QString& parent, parentMimeTypes() ) {
+    Q_FOREACH( const QString& parent, parentMimeTypes() ) {
         KMimeType::Ptr parentMime = KMimeTypeFactory::self()->findMimeTypeByName(parent);
         if (!parentMime) // error
             return false;
Index: kdecore/services/ktraderparsetree.cpp
===================================================================
--- kdecore/services/ktraderparsetree.cpp	(revisión: 797670)
+++ kdecore/services/ktraderparsetree.cpp	(copia de trabajo)
@@ -476,7 +476,7 @@
   {
       if (false && m_substring) {
           _context->b = false;
-          foreach (const QString &string, c2.strSeq) {
+          Q_FOREACH (const QString &string, c2.strSeq) {
               if (string.contains(c1.str, m_cs)) {
                   _context->b = true;
                   break;
Index: kdecore/services/kservicegroup.cpp
===================================================================
--- kdecore/services/kservicegroup.cpp	(revisión: 797670)
+++ kdecore/services/kservicegroup.cpp	(copia de trabajo)
@@ -313,7 +313,7 @@
     bool sort = options & SortEntries || options & AllowSeparators;
     QList<KServiceGroup::Ptr> list;
     List tmp = d->entries(this, sort, options & ExcludeNoDisplay, options & AllowSeparators, options & SortByGenericName);
-    foreach(const SPtr &ptr, tmp) {
+    Q_FOREACH(const SPtr &ptr, tmp) {
         if (ptr->isType(KST_KServiceGroup))
             list.append(Ptr::staticCast(ptr));
         else if (ptr->isType(KST_KServiceSeparator))
@@ -331,7 +331,7 @@
     QList<KService::Ptr> list;
     List tmp = d->entries(this, sort, options & ExcludeNoDisplay, options & AllowSeparators, options & SortByGenericName);
     bool foundService = false;
-    foreach(const SPtr &ptr, tmp) {
+    Q_FOREACH(const SPtr &ptr, tmp) {
         if (ptr->isType(KST_KService)) {
             list.append(KService::Ptr::staticCast(ptr));
             foundService = true;
Index: kdecore/services/kmimetypefactory.cpp
===================================================================
--- kdecore/services/kmimetypefactory.cpp	(revisión: 797670)
+++ kdecore/services/kmimetypefactory.cpp	(copia de trabajo)
@@ -172,7 +172,7 @@
     // Warning : this assumes we're NOT building a database
 
     const QList<int> offsetList = m_fastPatternDict->findMultiString(extension);
-    foreach(int offset, offsetList) {
+    Q_FOREACH(int offset, offsetList) {
         KMimeType::Ptr newMimeType(createEntry(offset));
         // Check whether the dictionary was right.
         if (newMimeType && newMimeType->patterns().contains("*."+extension)) {
Index: kdecore/localization/ktranscript.cpp
===================================================================
--- kdecore/localization/ktranscript.cpp	(revisión: 797670)
+++ kdecore/localization/ktranscript.cpp	(copia de trabajo)
@@ -362,7 +362,7 @@
 {
     // FIXME: vallgrind shows an afwul lot of "invalid read" in WTF:: stuff
     // when deref is called... Are we leaking somewhere?
-    //foreach (Scriptface *sface, m_sface.values())
+    //Q_FOREACH (Scriptface *sface, m_sface.values())
     //    sface->jsi->deref();
 }
 
@@ -516,7 +516,7 @@
 {
     QList<QString> modErrors;
 
-    foreach (const QStringList &mod, mods)
+    Q_FOREACH (const QStringList &mod, mods)
     {
         QString mpath = mod[0];
         QString mlang = mod[1];
@@ -557,7 +557,7 @@
     // Unset module path.
     currentModulePath.clear();
 
-    foreach (const QString &merr, modErrors)
+    Q_FOREACH (const QString &merr, modErrors)
         error.append(merr + '\n');
 }
 
@@ -1256,7 +1256,7 @@
 
                     // Add collected entry into global store,
                     // once for each entry key (QHash implicitly shared).
-                    foreach (const QByteArray &ekey, ekeys) {
+                    Q_FOREACH (const QByteArray &ekey, ekeys) {
                         phraseProps[ekey] = props;
                     }
 
@@ -1389,7 +1389,7 @@
 
         // Add collected entry into global store,
         // once for each entry key (QHash implicitly shared).
-        foreach (const QByteArray &ekey, ekeys) {
+        Q_FOREACH (const QByteArray &ekey, ekeys) {
             phraseProps[ekey] = props;
         }
     }
Index: kdecore/localization/klocalizedstring.cpp
===================================================================
--- kdecore/localization/klocalizedstring.cpp	(revisión: 797670)
+++ kdecore/localization/klocalizedstring.cpp	(copia de trabajo)
@@ -306,7 +306,7 @@
     if (s->ktrs != NULL)
     {
         QStringList pcalls = s->ktrs->postCalls(lang);
-        foreach(const QString &pcall, pcalls)
+        Q_FOREACH(const QString &pcall, pcalls)
             postTranscript(pcall, lang, lscr, final);
     }
 
@@ -964,7 +964,7 @@
     // A more specific module may reference the calls from a less specific,
     // and the catalog list is ordered from more to less specific. Therefore,
     // work on reversed list of catalogs.
-    foreach (const QString &lang, languages) {
+    Q_FOREACH (const QString &lang, languages) {
         for (int i = catalogs.size() - 1; i >= 0; --i) {
             const KCatalogName &cat(catalogs[i]);
 
@@ -993,7 +993,7 @@
     }
 
     // Create writing script transliterators for each new language.
-    foreach (const QString &lang, languages) {
+    Q_FOREACH (const QString &lang, languages) {
         if (!s->translits.contains(lang)) {
             KTranslit *t = KTranslit::create(lang);
             if (t != NULL) {
@@ -1003,7 +1003,7 @@
     }
 
     // Create visual formatters for each new language.
-    foreach (const QString &lang, languages) {
+    Q_FOREACH (const QString &lang, languages) {
         if (!s->formatters.contains(lang)) {
             s->formatters.insert(lang, new KuitSemantics(lang));
         }
Index: kdecore/localization/klocale.cpp
===================================================================
--- kdecore/localization/klocale.cpp	(revisión: 797670)
+++ kdecore/localization/klocale.cpp	(copia de trabajo)
@@ -337,7 +337,7 @@
 #endif
   {
     // Process the raw list to create possible combinations.
-    foreach (const QString &ln, rawList) {
+    Q_FOREACH (const QString &ln, rawList) {
       QString lang, ctry, modf, cset;
       KLocale::splitLocale(ln, lang, ctry, modf, cset);
 
@@ -498,7 +498,7 @@
   //    but nothing from appname.mo, you get a mostly English app with layout from right to left.
   //    That was considered to be a bug by the Hebrew translators.
   QStringList list;
-  foreach (const QString &language, languages) {
+  Q_FOREACH (const QString &language, languages) {
       if (!language.isEmpty() && !list.contains(language) && isApplicationTranslatedInto(language)) {
           list.append(language);
       }
@@ -546,7 +546,7 @@
   QStringList possibles;
   possibles += lang;
   possibles += KTranslit::fallbackList(lang);
-  foreach (const QString &lang, possibles) {
+  Q_FOREACH (const QString &lang, possibles) {
     if ( ! KCatalog::catalogLocaleDir( appName, lang ).isEmpty() ) {
         return true;
     }
@@ -630,7 +630,7 @@
 
   // Insert possible transliteration fallbacks after each set language.
   QStringList languageListFB;
-  foreach (const QString &lang, languageList) {
+  Q_FOREACH (const QString &lang, languageList) {
     languageListFB += lang;
     languageListFB += KTranslit::fallbackList(lang);
   }
@@ -639,8 +639,8 @@
   // the sequence must be e.g. nds/appname nds/kdelibs nds/kio de/appname de/kdelibs de/kio etc.
   // and not nds/appname de/appname nds/kdelibs de/kdelibs etc. Otherwise we would be in trouble with a language
   // sequende nds,en_US, de. In this case en_US must hide everything below in the language list.
-  foreach ( const QString &lang, languageListFB )
-    foreach ( const KCatalogName &name, catalogNames )
+  Q_FOREACH ( const QString &lang, languageListFB )
+    Q_FOREACH ( const KCatalogName &name, catalogNames )
       // create and add catalog for this name and language if it exists
       if ( ! KCatalog::catalogLocaleDir( name.name, lang ).isEmpty() )
       {
@@ -2341,7 +2341,7 @@
     // Go through possible localized paths by priority of languages,
     // return first that exists.
     QString fileName = fileInfo.fileName();
-    foreach (const QString &lang, d->languageList) {
+    Q_FOREACH (const QString &lang, d->languageList) {
         // Stop when the default language is reached.
         if (lang == KLocale::defaultLanguage()) {
             return filePath;
Index: kdecore/localization/ktranslit.cpp
===================================================================
--- kdecore/localization/ktranslit.cpp	(revisión: 797670)
+++ kdecore/localization/ktranslit.cpp	(copia de trabajo)
@@ -87,7 +87,7 @@
     // Search through higher priority languages.
     QString finalScrHi;
     if (lang != KLocale::defaultLanguage()) {
-        foreach (const QString &langHi, locale->languageList()) {
+        Q_FOREACH (const QString &langHi, locale->languageList()) {
             // Don't search lower priority languages.
             if (langHi == lang)
                 break;
Index: kdecore/localization/kuitsemantics.cpp
===================================================================
--- kdecore/localization/kuitsemantics.cpp	(revisión: 797670)
+++ kdecore/localization/kuitsemantics.cpp	(copia de trabajo)
@@ -891,7 +891,7 @@
     qSort(alist);
     int key = 0;
     int tenp = 1;
-    foreach (const Kuit::AttVar &att, alist) {
+    Q_FOREACH (const Kuit::AttVar &att, alist) {
         key += att * tenp;
         tenp *= 10;
     }
@@ -1190,7 +1190,7 @@
 
     // Collect attribute names and values, and format attribute string.
     QStringList attnams, attvals;
-    foreach (const QXmlStreamAttribute &xatt, xml.attributes()) {
+    Q_FOREACH (const QXmlStreamAttribute &xatt, xml.attributes()) {
         attnams += xatt.name().toString().toLower();
         attvals += xatt.value().toString();
         QChar qc = attvals.last().indexOf('\'') < 0 ? '\'' : '"';
Index: kdecore/network/ktcpsocket.cpp
===================================================================
--- kdecore/network/ktcpsocket.cpp	(revisión: 797670)
+++ kdecore/network/ktcpsocket.cpp	(copia de trabajo)
@@ -74,7 +74,7 @@
 public:
     CipherCc()
     {
-        foreach (const QSslCipher &c, QSslSocket::supportedCiphers()) {
+        Q_FOREACH (const QSslCipher &c, QSslSocket::supportedCiphers()) {
             allCiphers.insert(c.name(), c);
         }
     }
@@ -479,7 +479,7 @@
     //    duplicates even though there were none in the original list because KSslError
     //    has a smallest common denominator range of SSL error codes.
     QList<KSslError> ret;
-    foreach (const QSslError &e, d->sock.sslErrors())
+    Q_FOREACH (const QSslError &e, d->sock.sslErrors())
         ret.append(KSslError(e));
     return ret;
 }
@@ -642,7 +642,7 @@
 void KTcpSocket::setCiphers(const QList<KSslCipher> &ciphers)
 {
     QList<QSslCipher> cl;
-    foreach (const KSslCipher &c, d->ciphers) {
+    Q_FOREACH (const KSslCipher &c, d->ciphers) {
         cl.append(d->ccc.converted(c));
     }
     d->sock.setCiphers(cl);
@@ -711,7 +711,7 @@
 //debugging H4X
 void KTcpSocket::showSslErrors()
 {
-	foreach (const QSslError &e, d->sock.sslErrors())
+	Q_FOREACH (const QSslError &e, d->sock.sslErrors())
 		kDebug(7029) << e.errorString();
 }
 
@@ -954,7 +954,7 @@
 {
     QList<KSslCipher> ret;
     QList<QSslCipher> candidates = QSslSocket::supportedCiphers();
-    foreach(const QSslCipher &c, candidates) {
+    Q_FOREACH(const QSslCipher &c, candidates) {
         ret.append(KSslCipher(c));
     }
     return ret;
Index: kdecore/network/k3resolvermanager.cpp
===================================================================
--- kdecore/network/k3resolvermanager.cpp	(revisión: 797670)
+++ kdecore/network/k3resolvermanager.cpp	(copia de trabajo)
@@ -336,7 +336,7 @@
   // this should never be called
 
   // kill off running threads
-  foreach (KResolverThread* worker, workers)
+  Q_FOREACH (KResolverThread* worker, workers)
     worker->terminate();
 }
 
@@ -523,7 +523,7 @@
   // class and call their preprocessing functions. The first one that
   // says they can process (i.e., preprocess() returns true) will get the job.
 
-  foreach (KResolverWorkerFactoryBase *factory, workerFactories)
+  Q_FOREACH (KResolverWorkerFactoryBase *factory, workerFactories)
     {
       KResolverWorkerBase *worker = factory->create();
 
Index: kdecore/tests/kautosavefiletest.cpp
===================================================================
--- kdecore/tests/kautosavefiletest.cpp	(revisión: 797670)
+++ kdecore/tests/kautosavefiletest.cpp	(copia de trabajo)
@@ -30,7 +30,7 @@
 
 void KAutoSaveFileTest::cleanupTestCase()
 {
-    foreach (const QString &fileToRemove, filesToRemove) {
+    Q_FOREACH (const QString &fileToRemove, filesToRemove) {
         QFile::remove(fileToRemove);
     }
 }
Index: kdecore/tests/kservicetest.cpp
===================================================================
--- kdecore/tests/kservicetest.cpp	(revisión: 797670)
+++ kdecore/tests/kservicetest.cpp	(copia de trabajo)
@@ -227,7 +227,7 @@
     // Querying trader for services associated with KParts/ReadOnlyPart
     KService::List offers = KServiceTypeTrader::self()->query("KParts/ReadOnlyPart");
     QVERIFY( offers.count() > 0 );
-    //foreach( KService::Ptr service, offers )
+    //Q_FOREACH( KService::Ptr service, offers )
     //    qDebug( "%s %s", qPrintable( service->name() ), qPrintable( service->entryPath() ) );
 
     m_firstOffer = offers[0]->entryPath();
@@ -319,7 +319,7 @@
     KService::List offers = KServiceTypeTrader::self()->query( serviceType );
     QVERIFY( offers.count() > 0 ); // not empty
 
-    //foreach( KService::Ptr service, offers )
+    //Q_FOREACH( KService::Ptr service, offers )
     //    qDebug( "%s %s", qPrintable( service->name() ), qPrintable( service->entryPath() ) );
 
     QVERIFY( offers.count() >= 3 ); // at least 3, even
Index: kdecore/tests/kdatetimetest.cpp
===================================================================
--- kdecore/tests/kdatetimetest.cpp	(revisión: 797670)
+++ kdecore/tests/kdatetimetest.cpp	(copia de trabajo)
@@ -85,7 +85,7 @@
 void KDateTimeTest::removeDir(const QString &subdir)
 {
     QDir local = QDir::homePath() + QLatin1String("/.kde-unit-test/") + subdir;
-    foreach(const QString &file, local.entryList(QDir::Files))
+    Q_FOREACH(const QString &file, local.entryList(QDir::Files))
         if(!local.remove(file))
             qWarning("%s: removing failed", qPrintable( file ));
     QCOMPARE((int)local.entryList(QDir::Files).count(), 0);
Index: kdecore/tests/ksavefiletest.cpp
===================================================================
--- kdecore/tests/ksavefiletest.cpp	(revisión: 797670)
+++ kdecore/tests/ksavefiletest.cpp	(copia de trabajo)
@@ -376,7 +376,7 @@
 
 void KSaveFileTest::cleanupTestCase()
 {
-    foreach ( const QString &fileToRemove, filesToRemove ) {
+    Q_FOREACH ( const QString &fileToRemove, filesToRemove ) {
         QFile::remove(fileToRemove);
     }
 }
Index: kdecore/tests/kconfigtest.cpp
===================================================================
--- kdecore/tests/kconfigtest.cpp	(revisión: 797670)
+++ kdecore/tests/kconfigtest.cpp	(copia de trabajo)
@@ -195,7 +195,7 @@
 {
   QDir local = QDir::homePath() + "/.kde-unit-test/share/config";
 
-  foreach(const QString &file, local.entryList(QDir::Files))
+  Q_FOREACH(const QString &file, local.entryList(QDir::Files))
     if(!local.remove(file))
       qWarning("%s: removing failed", qPrintable( file ));
 
@@ -253,7 +253,7 @@
   QCOMPARE(sc2.name(), QString("kconfigtest"));
 
   // make sure groupList() isn't returning something it shouldn't
-  foreach(const QString& group, sc2.groupList())
+  Q_FOREACH(const QString& group, sc2.groupList())
       QVERIFY(!group.isEmpty() && group != "<default>");
 
   KConfigGroup sc3( &sc2, "AAA");
@@ -608,13 +608,13 @@
   cf.sync();
 
   int count=0;
-  foreach(const QByteArray& item, readLines())
+  Q_FOREACH(const QByteArray& item, readLines())
       if (item.startsWith("devices|"))
           count++;
   QVERIFY(count == 2);
   cg.deleteEntry("devices|manual|/mnt/ipod");
   cf.sync();
-  foreach(const QByteArray& item, readLines())
+  Q_FOREACH(const QByteArray& item, readLines())
       QVERIFY(!item.contains("ipod"));
 }
 
@@ -744,7 +744,7 @@
                 << "entry[fr]=French\n";
         QFile file(KStandardDirs::locateLocal("config", "mergetest"));
         file.open(QIODevice::ReadOnly|QIODevice::Text);
-        foreach (const QByteArray& line, lines) {
+        Q_FOREACH (const QByteArray& line, lines) {
             QCOMPARE(line, file.readLine());
         }
     }
Index: kdecore/tests/ksycocadicttest.cpp
===================================================================
--- kdecore/tests/ksycocadicttest.cpp	(revisión: 797670)
+++ kdecore/tests/ksycocadicttest.cpp	(copia de trabajo)
@@ -59,7 +59,7 @@
               << "application/msword";
     {
         KSycocaDict dict;
-        foreach(const QString& str, mimeTypes) {
+        Q_FOREACH(const QString& str, mimeTypes) {
             add(dict, str, str);
         }
         dict.remove("application/msword"); // just to test remove
@@ -74,7 +74,7 @@
     int offset = loadingDict.find_string("text/plain");
     QVERIFY(offset > 0);
     QCOMPARE(offset, KMimeType::mimeType("text/plain")->offset());
-    foreach(const QString& str, mimeTypes) {
+    Q_FOREACH(const QString& str, mimeTypes) {
         int offset = loadingDict.find_string(str);
         QVERIFY(offset > 0);
         QCOMPARE(offset, KMimeType::mimeType(str)->offset());
Index: kdecore/tests/ktimezonestest.cpp
===================================================================
--- kdecore/tests/ktimezonestest.cpp	(revisión: 797670)
+++ kdecore/tests/ktimezonestest.cpp	(copia de trabajo)
@@ -91,7 +91,7 @@
 void KTimeZonesTest::removeDir(const QString &subdir)
 {
     QDir local = QDir::homePath() + QLatin1String("/.kde-unit-test/") + subdir;
-    foreach(const QString &file, local.entryList(QDir::Files))
+    Q_FOREACH(const QString &file, local.entryList(QDir::Files))
         if(!local.remove(file))
             qWarning("%s: removing failed", qPrintable( file ));
     QCOMPARE((int)local.entryList(QDir::Files).count(), 0);
Index: kdecore/sonnet/textbreaks.cpp
===================================================================
--- kdecore/sonnet/textbreaks.cpp	(revisión: 797670)
+++ kdecore/sonnet/textbreaks.cpp	(copia de trabajo)
@@ -241,7 +241,7 @@
 
     QString modText = text;
     int off(0);
-    foreach(pos,breaks)
+    Q_FOREACH(pos,breaks)
     {
         modText.insert(pos+off, '|');
         ++off;
Index: kdecore/config/kconfig.cpp
===================================================================
--- kdecore/config/kconfig.cpp	(revisión: 797670)
+++ kdecore/config/kconfig.cpp	(copia de trabajo)
@@ -63,7 +63,7 @@
                           QString::fromLatin1("kdeglobals");
     if (wantGlobals()) {
         const KStandardDirs *const dirs = componentData.dirs();
-        foreach(const QString& dir, dirs->findAllResources("config", QLatin1String("kdeglobals")) +
+        Q_FOREACH(const QString& dir, dirs->findAllResources("config", QLatin1String("kdeglobals")) +
                                     dirs->findAllResources("config", QLatin1String("system.kdeglobals")))
             globalFiles.push_front(dir);
     }
@@ -121,7 +121,7 @@
     const int len = source.length();
     const bool sameName = (destination == source);
 
-    foreach (const KEntryKey& key, entryMap.keys()) {
+    Q_FOREACH (const KEntryKey& key, entryMap.keys()) {
         const QByteArray& group = key.mGroup;
 
         if (!group.startsWith(source)) // nothing to do
@@ -198,7 +198,7 @@
     Q_D(const KConfig);
     QStringList groups;
 
-    foreach (const KEntryKey& key, d->entryMap.keys())
+    Q_FOREACH (const KEntryKey& key, d->entryMap.keys())
         if (key.mKey.isNull() && !key.mGroup.isEmpty() &&
             key.mGroup != "<default>" && key.mGroup != "$Version")
             groups << QString::fromUtf8(key.mGroup);
@@ -211,7 +211,7 @@
     QByteArray theGroup = group + '\x1d';
     QSet<QString> groups;
 
-    foreach (const KEntryKey& key, entryMap.keys())
+    Q_FOREACH (const KEntryKey& key, entryMap.keys())
         if (key.mKey.isNull() && key.mGroup.startsWith(theGroup))
         {
             QString groupname = QString::fromUtf8(key.mGroup.mid(theGroup.length()));
@@ -294,7 +294,7 @@
         // Rewrite global/local config only if there is a dirty entry in it.
         bool writeGlobals = false;
         bool writeLocals = false;
-        foreach (const KEntry& e, d->entryMap) {
+        Q_FOREACH (const KEntry& e, d->entryMap) {
             if (e.bDirty) {
                 if (e.bGlobal) {
                     writeGlobals = true;
@@ -450,7 +450,7 @@
     // TODO: can we cache the values in etc_kderc / other global files
     //       on a per-application basis?
     const QByteArray utf8Locale = locale.toUtf8();
-    foreach(const QString& file, globalFiles) {
+    Q_FOREACH(const QString& file, globalFiles) {
         KConfigBackend::ParseOptions parseOpts = KConfigBackend::ParseGlobal|KConfigBackend::ParseExpansions;
         if (file != sGlobalFileName)
             parseOpts |= KConfigBackend::ParseDefaults;
@@ -477,7 +477,7 @@
         QList<QString> files;
 
         if (wantDefaults())
-            foreach (const QString& f, componentData.dirs()->findAllResources(resourceType, fileName))
+            Q_FOREACH (const QString& f, componentData.dirs()->findAllResources(resourceType, fileName))
                 files.prepend(f);
         else
             files << mBackend->filePath();
@@ -488,7 +488,7 @@
 //        qDebug() << "parsing local files" << files;
 
         const QByteArray utf8Locale = locale.toUtf8();
-        foreach(const QString& file, files) {
+        Q_FOREACH(const QString& file, files) {
             KConfigBackend::ParseOptions parseOpts;
             if (allowExecutableValues)
                 parseOpts |= KConfigBackend::ParseExpansions;
@@ -524,7 +524,7 @@
 void KConfig::addConfigSources(const QStringList& files)
 {
     Q_D(KConfig);
-    foreach(const QString& file, files) {
+    Q_FOREACH(const QString& file, files) {
         d->extraFiles.push(file);
     }
 
@@ -626,16 +626,16 @@
     QSet<QByteArray> groups;
     groups << aGroup;
 
-    foreach (const KEntryKey& key, d->entryMap.keys()) {
+    Q_FOREACH (const KEntryKey& key, d->entryMap.keys()) {
         if (key.mKey.isNull() && key.mGroup.startsWith(theGroup)) {
             groups << key.mGroup;
         }
     }
 
     bool dirty = false;
-    foreach (const QByteArray& group, groups) {
+    Q_FOREACH (const QByteArray& group, groups) {
         const QStringList keys = keyList(QString::fromUtf8(group));
-        foreach (const QString& key, keys) {
+        Q_FOREACH (const QString& key, keys) {
             if (d->canWriteEntry(group, key.toUtf8().constData())) {
                 d->entryMap.setEntry(group, key.toUtf8(), QByteArray(), options);
                 dirty = true;
Index: kdecore/config/kconfigini.cpp
===================================================================
--- kdecore/config/kconfigini.cpp	(revisión: 797670)
+++ kdecore/config/kconfigini.cpp	(copia de trabajo)
@@ -237,7 +237,7 @@
     }
 
     // now make sure immutable groups are marked immutable
-    foreach(const QByteArray& group, immutableGroups) {
+    Q_FOREACH(const QByteArray& group, immutableGroups) {
         entryMap.setEntry(group, QByteArray(), QByteArray(), KEntryMap::EntryImmutable);
     }
 
Index: kdecore/config/kconfigbackend.cpp
===================================================================
--- kdecore/config/kconfigbackend.cpp	(revisión: 797670)
+++ kdecore/config/kconfigbackend.cpp	(copia de trabajo)
@@ -73,7 +73,7 @@
         KService::List offers = KServiceTypeTrader::self()->query("KConfigBackend", constraint);
 
         //qDebug() << "found" << offers.count() << "offers for KConfigBackend plugins with name" << system;
-        foreach (const KService::Ptr offer, offers) {
+        Q_FOREACH (const KService::Ptr offer, offers) {
             backend = offer->createInstance<KConfigBackend>(0);
             if (backend) {
                 //qDebug() << "successfully created a backend for" << system;
Index: kdecore/config/kconfiggroup.cpp
===================================================================
--- kdecore/config/kconfiggroup.cpp	(revisión: 797670)
+++ kdecore/config/kconfiggroup.cpp	(copia de trabajo)
@@ -795,7 +795,7 @@
         return aDefault;
 
     QVariantList value;
-    foreach(const QString& v, KConfigGroupPrivate::deserializeList(data))
+    Q_FOREACH(const QString& v, KConfigGroupPrivate::deserializeList(data))
         value << v;
 
     return value;
@@ -929,7 +929,7 @@
 
     QList<QByteArray> balist;
 
-    foreach(const QString &entry, list)
+    Q_FOREACH(const QString &entry, list)
         balist.append(entry.toUtf8());
 
     writeEntry(key, KConfigGroupPrivate::serializeList(balist), flags);
@@ -947,7 +947,7 @@
 
     QList<QByteArray> data;
 
-    foreach(const QVariant& v, list) {
+    Q_FOREACH(const QVariant& v, list) {
         if (v.type() == QVariant::ByteArray)
             data << v.toByteArray();
         else
@@ -1163,7 +1163,7 @@
     Q_ASSERT_X(!d->bConst, "KConfigGroup::writePathEntry", "writing to a read-only group");
 
     QList<QByteArray> list;
-    foreach(const QString& path, value)
+    Q_FOREACH(const QString& path, value)
         list << translatePath(path).toUtf8();
 
     config()->d_func()->putData(d->fullName(), pKey, KConfigGroupPrivate::serializeList(list), pFlags, true);
Index: kdecore/io/kdebug.cpp
===================================================================
--- kdecore/io/kdebug.cpp	(revisión: 797670)
+++ kdecore/io/kdebug.cpp	(copia de trabajo)
@@ -467,7 +467,7 @@
             // gcc 4.1.2 don't put a space between the return type and
             // the function name if the function is in an anonymous namespace
             int index = 1;
-            forever {
+            Q_FOREVER {
                 index = info.indexOf("<unnamed>::", index);
                 if ( index == -1 )
                     break;
Index: kdecore/io/kautosavefile.cpp
===================================================================
--- kdecore/io/kautosavefile.cpp	(revisión: 797670)
+++ kdecore/io/kautosavefile.cpp	(copia de trabajo)
@@ -178,7 +178,7 @@
     KAutoSaveFile * asFile;
 
     // contruct a KAutoSaveFile for each stale file
-    foreach(const QString &file, files) {
+    Q_FOREACH(const QString &file, files) {
         // sets managedFile
         asFile = new KAutoSaveFile(filename);
         asFile->setFileName(file);
@@ -208,7 +208,7 @@
     KAutoSaveFile * asFile;
 
     // contruct a KAutoSaveFile for each stale file
-    foreach(file, files) {
+    Q_FOREACH(file, files) {
         sep = file.right(3);
         file.chop(KAutoSaveFilePrivate::padding);
 
Index: kdecore/io/ksavefile.cpp
===================================================================
--- kdecore/io/ksavefile.cpp	(revisión: 797670)
+++ kdecore/io/ksavefile.cpp	(copia de trabajo)
@@ -345,7 +345,7 @@
     d.setSorting( QDir::Name );
 
     uint maxBackupFound = 0;
-    foreach ( const QFileInfo &fi, d.entryInfoList() ) {
+    Q_FOREACH ( const QFileInfo &fi, d.entryInfoList() ) {
         if ( fi.fileName().endsWith( backupExtension ) ) {
             // sTemp holds the file name, without the ending backupExtension
             QString sTemp = fi.fileName();
Index: kdecore/kconfig_compiler/kconfig_compiler.cpp
===================================================================
--- kdecore/kconfig_compiler/kconfig_compiler.cpp	(revisión: 797670)
+++ kdecore/kconfig_compiler/kconfig_compiler.cpp	(copia de trabajo)
@@ -1091,7 +1091,7 @@
   out << " = v;" << endl;
 
   if ( !e->signalList().empty() ) {
-    foreach(const Signal &signal, e->signalList()) {
+    Q_FOREACH(const Signal &signal, e->signalList()) {
       out << "  " << This << varPath("settingsChanged") << " |= " << signalEnumName(signal.name) << ";" << endl;
     }
     out << "}" << endl;
@@ -1571,7 +1571,7 @@
   if( hasSignals ) {
     h << endl;
     h << "  Q_SIGNALS:";
-    foreach(const Signal &signal, signalList) {
+    Q_FOREACH(const Signal &signal, signalList) {
       h << endl;
       if ( !signal.label.isEmpty() ) {
         h << "    /**" << endl;
@@ -2021,7 +2021,7 @@
     cpp << "void " << className << "::" << "usrWriteConfig()" << endl;
     cpp << "{" << endl;
     cpp << "  " << inherits << "::usrWriteConfig();" << endl << endl;
-    foreach(const Signal &signal, signalList) {
+    Q_FOREACH(const Signal &signal, signalList) {
       cpp << "  if ( " << varPath("settingsChanged") << " & " << signalEnumName(signal.name) << " ) " << endl;
       cpp << "    emit " << signal.name << "(";
       QList<SignalArguments>::ConstIterator it, itEnd = signal.arguments.constEnd();
Index: kdecore/util/kshell_win.cpp
===================================================================
--- kdecore/util/kshell_win.cpp	(revisión: 797670)
+++ kdecore/util/kshell_win.cpp	(copia de trabajo)
@@ -125,7 +125,7 @@
 
     int p = 0;
     const int length = args.length();
-    forever {
+    Q_FOREVER {
         while (p < length && isWhiteSpace(args[p].unicode()))
             ++p;
         if (p == length)
@@ -133,7 +133,7 @@
 
         QString arg;
         bool inquote = false;
-        forever {
+        Q_FOREVER {
             bool copy = true; // copy this char
             int bslashes = 0; // number of preceding backslashes to insert
             while (p < length && args[p] == bs) {
Index: kdecore/util/kpluginfactory.cpp
===================================================================
--- kdecore/util/kpluginfactory.cpp	(revisión: 797670)
+++ kdecore/util/kpluginfactory.cpp	(copia de trabajo)
@@ -107,7 +107,7 @@
         QList<KPluginFactoryPrivate::Plugin> clashes(d->createInstanceHash.values(keyword));
         const QMetaObject *superClass = metaObject->superClass();
         if (superClass) {
-            foreach (const KPluginFactoryPrivate::Plugin &plugin, clashes) {
+            Q_FOREACH (const KPluginFactoryPrivate::Plugin &plugin, clashes) {
                 for (const QMetaObject *otherSuper = plugin.first->superClass(); otherSuper;
                         otherSuper = otherSuper->superClass()) {
                     if (superClass == otherSuper) {
@@ -116,7 +116,7 @@
                 }
             }
         }
-        foreach (const KPluginFactoryPrivate::Plugin &plugin, clashes) {
+        Q_FOREACH (const KPluginFactoryPrivate::Plugin &plugin, clashes) {
             superClass = plugin.first->superClass();
             if (superClass) {
                 for (const QMetaObject *otherSuper = metaObject->superClass(); otherSuper;
@@ -172,7 +172,7 @@
     const QList<KPluginFactoryPrivate::Plugin> candidates(d->createInstanceHash.values(keyword));
     // for !keyword.isEmpty() candidates.count() is 0 or 1
 
-    foreach (const KPluginFactoryPrivate::Plugin &plugin, candidates) {
+    Q_FOREACH (const KPluginFactoryPrivate::Plugin &plugin, candidates) {
         for (const QMetaObject *current = plugin.first; current; current = current->superClass()) {
             if (0 == qstrcmp(iface, current->className())) {
                 if (obj) {
Index: knewstuff/knewstuff2/engine.cpp
===================================================================
--- knewstuff/knewstuff2/engine.cpp	(revisión: 797670)
+++ knewstuff/knewstuff2/engine.cpp	(copia de trabajo)
@@ -170,7 +170,7 @@
     KNS::Entry::List tempList = engine->downloadDialogModal(0);
 
     // copy the list since the entries will be deleted when we delete the engine
-    foreach (Entry * entry, tempList) {
+    Q_FOREACH (Entry * entry, tempList) {
         entries << new Entry(*entry);
     }
     delete engine;
Index: knewstuff/knewstuff2/core/entryhandler.cpp
===================================================================
--- knewstuff/knewstuff2/core/entryhandler.cpp	(revisión: 797670)
+++ knewstuff/knewstuff2/core/entryhandler.cpp	(copia de trabajo)
@@ -115,7 +115,7 @@
     if (!entry.checksum().isEmpty()) {
         (void)addElement(doc, el, "checksum", entry.checksum());
     }
-    foreach(const QString &file, entry.installedFiles()) {
+    Q_FOREACH(const QString &file, entry.installedFiles()) {
         (void)addElement(doc, el, "installedfile", file);
     }
 
Index: knewstuff/knewstuff2/core/coreengine.cpp
===================================================================
--- knewstuff/knewstuff2/core/coreengine.cpp	(revisión: 797670)
+++ knewstuff/knewstuff2/core/coreengine.cpp	(copia de trabajo)
@@ -1549,7 +1549,7 @@
 {
     entry->setStatus(Entry::Deleted);
 
-    foreach(const QString &file, entry->installedFiles()) {
+    Q_FOREACH(const QString &file, entry->installedFiles()) {
         if (file.endsWith('/')) {
             QDir dir;
             bool worked = dir.rmdir(file);
@@ -1597,7 +1597,7 @@
 QStringList KNS::CoreEngine::archiveEntries(const QString& path, const KArchiveDirectory * dir)
 {
     QStringList files;
-    foreach(const QString &entry, dir->entries()) {
+    Q_FOREACH(const QString &entry, dir->entries()) {
         QString childPath = path + '/' + entry;
         if (dir->entry(entry)->isFile()) {
             files << childPath;
